<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库存储和查询</title>
      <link href="/2023/07/11/shu-ju-ku-cun-chu-he-cha-xun/"/>
      <url>/2023/07/11/shu-ju-ku-cun-chu-he-cha-xun/</url>
      
        <content type="html"><![CDATA[<h4 id="存储和文件结构"><a href="#存储和文件结构" class="headerlink" title="存储和文件结构"></a>存储和文件结构</h4><ul><li><p><strong>磁盘块访问的优化</strong>：</p><ul><li>缓冲：从磁盘读取的块暂时存储在内存缓冲区</li><li>预读：一个磁盘块被访问时，相同磁道的连续块也被读入内存缓冲区</li><li>调度：磁盘调度算法</li><li>文件组织：按照与预期数据访问方式最接近的方式组织磁盘上的块</li><li>非易失性写缓冲区：加速写磁盘操作，先写到缓冲区通知写完成再写到磁盘</li><li>日志磁盘：连续写，系统恢复后可以继续写</li></ul></li><li><p><strong>RAID</strong>：</p><ul><li>RAID 0级：没有任何冗余</li><li>RAID 1级：镜像磁盘</li><li>RAID 2级：内存风格的纠错码，使用奇偶校验位实现错误检测和纠正</li><li>RAID 3级：位交叉奇偶校验，使用单一的奇偶校验位来检错和纠错</li><li>RAID 4级：块交叉的奇偶校验</li><li>RAID 5级：块交叉的分布奇偶校验，每个磁盘都存储奇偶校验位，而不是像RAID 4 单独一张盘存储校验位</li><li>RAID 6级：P+Q冗余，存储了额外的冗余信息，可以应对多张盘发生故障，不采用奇偶校验</li></ul></li><li><p><strong>文件组织</strong>：</p><ul><li>定长记录：长度固定。文件开始处，分配一定数量的字节作为文件头，文件头包含有关文件的各种信息。可存储内容被删除的第一个记录地址，用第一个记录存储第二个可用记录地址形成空闲列表。</li><li>变长记录：分槽的页结构</li></ul></li><li><p><strong>文件中记录的组织</strong>：</p><ul><li>堆文件组织：任意存储</li><li>顺序文件组织</li><li>散列文件组织</li><li>多表聚簇文件组织：通常每个关系的记录用到单独的文件存储。其几个不同的关系的记录存储到同一个文件，可以高效的执行特定查询。</li></ul></li><li><p><strong>数据库缓冲区</strong>：缓冲区是主存储器中用于存储磁盘块的拷贝的部分</p><ul><li>缓冲区管理器：负责缓冲区空间分配的子系统。<ul><li>缓冲区替换策略：如最近最少使用</li><li>被钉住的块：当一个块正在更新时不允许写回磁盘。不允许写回磁盘的块叫被钉住的块</li><li>块的强制写出：把块强制写回磁盘</li></ul></li></ul></li></ul><h4 id="索引与散列"><a href="#索引与散列" class="headerlink" title="索引与散列"></a>索引与散列</h4><ul><li><p><strong>顺序索引</strong>：</p><ul><li>聚集索引（主索引）：搜索码指定的顺序与文件中记录的物理顺序相同</li><li>稠密索引：文件中的每个搜索码值都有一个索引项。查找块</li><li>稀疏索引：只为搜索码的某些值建立索引项。只有当关系按照搜索码顺序存储时（聚集索引）才能使用稀疏索引。所占空间小，插入和删除所需维护开销小</li><li>多级索引</li><li>辅助索引：不是主索引的索引。必须是稠密索引，对每个搜索码值都有一个索引项，而且对文件的每一条记录都有一个指针。</li></ul></li><li><p><strong>B+树索引</strong>：</p><ul><li>插入：叶结点中仍有空间；叶结点溢出；非叶结点溢出；分裂、新根结点</li><li>删除：叶结点内直接删除；页结点与兄弟结点合并；从兄弟结点借键；合并根结点</li><li>结点分裂、合并会影响到辅助索引更新指针，为此：在辅助索引中，不存储指向被索引的记录的指针，而是存储主索引搜索码属性的值。现在辅助索引定位记录需两步：首先用辅助索引找到主索引搜索码的值，然后用主索引找对应记录。</li></ul></li><li><p><strong>静态散列（散列索引）</strong>：</p><ul><li>散列函数：分布均匀、随机</li><li>桶（存储一条或多条记录的存储单位）溢出：<ul><li>原因：桶不足；偏斜（某些桶分配记录多，其他桶仍有空间）</li><li>溢出桶解决桶溢出问题：若桶已满则插入到溢出桶中，形成溢出链。这种散列结构称为闭地址。</li><li>开地址：桶固定，没有溢出链，桶满后将其插入其他桶。在数据库重要性不大</li></ul></li></ul></li><li><p><strong>动态散列</strong>：散列函数动态改变适应数据库增大或缩小</p><ul><li><p>数据结构：通过桶的分裂或合并适应数据库大小变化。选择的散列函数的值范围较大，是b位二进制整数，一个典型的b值是32，使用 高i 位标记桶，i随数据库大小变化而增大或减小。</p></li><li><p>查询和更新</p><ul><li>插入：若桶满，则分裂这个桶并对记录重新分配。分裂桶需要确定是否增加位数，如果只有一个表项指向桶，则多引入一位；如果多个表项指向桶不需要增加位数</li><li>删除：桶空删除。位数也应随之变化</li></ul></li><li><p>线性散列：使用低i位标记桶。与上述可扩充散列不同的是线性散列不使用间接层（桶地址表）</p></li></ul></li><li><p><strong>多维索引结构</strong>：</p><ul><li><p>类散列方法</p><ul><li>网格文件：存储指向记录的指针。根据每维的分量确定所属的桶，桶没有空间可以添加溢出块或通过增加或移动网格重组结构。适用范围查询和最临近查询</li><li>分段散列函数：适用部分匹配查询</li></ul></li><li><p>类树方法</p><ul><li>多键索引</li><li>kd-树：内部结点有一对属性和值将数据点分成两部分，所有维的属性在层间交替出现，叶子层为存储记录的存储块。</li><li>四叉树</li><li>R树（区域树）</li></ul></li><li><p>位图索引：关系有n个记录，字段有m种取值，则位图索引是m个长度为n的位向量集合。位图索引只是找到记录号，但是记录对应的磁盘地址不知道，可以创建一个辅助索引，索引项是记录号和记录地址。</p><ul><li><p>压缩位图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">对位图进行压缩，i个0和后面的一个1是一个段，对段进行编码</span><br><span class="line">0000 0000 0000 01//13个0,log2(13) = 4,所以编码为：</span><br><span class="line">11101101            //1110表示后面4位是有效值,1101表示13个0和一个1</span><br><span class="line">特殊:如果没有0,编码00;如果1个0，编码01</span><br><span class="line">例如:100000001000 -&gt; 00 110111</span><br><span class="line">1-&gt;00</span><br><span class="line">00000001-&gt;110111</span><br><span class="line">000-&gt;忽略</span><br><span class="line">解码:111011011011-&gt;0000 0000 0000 01 1 0001</span><br><span class="line">11101101-&gt;0000 0000 0000 01</span><br><span class="line">00-&gt;1</span><br><span class="line">1011-&gt;0001</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h4><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><ul><li><p><strong>等价规则</strong></p><ul><li><p>合取选择运算可分解为单个选择运算的序列 <code>在关系E上选择a和b属性，可分解为在E上取a属性的基础上取b属性</code></p></li><li><p>选择运算满足交换律</p></li><li><p>一系列投影运算中只有最后一个运算是必须的，其余可省略</p></li><li><p>选择操作可与笛卡尔积以及θ连接相结合</p><p><img src="https://img8.php1.cn/3cdc5/fd11/bdf/7b0a2aa1f1fa1468.png" alt="选择操作可与笛卡尔积以及θ连接相结合"></p></li><li><p>θ连接运算满足交换律</p><p><img src="https://img8.php1.cn/3cdc5/fd11/bdf/ac88ac68dc7c04af.png"></p></li><li><p>选择运算在下面两个条件下对θ连接运算具有分配律</p><p><img src="https://kgithub.com/RonronnerW/RonronnerW.github.io/blob/master/img/db1.png?raw=true"></p></li><li><p>投影运算在下面条件下对θ连接运算具有分配律</p><p><img src="https://kgithub.com/RonronnerW/RonronnerW.github.io/blob/master/img/db2.png?raw=true"></p></li><li><p>集合的并于交满足交换律和结合律</p></li><li><p>选择运算对并、交、差运算具有分配律</p></li><li><p>投影运算对并运算具有分配律</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/2023/07/06/shu-ju-ku-she-ji/"/>
      <url>/2023/07/06/shu-ju-ku-she-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="数据库设计和E-R模型"><a href="#数据库设计和E-R模型" class="headerlink" title="数据库设计和E-R模型"></a>数据库设计和E-R模型</h4><ul><li><p><strong>E-R模型</strong>：</p><ul><li>实体集：相同类型或性质的实体的集合。如大学的教师就是一个实体集。</li><li>联系集：联系指多个实体间的关联。联系集是相同类型联系的集合。</li><li>属性：属性可取值的集合叫域<ul><li>简单属性：不能划分更小的部分</li><li>复合属性：可以再划分，如地址</li><li>单值属性：如id</li><li>多值属性：如电话</li><li>派生属性：属性值不存储，需要时计算，如根据出生计算年龄</li></ul></li></ul></li><li><p><strong>约束</strong>：</p><ul><li>映射基数：表示一个实体通过联系集能关联的实体个数。有一对一、一对多、多对一和多对多</li><li>参与约束：全部的或部分的：更具实体是否全部参与联系区分</li></ul></li><li><p><strong>E-R图</strong>：</p><ul><li><p>基本结构：</p><ul><li>分成两部分的矩形：实体集，属性加下划线表示主码</li><li>菱形：联系集</li><li>未分割的矩形：联系集的属性</li><li>线段：连接属性集和联系集</li><li>虚线：连接联系集属性和联系集</li></ul></li><li><p>映射基数：</p><ul><li>一对一：联系集到实体集的箭头</li><li>一对多&#x2F;多对一&#x2F;多对多：一用箭头，多用线段</li><li>线上用<code>l..h</code>标明最小和最大映射基数，*代表没有限制</li></ul></li></ul></li><li><p><strong>弱实体集</strong>：没有足够的属性以形成主码的实体集。弱实体集必须与称作标识或属主实体集的实体集关联才有意义。每个弱实体必须和一个标识实体关联</p></li></ul><h4 id="关系数据库设计："><a href="#关系数据库设计：" class="headerlink" title="关系数据库设计："></a>关系数据库设计：</h4><ul><li><p><strong>第一范式</strong>：关系的所有属性都是原子的（不可分的）。</p></li><li><p><strong>码和函数依赖</strong>：</p><ul><li>超码：子集K是超码的条件：关系r的实例中的所有元组对t1和t2总满足，若t1≠t2，则t1[K]≠t2[K]。</li><li>满足函数依赖 a-&gt;b 的条件：对所有元组对t1和t2，若t1[a]&#x3D;t2[a]，则t1[b]&#x3D;t2[b]</li></ul></li><li><p><strong>Boyce-Codd范式（BCNF）</strong>：</p><ul><li><p>对F的闭包中所有形如 a-&gt;b 的函数依赖，下面至少一项成立：</p><ol><li><p>a-&gt;b 是平凡的函数依赖（即b包含于a）</p></li><li><p>a 是关系模式的一个超码</p></li></ol></li><li><p>分解不属于BCNF模式的一般规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设R不属于BCNF，则存在至少一个非平凡的函数依赖 a-&gt;b ,其中a不是R的超码。以下面两个模式取代R：</span><br><span class="line">(a∪b)</span><br><span class="line">(R-(b-a))</span><br><span class="line">产生的模式仍有不属于BCNF的，则继续分解，直至最终都是BCNF</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>第三范式</strong>：</p><ul><li><p>对F的闭包中所有形如 a-&gt;b 的函数依赖，下面至少一项成立：</p><ol><li><p>a-&gt;b 是一个平凡的函数依赖</p></li><li><p>a 是 R 的一个超码</p></li><li><p>b-a 中的每个属性A都包含于R的一个候选码中（可能包含于不同的候选码中）</p></li></ol></li></ul></li><li><p><strong>函数依赖理论</strong>：</p><ul><li><p>公理：</p><ul><li>自反律：若a为一属性集且b包含于a，则a-&gt;b成立</li><li>增补律：若a-&gt;b成立且r，则r∪a-&gt;r∪b</li><li>传递律：a-&gt;b和b-&gt;r，则a-&gt;r</li><li>合并律：a-&gt;b和a-&gt;r，则a-&gt;b∪r</li><li>分解律：a-&gt;b∪r，则a-&gt;b和a-&gt;r</li><li>伪传递律：a-&gt;b和c∪b-&gt;r，则a∪c-&gt;r</li></ul></li><li><p>属性集的闭包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ret:=a;</span><br><span class="line">repeat</span><br><span class="line">for each 函数依赖 b-&gt;c in F do</span><br><span class="line">begin</span><br><span class="line">if b包含于ret then ret:=ret∪c;</span><br><span class="line">            end</span><br><span class="line">     until (ret不变)</span><br></pre></td></tr></table></figure></li><li><p>正则覆盖：是一个依赖集，其中任何函数依赖都不含无关属性（除去一个属性不影响闭包，则该属性是无关属性），函数依赖左半部都是唯一的。</p></li><li><p>无损分解</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计 E-R模型 关系数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系数据库</title>
      <link href="/2023/07/02/guan-xi-shu-ju-ku/"/>
      <url>/2023/07/02/guan-xi-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h4 id="码"><a href="#码" class="headerlink" title="码"></a>码</h4><ul><li><strong>超码</strong>：一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一标识一个元组。</li><li><strong>候选码</strong>：最小超码称为候选码。</li><li><strong>主码</strong>：选中用来在一个关系中区分不同元组的候选码。</li><li><strong>外码</strong>：一个关系模式<code>r1</code>可能在它的属性中包括另一个关系模式<code>r2</code>的主码，这个属性在<code>r1</code>上称作参照<code>r2</code>的外码。</li></ul><h4 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h4><ul><li>选择（σ）：返回满足谓词的行</li><li>投影（π）：对输入关系的所有行输出指定属性。从输出中去除重复元组</li><li>自然连接（⋈）：两个关系相同名称的属性自动进行记录匹配，结果去除重复属性列</li><li>笛卡尔积（×）：两个关系中输出所有元组对（无论他们共同属性上的取值是否相同）</li><li>并（∪）：输出两个关系的元组的并</li></ul><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><ul><li><p><strong>基本类型</strong>：</p><ul><li>char(n): 固定长度字符串。会追加空格使其达到串长度。</li><li>varchar(n): 可变长度字符串。不会追加空格</li><li>…</li></ul></li><li><p><strong>基本模式定义</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table department</span><br><span class="line">(dept_name varchar(20) not null,</span><br><span class="line">building varchar(15),</span><br><span class="line">primary key(dept_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>完整性约束：<ul><li><code>primary key(a)</code>：主码</li><li><code>foreign key(a) references B</code>：外码</li><li><code>not null</code>：不允许空值</li></ul></li></ul><p>插入元组：<code>insert into department values(&#39;wang&#39;,&#39;a&#39;);</code></p><p>删除元组：<code>delete from department</code></p><p>删除关系：<code>drop table department</code></p><p>为关系添加属性：<code>alter table department add A D</code>,A为属性，D为属性的域</p><p>去掉属性：<code>alter table department drop A</code></p></li><li><p><strong>查询的基本结构</strong>：</p><ul><li><p>单关系查询：<code>select dept_name from department;</code></p><ul><li>强行删除重复：<code>select distinct dept_name from department;</code></li><li>where 满足特定谓词：<code>select dept_name from department where ;</code></li></ul></li><li><p>多关系查询：把访问的关系都列在from中，where指定匹配条件</p></li><li><p>自然连接：<code>select name,course_id from instructor natural join teaches</code></p></li></ul></li><li><p><strong>附加的基本运算</strong>：</p><ul><li><p>更名运算：<code>old-name as new-name</code>，可以出现在<code>select</code>和<code>from</code>中</p></li><li><p>字符串运算：使用<code>Like</code>操作实现模式匹配</p><ul><li><code>%</code>：匹配任意子串</li><li><code>_</code>：匹配任意一个字符</li><li>使用<code>escape</code>定义转义字符。<code>like &#39;ab\%cd%&#39; escape &#39;\&#39;  匹配ab%cd开头字符串   </code></li></ul></li><li><p>正则表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mysql使用REGEXP</span><br><span class="line"></span><br><span class="line">^:匹配开始位置</span><br><span class="line">[A-Za-z]:匹配大小写字母</span><br><span class="line">[A-Za-z0-9_.-]:匹配字母(大写或小写)、数字、下划线 _、句点 .和/或横杠-的字符串</span><br><span class="line">*:匹配前面的子表达式零次或多次</span><br><span class="line">@leetcode[.]com:匹配@leetcode.com</span><br><span class="line">$:匹配结尾</span><br><span class="line"></span><br><span class="line">where mail REGEXP &#x27;^[A-Za-z][A-Za-z0-9_.-]*@leetcode[.]com$&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>排序：<code>order by  默认升序，可以用desc表示降序，asc表示升序</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from instrutor</span><br><span class="line">order by salary desc, name asc;</span><br></pre></td></tr></table></figure></li><li><p>where子句谓词：</p><ul><li><code>between A and B  表示一个值属于[A,B]</code></li><li><code>and   增加一个条件</code></li><li>元组比较运算：<code>(a1,a2) &lt;= (b1,b2) 表示a1&lt;=b1且a2&lt;=b2时为真</code></li></ul></li></ul></li><li><p><strong>集合运算</strong>：</p><ul><li><code>union</code>：并。自动去重复，保留重复必须用<code>union all</code></li><li><code>intersect</code>：交。同上</li><li><code>except</code>：差。同上</li></ul></li><li><p><strong>空值</strong>：</p><ul><li>算数运算：任一输入为空，结果为空</li><li>比较运算：涉及空值的比较运算结果为<code>unknown</code>，where子句谓词对一个元组计算出false或unknown都不能加入到结果集中。在谓词中<code>null = null</code>会返回unknown，而不是true。</li><li>集合运算</li></ul></li><li><p><strong>聚集函数</strong>：以值的一个集合为 输入，返回单个值的函数。例如：avg,min,max,sum,count</p><ul><li><p>基本聚集：计算元组个数使用<code>count(*)</code>，使用<code>count(*)</code>时不允许使用<code>distinct</code></p></li><li><p>分组聚集：<code>group by</code>给出一个或多个属性来构造分组。注意：出现在<code>select</code>中但是没有被聚集的属性只能是出现在<code>group by</code>子句中的那些属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//找出每个系的平均工资</span><br><span class="line">select dept_name,avg(salary) as avg_salary</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name;</span><br></pre></td></tr></table></figure></li><li><p>having 子句：对分组限定条件，跟在<code>group by</code>后面。having中的谓词在形成分组后才起作用，所以可以使用聚集函数。</p></li><li><p>对空值和布尔值的聚集：除了<code>count(*)</code>外所有聚集函数都忽略输入集合中的空值。空集的count运算值为0，其他聚集函数输入为空集情况下返回一个空值。</p></li></ul></li><li><p><strong>嵌套子查询</strong>：</p><ul><li><p>集合成员资格：<code>in</code>测试元组是否是集合中的成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct ID)</span><br><span class="line">from takes</span><br><span class="line">where (course_id,sec_id) in (select course_id,sec_id</span><br><span class="line">from teaches</span><br><span class="line">where tesches.ID = 10101);</span><br></pre></td></tr></table></figure></li><li><p>集合的比较：</p><ul><li><p>至少比某一个大: <code>&gt; some</code>, 也允许<code>&lt; some, &lt;= some, &gt;=some, =some等价于in, &lt;&gt; some并不等价于not in</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; some(select salary</span><br><span class="line">from instructor</span><br><span class="line">where dept_name = &#x27;Biology&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>比所有的都大：<code>&gt; all</code>, <code>&lt;&gt; all等价于not in, =all不等价于in</code></p></li></ul></li><li><p>空关系测试：子查询结果集中是否存在元组：<code>exists</code>，非空返回true；可将关系A包含关系B写成<code>not exists(B except A)</code></p></li><li><p>重复元组存在性测试：<code>unique</code>，没有重复返回true；</p></li><li><p>from子句中的子查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, avg_salary</span><br><span class="line">from (select dept_name,avg(salary)</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name</span><br><span class="line">as dept_avg(dept_name,avg_salary)) --as给子查询的结果关系起名字并对属性重命名</span><br><span class="line">where avg_salary &gt; 4200;</span><br></pre></td></tr></table></figure><p>from子句嵌套的子查询中不能使用来自from子句其他关系的相关变量，想要实现此操作需要以<code>lateral</code>作为前缀。</p></li><li><p>with子句：定义临时关系。例如找出最大预算值的系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with max_budget(value) as</span><br><span class="line">(select max(budget)</span><br><span class="line">from department)</span><br><span class="line">select budget</span><br><span class="line">from department,max_budget</span><br><span class="line">where department.budget = max_budget.value;</span><br></pre></td></tr></table></figure></li><li><p>标量子查询：返回包含单个属性的单个元组，可以出现在任何地方</p></li></ul></li><li><p>数据库的修改</p><ul><li><p>删除：<code>delete</code>删除元组, 只能作用于一个关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from r</span><br><span class="line">where P；</span><br></pre></td></tr></table></figure></li><li><p>插入：<code>insert</code>, 单个元组插入请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into course</span><br><span class="line">values(&#x27;101&#x27;,&#x27;DS&#x27;,4);</span><br></pre></td></tr></table></figure></li><li><p>更新：<code>update</code>, 改变元组部分属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update course</span><br><span class="line">set course_id = &#x27;102&#x27;;</span><br></pre></td></tr></table></figure><p>case语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">when pred1 then ret1</span><br><span class="line">when pres2 then ret2</span><br><span class="line">else retn</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="中级SQL"><a href="#中级SQL" class="headerlink" title="中级SQL"></a>中级SQL</h4><ul><li><p><strong>连接表达式</strong>：</p><ul><li><p>连接条件：<code>on</code>可以指定任意的连接条件, 出现在连接表达式的末尾</p><p><code>on</code>和<code>where</code>在外连接中的表现不同：on条件是外连接声明的一部分，where子句却不是。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from student join takes on student.ID = takes.ID;</span><br></pre></td></tr></table></figure></li><li><p>外连接：通过在结果中创建空值元组的方式，保留连接中丢失的元组</p><ul><li><p>左外连接：只保留出现在左外连接运算之前左边关系的元组,其余属性为空值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from student natural left outer join takes;</span><br></pre></td></tr></table></figure></li><li><p>右外连接：保留右边  <code>natural right outer join</code></p></li><li><p>全外连接：两边都保留  <code>natural full outer join</code></p></li></ul></li></ul></li><li><p><strong>视图</strong>：从基本表中导出的虚拟的表，数据库存储视图定义本身，而不存储执行结果。</p><ul><li><p>视图定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create view view_name as</span><br><span class="line">&lt; query ecpression&gt;</span><br></pre></td></tr></table></figure></li><li><p>物化视图：允许存储视图关系，但是必须保证：定义视图的实际关系变化时，视图也随之修改。物化视图查询很快，避免了读取大量底层关系。</p></li><li><p>视图更新：一般不允许对视图关系进行修改</p></li></ul></li><li><p><strong>完整性约束</strong>：作用于创建关系命令的一部分被声明，也可以通过<code>alter table table_name add ...</code>命令施加到关系上</p><ul><li><code>not null</code>：禁止主码出现空值，因此主码不必再显式声明为not null</li><li><code>unique</code>：声明属性形成一个候选码，没有两个元组能在所列出的属性上取值相同</li><li><code>check</code>：保证属性值满足指定的条件。例如：<code>check(budget&gt;0)</code></li><li>参照完整性：外码</li></ul></li><li><p><strong>SQL数据类型于模式</strong>：</p><ul><li><p>日期和时间：<code>data:日期; time:时间; timestamp:data于time的组合</code></p></li><li><p>默认值：<code>default 0:默认值为0</code></p></li><li><p>创建索引：高效的查找而不用扫描关系中的所有元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index student_index on student(ID);</span><br></pre></td></tr></table></figure></li><li><p>大对象类型：例如图片等。字符数据的大对象数据类型（clob）、二进制数据的大对象数据类型（blob）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book_review clob (10KB)</span><br><span class="line">image blob (10MB)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>授权</strong>：</p><ul><li><p>权限的授予与收回：默认情况下，被授予权限的用户&#x2F;角色无权将权限再授予其他用户&#x2F;角色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &lt;权限列表&gt;--select/insert/update/delete</span><br><span class="line">on &lt;关系/视图&gt;</span><br><span class="line">to &lt;用户/角色列表&gt;;   --public指系统的所有当前用户和将来的用户</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revoke &lt;权限列表&gt;</span><br><span class="line">on &lt;关系/视图&gt;</span><br><span class="line">from &lt;用户/角色列表&gt;;</span><br></pre></td></tr></table></figure></li><li><p>角色：</p><ul><li>创建角色：<code>create role instrutor;</code></li><li>授予权限：同上</li><li>角色可以授予用户&#x2F;角色：<code>grant A to B;</code></li></ul></li><li><p>权限的转移：允许将得到的权限传递给其他用户，需要附加<code>with grant option</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on department to Amit with grant option;</span><br></pre></td></tr></table></figure></li><li><p>权限的收回：大多数数据库系统中，权限收回默认是级联的。可以申明restrict防止级联收回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke select on departmnet from Amit restrict;--防止级联收回</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h4><ul><li><p><strong>函数和过程</strong>：输入自己的函数和过程通常用<code>create or replace</code>对旧代码替换。SQL支持函数重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//函数：给定系名返回教师数目</span><br><span class="line">create function dept_count(dept_name varchar(20))</span><br><span class="line">returns integer</span><br><span class="line">begin</span><br><span class="line">declare d_count integer;</span><br><span class="line">select count(*) into d_count</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dpt_name = dept_name</span><br><span class="line">return d_count;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//过程：in和out 分别表示参数和返回值</span><br><span class="line">create procedure dept_count(in dept_name varchar(20),out d_count integer)</span><br><span class="line">begin</span><br><span class="line">select count(*) into d_count</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dept_name = dept_name</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>表函数：返回关系作为结果的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create function instrutor_of(dept_name varchar(20))</span><br><span class="line">return table(</span><br><span class="line">ID varchar(5),</span><br><span class="line">name varchar(20))</span><br><span class="line">return table</span><br><span class="line">(select ID,name</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dept_name = dept_name);</span><br></pre></td></tr></table></figure></li><li><p><strong>触发器</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create trigger check after insert on section--插入元组后启动触发器</span><br><span class="line">referencing new row as nrow--建立一个过渡变量用来在插入完成后存储所插入值</span><br><span class="line">for each row--插入多个元组时，可以显式迭代每一个元组</span><br><span class="line">when (nrow.id not in(--when指定一个条件</span><br><span class="line">select slot_id</span><br><span class="line">from slot))</span><br><span class="line">begin--触发器执行</span><br><span class="line">rollback--回滚</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/06/23/c/"/>
      <url>/2023/06/23/c/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>预处理器</strong>：</p><p><code>#define</code> 指令把一个名字设定为预处理变量</p><p><code>#ifdef</code> 当且仅当变量已定义时为真，<code>#ifndef</code> 当且仅当变量未定义时为真。一旦结果为真则执行后续操作直到遇到<code>#endif</code>指令为止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">std::string bookNo;</span><br><span class="line">unsigned units_sold  = 0;</span><br><span class="line">double revenue = 0.0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>第一次包含<code>Sales_data.h</code>时，<code>#ifndef</code>检查结果为真，预处理器执行后面操作直到遇到<code>#endif</code>。此时SALES_DATA_H值变为已定义，<code>Sales_data.h</code>也会被拷贝到程序中。后面再次包含<code>Sales_data.h</code>时检查结果为假，编译器忽略。</p></li><li><p><strong>声明和定义</strong>： </p><ul><li><p>声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含那个名字的声明。定义负责创建与名字关联的实体。声明规定了变量的类型和名字，定义还申请存储空间，也可能赋一个初值。</p></li><li><p>想声明而非定义变量，就在变量名前添加关键字<code>extern</code>, 而且不要显式地初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明</span><br><span class="line">int j; //定义</span><br><span class="line">extern int i = 1; //定义 任何包含显式初始化的声明成为定义</span><br></pre></td></tr></table></figure></li><li><p>多个文件中使用同一个变量，就必须声明和定义分离。此时，定义必须出现且只能出现在一个文件中，其他文件中对其声明。</p></li></ul></li><li><p><strong>复杂的数组声明</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *ptrs[10];//从右往左理解，表示含有十个整型指针的数组</span><br><span class="line">int (*parray)[10] = &amp;arr;//从内往外理解，parray指向一个含有10个整数的数组</span><br><span class="line">int (&amp;arrref)[10] = arr;//从内往外理解，arrref引用一个含有10个整数的数组</span><br><span class="line">int *(&amp;array)[10] = ptrs;//array是数组的引用，该数组含有10个指针</span><br></pre></td></tr></table></figure></li><li><p><strong>指针与引用</strong>：</p><ul><li><p>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针生命周期内它可以先后指向不同的对象。</p></li><li><p>指针无需再定义时赋初值。</p></li><li><p>引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p></li><li><p>一旦定义引用就无法再绑定到另外的对象，之后每次使用这个引用都是访问最初绑定的对象。</p></li><li><p>指向指针的引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int *p;//p是指针</span><br><span class="line">int *&amp;r = p;//r是一个对指针p的引用. 从右往左，首先r是一个引用，然后引用的是一个int指针</span><br><span class="line">r = &amp;i;//r引用了一个指针，和r赋值&amp;i就是另p指向i</span><br><span class="line">*r = 0;//解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>深拷贝和浅拷贝</strong>：</p><ul><li><p>浅拷贝：简单的赋值拷贝操作</p></li><li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">//浅拷贝</span><br><span class="line">Person(int age ,int height) &#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = height;</span><br><span class="line">&#125;</span><br><span class="line">//深拷贝</span><br><span class="line">Person(int age ,int height) &#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = new int(height);</span><br><span class="line">&#125;</span><br><span class="line">//析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">if (m_height != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">int* m_height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数指针</strong>：指向函数的指针。函数的类型由返回类型和形参类型共同决定，与函数名无关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool (*pf)(const int&amp; a, const int&amp; b);//函数指针，pf指向一个函数，返回值是bool类型</span><br><span class="line">bool *pf(const int&amp; a, const int&amp; b);//指针函数，名为pf的函数，返回bool*</span><br><span class="line"></span><br><span class="line">bool compare(const int&amp; a, const int&amp; b);</span><br><span class="line">//把函数名作为一个值使用时，该函数自动转换成指针</span><br><span class="line">pf = compare;//pf指向名为compare的函数</span><br><span class="line">pf = &amp;compare;//等价，取地址符是可选的</span><br></pre></td></tr></table></figure></li><li><p><strong><code>const</code>作用</strong>：</p><ol><li><p>定义常量</p></li><li><p>类型检查。const与#define定义常量的区别：const常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，只是简单的字符替换，不能进行安全检查。</p></li><li><p>修饰指针，分为指向常量的指针和指针常量</p></li><li><p>常量引用，经常用于形参，既避免了拷贝，又避免了函数对值的修改</p></li><li><p>修饰成员函数，说明成员函数内不能修改成员变量</p></li></ol></li><li><p><strong><code>const</code>的引用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line">const int &amp;r1 = ci;// 正确，引用及其对象都是常量</span><br><span class="line">int &amp;r2 = ci;// 错误，试图让一个非常量引用指向一个常量对象</span><br><span class="line"></span><br><span class="line">int i = 42;</span><br><span class="line">const int &amp;r3 = i;// 正确，允许将const int&amp;绑定到一个普通int对象上</span><br></pre></td></tr></table></figure></li><li><p>**指针和<code>const</code>**：</p><ul><li><p><strong>指向常量的指针（<code>pointer to const</code>）</strong>: 不能用于改变其所指对象的值。要想存放常量对象地址，只能使用指向常量的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int *a;//指向常量的指针</span><br><span class="line">int const *a;//同上。cosnt位于*的左侧，则const用来修饰指针指向的变量</span><br><span class="line">*a = 10;//错误</span><br><span class="line"></span><br><span class="line">//允许把非const对象地址赋给指向const对象的指针</span><br><span class="line">const int *ptr;</span><br><span class="line">int val = 3;</span><br><span class="line">ptr = &amp;val;//正确，但是不能通过ptr指针修改val</span><br></pre></td></tr></table></figure></li><li><p><strong><code>const</code>指针（<code>const pointer</code>）</strong>：常量指针，必须初始化且初始化后值不能再改变。把*放在<code>const</code>之前说明指针是一个常量，意味着不变的是指针本身的值而非指向的那个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;</span><br><span class="line">int *const cur = &amp;num;//cur 将一直指向num</span><br><span class="line">//从右往左阅读，离cur最近的是const，意味着cur本身是一个常量对象，对象的类型为int*，</span><br><span class="line">//即cur是一个常量指针，该常量指针指向一个int对象</span><br><span class="line"></span><br><span class="line">const double pi = 3.14;</span><br><span class="line">const double *const pip = &amp;pi;//pip是一个指向常量对象的常量指针</span><br><span class="line">//pip本身是一个常量对象，对象类型是const double*，表示pip是一个指向常量的常量指针</span><br></pre></td></tr></table></figure></li></ul></li><li><p>**顶层<code>const</code>**：顶层<code>const</code>表示指针本身是常量，底层<code>const</code>表示指针所指对象是一个常量。更一般的，顶层<code>const</code>可以表示任意的对象是常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *const p1 = &amp;i;//不能改变p1的值，顶层const</span><br><span class="line">const int ci = 42;//不能改变ci的值，顶层const</span><br><span class="line">const int *p2 = &amp;ci;//允许改变p2的值，底层const</span><br><span class="line">const int *const p3 = p2;//靠右的const的顶层，靠左的是底层</span><br><span class="line">const int &amp;r = ci;//声明引用的const都是底层</span><br></pre></td></tr></table></figure><p>拷贝操作时，顶层<code>const</code>不受影响，底层<code>const</code>必须具有相同的底层<code>const</code>资格，一般来说非常量可以转换成常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = ci;//正确</span><br><span class="line">p2 = p3;//正确，p2和p3指向对象类型相同，p3顶层const部分不影响</span><br><span class="line"></span><br><span class="line">int *p = p3;//错误，p3包含底层const定义而p没有</span><br><span class="line">p2 = &amp;i;//正确，int*能转换成const int*</span><br><span class="line">int &amp;r = ci;//错误，普通的int不能绑定到int常量上</span><br><span class="line">const int &amp;r2 = i;//正确，const int&amp;可以绑定到普通的int上</span><br></pre></td></tr></table></figure></li><li><p><strong>static</strong>：</p><ul><li><p>静态变量：变量声明为static时，空间将在程序的生命周期内分配，只分配一次。类中的静态变量由对象共享，不能使用构造函数初始化，应使用类外的类名和范围解析运算符显式初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Apple&#123;</span><br><span class="line">public:</span><br><span class="line">static int i;</span><br><span class="line">&#125;</span><br><span class="line">int Apple::i = 0;</span><br></pre></td></tr></table></figure></li><li><p>静态成员：</p><ul><li>类对象为静态：对象的生命周期直到程序结束。</li><li>类中的静态函数：允许静态成员函数仅访问静态数据成员和其他静态成员函数，无法访问非静态成员和函数。</li></ul></li></ul></li><li><p><strong>重载和<code>const</code>形参</strong>：</p><ul><li><p>顶层<code>const</code>不影响传入函数的对象。一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(Phone);</span><br><span class="line">Record lookup(cosnt Phone);//重复声明</span><br><span class="line"></span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(Phone* const);//重复声明</span><br></pre></td></tr></table></figure></li><li><p>如果形参是指针或引用，则区分其指向常量对象还是非常量对象可以实现函数重载，此时<code>const</code>是底层的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(Phone&amp;);</span><br><span class="line">Record lookup(cosnt Phone&amp;);//新函数，作用于常量引用</span><br><span class="line"></span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(const Phone*);//新函数，作用于指向常量的指针</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>this</code>指针</strong>：作用在类内部，当类的非静态成员函数中访问类的非静态成员的时候，编译器自动将对象本身地址作为一个隐含参数传递给函数。</p><ul><li><p>在类的非静态成员函数中返回类对象本身的时候，直接使用<code>return *this</code>.</p></li><li><p>参数与变量名相同时，必须<code>this-&gt;n = n</code>。</p></li><li><p><code>this</code>指针会被编译器解析为<code>A *const</code>。</p></li><li><p><code>this</code>是右值</p></li></ul></li><li><p>**<code>inline</code>**：内联能提高函数效率，但是内联是以代码膨胀为代价的，仅仅省区函数调用的开销从而提高执行效率。不适合使用内联：函数体内代码比较长；函数体内出现循环。</p><ul><li><p>虚函数（virtual）和内联（inline）：</p><ul><li><p>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联。内联是编译期间，虚函数多态在运行期间，编译器无法知道运行期间用哪个代码，因此虚函数表现多态时不可以内联。</p></li><li><p><code>inline virtual</code>唯一可以内联时候：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p></li></ul></li></ul></li></ul><p>​      </p><ul><li><p>**<code>class</code>和<code>struct</code>**：唯一区别是默认访问权限不一样，<code>struct</code>默认<code>public</code>，<code>class</code>默认<code>private</code>。</p></li><li><p>**<code>union</code>**：一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。</p></li><li><p><strong><code>sizeof</code>类大小计算</strong>：</p><ul><li>空类大小为1字节</li><li>一个类中，成员函数、静态数据成员不占存储空间</li><li>不管多少个虚函数只有一个虚指针的大小</li><li>派生类继承了所有基类的函数和成员，按照字节对齐计算大小。虚函数都是继承基类的虚指针。</li></ul></li><li><p>**<code>extern &quot;C&quot;</code>**：告诉编译器按照C的方式编译。</p><ul><li><p>C++调用C函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern int add(...)</span><br><span class="line"></span><br><span class="line">//xx.c</span><br><span class="line">int add()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//xx.cpp</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    #include &quot;xx.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C调用C++函数：<code>extern &quot;C&quot;</code>在C中是语法错误，需要放在C++头文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">    int add();</span><br><span class="line">&#125;</span><br><span class="line">//xx.cpp</span><br><span class="line">int add()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//xx.c</span><br><span class="line">extern int add();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>lambda表达式</strong>：</p><p><strong>[ capture list ]   ( parameter list )  -&gt;  return type   { function body }</strong></p><p>capture list:捕获列表；parameter list：参数列表；return type：返回类型；function body：函数体</p><p>我们可以忽略参数列表和返回类型，但必须包含捕获列表和函数体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto f = [] &#123;return 42;&#125;//忽略括号和参数列表等价于指定一个空参数列表</span><br><span class="line">cout&lt;&lt;f()&lt;&lt;endl;//输出42</span><br><span class="line">[] (const string&amp; a,const string&amp; b) &#123;return a.size()&lt;b.size();&#125;</span><br></pre></td></tr></table></figure><p>lambda捕获列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]空捕获列表。lambda不能使用所在函数中的变量</span><br><span class="line">[names]names是一个逗号分隔的名字列表，都是所在函数的局部变量，默认情况下捕获列表中的变量都被拷贝。名字前加&amp;，则采用引用捕获方式。</span><br><span class="line">[&amp;]隐式捕获列表，采用引用捕获方式，使用所在函数的实体的引用</span><br><span class="line">[=]隐式，采用值捕获方式，拷贝所在函数的实体的值</span><br><span class="line">[&amp;,names]names采用值捕获方式，不能加&amp;</span><br><span class="line">[=,names]names采用引用方式捕获，必须加&amp;</span><br></pre></td></tr></table></figure></li><li><p><strong>智能指针</strong>：</p><ul><li><p><code>shared_ptr</code>：允许多个指针指向同一个对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; sp;//空指针，可以指向类型为T的对象</span><br><span class="line">p.get();//返回p中保存的指针</span><br><span class="line">make_shared&lt;T&gt; (args);//返回一个shared_ptr，指向一个动态分配类型为T的对象。使用args初始化对象。最安全的分配</span><br><span class="line">shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(42);</span><br><span class="line">shared_ptr&lt;T&gt; p(q);//p是shared_ptr的拷贝</span><br><span class="line">p = q;//此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0则将其管理的原内存释放</span><br><span class="line">p.use_count();//若p.use_count()为1，返回true</span><br><span class="line">p.unique();//返回p共享对象的智能指针数量</span><br></pre></td></tr></table></figure></li><li><p><code>unique_ptr</code>：独占所指向对象。不支持普通的拷贝或赋值操作，但是可以通过release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr。不能拷贝的规则有一个例外：可以拷贝或赋值一个将要被销毁的unique_ptr，如返回局部对象的拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; p(new int(42));</span><br><span class="line">unique_ptr&lt;int&gt; p1(p2);//错误，不支持拷贝</span><br><span class="line">p1 = p2;//错误，不支持赋值</span><br><span class="line">unique_ptr&lt;int&gt; p2(p1.release());//将所有权从p1转移给p2。release将p1置空</span><br><span class="line">p2.reset(p3.release());//将所有权从p3转移给p2。reset释放了p2原来指向内存</span><br></pre></td></tr></table></figure></li><li><p><code>weak_ptr</code>：弱引用，指向<code>shared_ptr</code>所管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto p = make_shared&lt;int&gt;(42);</span><br><span class="line">weak_ptr&lt;int&gt; wp(p);//wp弱共享p，p引用计数不变</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多态性</strong>：</p><ul><li>静态绑定：编译时把调用函数名与具体函数绑定到一起。通过函数重载和运算符重载实现。</li><li>动态绑定：运行时绑定。通过继承和虚函数实现。</li></ul></li><li><p><strong>运算符重载</strong>：</p><ul><li><p>类运算符重载形式（二元）</p><ul><li><p>非静态成员运算符重载：参数比实际参数少一个，第一个参数以this指针隐式传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex operator+(Complex b)&#123;……&#125;</span><br></pre></td></tr></table></figure></li><li><p>友元运算符重载：参数个数与实际运算的参数个数相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">friend Complex operator+(Complex a,Complex b);//声明</span><br><span class="line">Complex  operator+(Complex a,Complex b)&#123;……&#125;//定义</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一元运算符：作为类成员函数重载时不需要参数，通过this指针隐式传递</p><ul><li><p>前自增&#x2F;减 与 后自增&#x2F;减：通过在运算符函数参数表中是否插入关键字int 来区分这两种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//前缀</span><br><span class="line">operator -- ();</span><br><span class="line">operator -- (X &amp; x);</span><br><span class="line">//后缀</span><br><span class="line">operator -- (int);</span><br><span class="line">operator -- (X &amp; x, int);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重载赋值运算符”&#x3D;”：只能用成员函数重载</p></li><li><p>重载”[]”：</p><ul><li>是一个二元运算符，<code>X&amp; operator[](int n);</code></li><li>[]既可以出现在赋值符“&#x3D;”的左边，也可以出现在赋值符“&#x3D;”的右边，所以重载运算符[]时常返回引用。</li><li>[]只能被重载为类的非静态成员函数，不能被重载为友元和普通函数。</li></ul></li><li><p>重载”()”：只能被重载为类的成员函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X&amp; operator( )(参数表);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>模板</strong>：</p><ul><li><p>函数模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T1, class T2,…&gt;</span><br><span class="line">返回类型 函数名(参数表)&#123;</span><br><span class="line">   …… //函数模板定义体</span><br><span class="line">&#125;</span><br><span class="line">//T1,T1...是模板参数, class/typename表示其后参数可以是任意类型</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T min(T a, T b)&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>类模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1,class T2,…&gt;</span><br><span class="line">class 类名&#123;</span><br><span class="line">    ……// 类成员的声明与定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2023/06/21/markdown/"/>
      <url>/2023/06/21/markdown/</url>
      
        <content type="html"><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><ul><li>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</li></ul><hr><h4 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h4><ul><li><p><strong>换行</strong>：段落换行使用两个以上空格加上回车</p></li><li><p><strong>字体</strong>：</p></li></ul><p>​*斜体*</p><p>​_斜体_</p><p>​**粗体**</p><p>​**粗体**</p><p>​***粗斜体***</p><p>​___粗斜体___</p><ul><li><strong>分割线</strong>：</li></ul><p>​你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西</p><ul><li><strong>删除线</strong>：</li></ul><p>​如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可。</p><ul><li><strong>下划线</strong>：</li></ul><p>​下划线可以通过 HTML 的 <strong><u></strong> 标签来实现。例如：&lt;u&gt;文本&lt;&#x2F;u&gt;</p><hr><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li><strong>无序表</strong>：无序列表使用星号(<em>****)、加号(<strong>+</strong>)或是减号(</em>*-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</li><li><strong>有序表</strong>：使用数字并加上 <strong>.</strong> 号来表示</li><li><strong>列表嵌套</strong>：子列表中的选项前面添加两个或四个空格即可</li></ul><hr><h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><ul><li>区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号。另外区块是可以嵌套的，一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推。</li></ul><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><p>用 <strong>&#96;&#96;&#96;</strong> 包裹一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><ul><li>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><ul><li><strong>我们可以设置表格的对齐方式：</strong><ul><li><p><strong>-:</strong> 设置内容和标题栏居右对齐。</p></li><li><p><strong>:-</strong> 设置内容和标题栏居左对齐。</p></li><li><p><strong>:-:</strong> 设置内容和标题栏居中对齐。</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><hr><h4 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h4><ul><li><p><strong>转义</strong>：使用反斜杠转义特殊字符</p></li><li><p><strong>公式</strong>：使用 <a href="https://github.com/Khan/KaTeX">KaTeX</a> 或者 <a href="https://github.com/mathjax/MathJax">MathJax</a> 来渲染数学表达式。</p><ul><li><code>$...$</code> 或者 <code>\(...\)</code> 中的数学表达式将会在行内显示。</li><li><code>$$...$$</code> 或者 <code>\[...\]</code> 或者 &#96;&#96;&#96;&#96;math&#96; 中的数学表达式将会在块内显示。</li></ul></li><li><p><strong><a href="https://www.runoob.com/markdown/md-advance.html">流程图、时序图、甘特图</a></strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
