<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SSM</title>
      <link href="/2023/11/25/ssm/"/>
      <url>/2023/11/25/ssm/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2023/11/21/javaweb/"/>
      <url>/2023/11/21/javaweb/</url>
      
        <content type="html"><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p><strong>Tomcat 版本和Servlet版本之间的对应关系</strong></p><table><thead><tr><th align="left"><strong>Servlet</strong> Version</th><th align="left">**Tomcat ** Version</th><th align="left"><strong>JDK</strong> Version</th></tr></thead><tbody><tr><td align="left">6.1</td><td align="left">11.0.x</td><td align="left">17 and later</td></tr><tr><td align="left">6.0</td><td align="left">10.1.x</td><td align="left">11 and later</td></tr><tr><td align="left">5.0</td><td align="left">10.0.x (superseded)</td><td align="left">8 and later</td></tr><tr><td align="left">4.0</td><td align="left">9.0.x</td><td align="left">8 and later</td></tr><tr><td align="left">3.1</td><td align="left">8.5.x</td><td align="left">7 and later</td></tr><tr><td align="left">3.1</td><td align="left">8.0.x (superseded)</td><td align="left">7 and later</td></tr><tr><td align="left">3.0</td><td align="left">7.0.x (archived)</td><td align="left">6 and later (7 and later for WebSocket)</td></tr></tbody></table><p>Tomcat官方网站：<a href="http://tomcat.apache.org/" title="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><ul><li>安装版：需要安装，一般不考虑使用。</li><li>解压版: 直接解压缩使用，我们使用的版本。</li></ul><p><strong>目录</strong></p><ul><li><p>bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat10.exe、tomcat10w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat；</p></li><li><p>conf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：</p><ul><li><p><strong>server.xml：配置整个服务器信息。例如修改端口号。默认HTTP请求的端口号是：8080</strong></p></li><li><p>tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；</p></li><li><p>web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text&#x2F;html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的！</p></li><li><p>context.xml：对所有应用的统一配置，通常我们不会去配置它。</p></li></ul></li><li><p>lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下；</p></li><li><p>logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。</p></li><li><p>temp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！</p></li><li><p><strong>webapps：存放web项目的目录，其中每个文件夹都是一个项目</strong>；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中访问：<a href="http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目。其中examples"就是项目名，即文件夹的名字。">http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目。其中examples&quot;就是项目名，即文件夹的名字。</a></p><ul><li>app  本应用根目录<ul><li>static 非必要目录,约定俗成的名字,一般在此处放静态资源 ( css  js  img)</li><li>WEB-INF  必要目录,必须叫WEB-INF,受保护的资源目录,浏览器通过url不可以直接访问的目录<ul><li>classes     必要目录,src下源代码,配置文件,编译后会在该目录下,web项目中如果没有源码,则该目录不会出现</li><li>lib             必要目录,项目依赖的jar编译后会出现在该目录下,web项目要是没有依赖任何jar,则该目录不会出现</li><li>web.xml   必要文件,web项目的基本配置文件. 较新的版本中可以没有该文件,但是学习过程中还是需要该文件</li></ul></li><li>index.html  非必要文件,index.html&#x2F;index.htm&#x2F;index.jsp为默认的欢迎页</li></ul></li></ul></li><li><p>work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。</p></li><li><p>LICENSE：许可证。</p></li><li><p>NOTICE：说明文件。</p></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><blockquote><p> HTTP&#x2F;1.0</p></blockquote><ul><li>1996 年，HTTP&#x2F;1.0 发布。该规范是显著扩大，并且支持三种请求方法：GET，Head，和POST。 </li><li>HTTP&#x2F;1.0 相对于 HTTP&#x2F;0.9 的改进如下：<ul><li>每个请求都附加了 HTTP 版本。</li><li>在响应开始时发送状态代码。</li><li>请求和响应都包含 HTTP 报文头。</li><li>内容类型能够传输 HTML 文件以外的文档。</li></ul></li><li>但是，HTTP&#x2F;1.0 不是官方标准。</li></ul><blockquote><p>HTTP&#x2F;1.1</p></blockquote><ul><li><p>HTTP 的第一个标准化版本 HTTP&#x2F;1.1 ( RFC 2068 ) 于 1997 年初发布，支持七种请求方法：OPTIONS，GET，HEAD，POST，PUT，DELETE，和TRACE </p></li><li><p>HTTP&#x2F;1.1 是 HTTP 1.0 的增强：</p><ul><li><p>虚拟主机允许从单个 IP 地址提供多个域。</p></li><li><p><strong>持久连接</strong>和流水线连接允许 Web 浏览器通过单个持久连接发送多个请求。</p></li><li><p><strong>缓存</strong>支持节省了带宽并使响应速度更快。</p></li></ul></li><li><p>HTTP&#x2F;1.1 在接下来的 15 年左右将非常稳定。 </p></li><li><p>在此期间，出现了 HTTPS（安全超文本传输协议）。它是使用 SSL&#x2F;TLS 进行安全加密通信的 HTTP 的安全版本。</p></li></ul><p><strong>请求报文格式</strong></p><ul><li>请求首行（<strong>请求行</strong>）；    GET&#x2F;POST   资源路径?参数   HTTP&#x2F;1.1</li><li>请求头信息（<strong>请求头</strong>）；</li><li>空行；</li><li>请求体；POST请求才有请求体</li></ul><p><strong>响应报文格式</strong></p><ul><li>响应首行（<strong>响应行</strong>）； 协议&#x2F;版本  状态码    状态码描述</li><li>响应头信息（<strong>响应头</strong>）；</li><li>空行；</li><li>响应体；</li></ul><p><strong>常见响应码</strong></p><ul><li><strong>200：</strong> 请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；</li><li><strong>302：</strong> 重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location指定新请求的URL地址；</li><li><strong>304：</strong> 使用了本地缓存</li><li><strong>404：</strong> 请求的资源没有找到，说明客户端错误的请求了不存在的资源；</li><li><strong>405：</strong> 请求的方式不允许</li><li><strong>500：</strong> 请求资源找到了，但服务器内部出现了错误；</li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的<strong>控制器</strong></p><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><ol><li>客户端发送请求报文</li><li>tomcat接收到请求后，会将请求报文的信息转换为一个HttpServiceRequest 对象，该对象包含了请求中的所有信息</li><li>tomcat同时创建一个HttpServiceResponse 对象，该对象用于承装要响应给客户端的信息，然后该对象装换为响应报文</li><li>tomcat根据请求中的资源路径找到对象的servlet，将servlet实例化，调用service方法，同时将HttpServiceRequest 和HttpServiceResponse 对象传入</li><li>服务端返回响应报文</li></ol><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li><p>创建JavaWeb项目，同时将tomcat添加为当前项目依赖</p></li><li><p>自定义一个类,要继承HttpServlet类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span>  <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;atguigu&quot;</span>.equals(username))&#123;</span><br><span class="line">            <span class="comment">//通过响应对象响应信息</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>重写service方法,该方法主要就是用于处理用户请求的服务方法</p></li><li><p>HttpServletRequest 代表请求对象,是有请求报文经过tomcat转换而来的,通过该对象可以获取请求中的信息</p></li><li><p>HttpServletResponse 代表响应对象,该对象会被tomcat转换为响应的报文,通过该对象可以设置响应中的信息</p></li><li><p>Servlet对象的生命周期(创建,初始化,处理服务,销毁)是由tomcat管理的,无需我们自己new</p></li><li><p>HttpServletRequest HttpServletResponse 两个对象也是有tomcat负责转换,在调用service方法时传入给我们用的</p></li></ul></li><li><p>在web.xml为UseServlet配置请求的映射路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给UserServlet起一个别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.UserServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联别名和映射路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以为一个Servlet匹配多个不同的映射路径,但是不同的Servlet不能使用相同的url-pattern--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/userServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;url-pattern&gt;/userServlet2&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            /        表示通配所有资源,不包括jsp文件</span></span><br><span class="line"><span class="comment">            /*       表示通配所有资源,包括jsp文件</span></span><br><span class="line"><span class="comment">            /a/*     匹配所有以a前缀的映射路径</span></span><br><span class="line"><span class="comment">            *.action 匹配所有以action为后缀的映射路径</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet并不是文件系统中实际存在的文件或者目录,所以为了能够请求到该资源,我们需要为其配置映射路径</li><li>servlet的请求映射路径配置在web.xml中</li><li>servlet-name作为servlet的别名,可以自己随意定义,见名知意就好</li><li>url-pattern标签用于定义Servlet的请求映射路径</li><li>一个servlet可以对应多个不同的url-pattern</li><li>多个servlet不能使用相同的url-pattern</li><li>url-pattern中可以使用一些通配写法<ul><li>&#x2F;        表示通配所有资源,不包括jsp文件</li><li>&#x2F;*      表示通配所有资源,包括jsp文件</li><li>&#x2F;a&#x2F;*     匹配所有以a前缀的映射路径</li><li>*.action 匹配所有以action为后缀的映射路径</li></ul></li></ul><p><strong>推荐使用@WebServlet注解替换Servlet配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">        name = &quot;userServlet&quot;, /*别名*/</span></span><br><span class="line"><span class="meta">        //value = &quot;/user&quot;, /*映射路径*/</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/userServlet1&quot;,&quot;/userServlet2&quot;,&quot;/userServlet&quot;&#125;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name = &quot;encoding&quot;,value = &quot;UTF-8&quot;)&#125;,/*配置初始参数*/</span></span><br><span class="line"><span class="meta">        loadOnStartup = 6</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span>  <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> getServletConfig().getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        System.out.println(encoding);</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;atguigu&quot;</span>.equals(username))&#123;</span><br><span class="line">            <span class="comment">//通过响应对象响应信息</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><table><thead><tr><th>生命周期</th><th>对应方法</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>构造对象</td><td>构造器</td><td>第一次请求或者容器启动</td><td>1</td></tr><tr><td>初始化</td><td>init()</td><td>构造完毕后</td><td>1</td></tr><tr><td>处理服务</td><td>service(HttpServletRequest req,HttpServletResponse resp)</td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td>destory()</td><td>容器关闭</td><td>1</td></tr></tbody></table><p>Servlet对象在容器中是单例的</p><p>容器是可以处理并发的用户请求的,每个请求在容器中都会开启一个线程</p><p>多个线程可能会使用相同的Servlet对象,所以在Servlet中,我们<strong>不要轻易定义一些容易经常发生修改的成员变量</strong>，会引发线程安全问题</p><p>load-on-startup中定义的正整数表示启动时实例化顺序,如果数字重复了,容器会自行解决实例化顺序问题,但是应该避免重复。默认值是-1，表示启动时不会实例化</p><p>Tomcat容器中,已经定义了一些随系统启动实例化的servlet,我们自定义的servlet的load-on-startup尽量不要占用数字1-5</p><h3 id="Servlet继承结构"><a href="#Servlet继承结构" class="headerlink" title="Servlet继承结构"></a>Servlet继承结构</h3><h4 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h4><p>Servlet 规范接口,所有的Servlet必须实现 </p><ul><li>public void init(ServletConfig config) throws ServletException;   <ul><li>初始化方法,容器在构造servlet对象后,自动调用的方法,容器负责实例化一个ServletConfig对象,并在调用该方法时传入</li><li>ServletConfig对象可以为Servlet 提供初始化参数</li></ul></li><li>public ServletConfig getServletConfig();<ul><li>获取ServletConfig对象的方法,后续可以通过该对象获取Servlet初始化参数</li></ul></li><li>public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;<ul><li>处理请求并做出响应的服务方法,每次请求产生时由容器调用</li><li>容器创建一个ServletRequest对象和ServletResponse对象,容器在调用service方法时,传入这两个对象</li></ul></li><li>public String getServletInfo();<ul><li>获取ServletInfo信息的方法</li></ul></li><li>public void destroy();<ul><li>Servlet实例在销毁之前调用的方法</li></ul></li></ul><h4 id="GenericServlet-抽象类"><a href="#GenericServlet-抽象类" class="headerlink" title="GenericServlet 抽象类"></a>GenericServlet 抽象类</h4><p>GenericServlet 抽象类是对Servlet接口一些固定功能的粗糙实现,以及对service方法的再次抽象声明,并定义了一些其他相关功能方法</p><ul><li>private transient ServletConfig config：初始化配置对象作为属性</li><li>public GenericServlet() { } ：构造器,为了满足继承而准备</li><li>public void destroy() { } ：销毁方法的平庸实现</li><li>public String getInitParameter(String name) ：获取初始参数的快捷方法</li><li>public Enumeration<String> getInitParameterNames() ：返回所有初始化参数名的方法</li><li>public ServletConfig getServletConfig()：获取初始Servlet初始配置对象ServletConfig的方法</li><li>public ServletContext getServletContext()：获取上下文对象ServletContext的方法</li><li>public String getServletInfo() ：获取Servlet信息的平庸实现</li><li>public void init(ServletConfig config) throws ServletException() ：初始化方法的实现,并在此调用了init的重载方法</li><li>public void init() throws ServletException ：<strong>重载init方法,为了让我们自己定义初始化功能的方法</strong></li><li>public void log(String msg) </li><li>public void log(String message, Throwable t)：打印日志的方法及重载</li><li>public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException：<strong>服务方法再次声明</strong></li><li>public String getServletName() ：获取ServletName的方法</li></ul><h4 id="HttpServlet-抽象类"><a href="#HttpServlet-抽象类" class="headerlink" title="HttpServlet 抽象类"></a>HttpServlet 抽象类</h4><p>abstract class HttpServlet extends GenericServlet  HttpServlet抽象类,除了基本的实现以外,增加了更多的基础功能</p><ul><li><p>public HttpServlet() {}</p><ul><li>构造器,用于处理继承</li></ul></li><li><p>public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException</p><ul><li>对服务方法的实现</li><li>在该方法中,将请求和响应对象转换成对应HTTP协议的HttpServletRequest HttpServletResponse对象</li><li>调用重载的service方法</li></ul></li><li><p>public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException</p><ul><li>重载的service方法,被重写的service方法所调用</li><li>在该方法中,通过请求方式判断,调用具体的do***方法完成请求的处理</li></ul></li><li><p>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p></li><li><p>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p></li><li><p>protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p></li><li><p>protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p></li><li><p>protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p></li><li><p>protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p></li><li><p>protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p><p>对应不同请求方式的处理方法</p><p>除了doOptions和doTrace方法,其他的do*** 方法都在故意响应错误信息。如果不重写自己的service方法都会调用这些方法而故意响应405错误信息</p><p>自定义Servlet中,必须要对处理请求的方法进行重写，要么重写service方法，要么重写do***方法</p></li></ul><h3 id="ServletConfig和ServletContext"><a href="#ServletConfig和ServletContext" class="headerlink" title="ServletConfig和ServletContext"></a>ServletConfig和ServletContext</h3><h4 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h4><p>为Servlet提供初始配置参数的一种对象,<strong>每个Servlet都有自己独立唯一的ServletConfig对象</strong></p><p>容器会为**每个Servlet实例化一个ServletConfig对象,**并通过Servlet生命周期的init方法传入给Servlet作为属性</p><p>使用 @WebServlet 注解的initParams配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">        name = &quot;userServlet&quot;, /*别名*/</span></span><br><span class="line"><span class="meta">        //value = &quot;/user&quot;, /*映射路径*/</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/userServlet1&quot;,&quot;/userServlet2&quot;,&quot;/userServlet&quot;&#125;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name = &quot;encoding&quot;,value = &quot;UTF-8&quot;)&#125;,/*配置初始参数*/</span></span><br><span class="line"><span class="meta">        loadOnStartup = 6</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>容器会为每个app创建一个独立的唯一的ServletContext对象</p><p>ServletContext对象<strong>为所有的Servlet所共享</strong></p><p>ServletContext可以<strong>为所有的Servlet提供初始配置参数</strong></p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>paramA<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>valueA<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>paramB<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>valueB<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>获取资源的真实路径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;资源在web目录中的路径&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>例如我们的目标是需要获取项目中某个静态资源的路径，不是工程目录中的路径，而是<strong>部署目录中的路径</strong>；我们如果直接拷贝其在我们电脑中的完整路径的话其实是有问题的，因为如果该项目以后部署到公司服务器上的话，路径肯定是会发生改变的，所以我们需要使用代码动态获取资源的真实路径.  只要使用了servletContext动态获取资源的真实路径，<strong>那么无论项目的部署路径发生什么变化，都会动态获取项目运行时候的实际路径</strong>，所以就不会发生由于写死真实路径而导致项目部署位置改变引发的路径错误问题</li></ul><p><strong>获取项目的上下文路径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> servletContext.getContextPath();</span><br></pre></td></tr></table></figure><ul><li>项目的部署名称,也叫项目的上下文路径,在部署进入tomcat时所使用的路径,该路径是可能发生变化的,通过该API动态获取项目真实的上下文路径,可以<strong>帮助我们解决一些后端页面渲染技术或者请求转发和响应重定向中的路径问题</strong></li></ul><p><strong>域对象的相关API</strong></p><ul><li>域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同</li><li>ServletContext代表应用,所以ServletContext域也叫作应用域,是webapp中最大的域,可以在本应用内实现数据的共享和传递</li><li>webapp中的三大域对象,分别是应用域,会话域,请求域</li><li>三大域对象都具有的API如下</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setAttribute(String key,Object value);</td><td>向域中存储&#x2F;修改数据</td></tr><tr><td>Object getAttribute(String key);</td><td>获得域中的数据</td></tr><tr><td>void removeAttribute(String key);</td><td>移除域中的数据</td></tr></tbody></table><h2 id="HttpServiceRequest"><a href="#HttpServiceRequest" class="headerlink" title="HttpServiceRequest"></a>HttpServiceRequest</h2><p>获取请求行信息相关(方式,请求的url,协议及版本)</p><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>StringBuffer getRequestURL();</td><td>获取客户端请求资源的完整路径，统一资源定位符</td></tr><tr><td>String getRequestURI();</td><td>获取客户端请求资源的路径，统一资源标识符</td></tr><tr><td>int getServerPort();</td><td>获取客户端发送请求时的端口</td></tr><tr><td>int getLocalPort();</td><td>获取本应用在所在容器的端口</td></tr><tr><td>int getRemotePort();</td><td>获取客户端程序的端口</td></tr><tr><td>String getScheme();</td><td>获取请求协议</td></tr><tr><td>String getProtocol();</td><td>获取请求协议及版本号</td></tr><tr><td>String getMethod();</td><td>获取请求方式</td></tr></tbody></table><p>获得请求头信息相关</p><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getHeader(String headerName);</td><td>根据头名称获取请求头</td></tr><tr><td>Enumeration<String> getHeaderNames();</td><td>获取所有的请求头名字</td></tr><tr><td>String getContentType();</td><td>获取content-type请求头</td></tr></tbody></table><p>获得请求参数相关</p><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getParameter(String parameterName);</td><td>根据请求参数名获取请求单个参数值</td></tr><tr><td>String[] getParameterValues(String parameterName);</td><td>根据请求参数名获取请求多个参数值数组</td></tr><tr><td>Enumeration<String> getParameterNames();</td><td>获取所有请求参数名</td></tr><tr><td>Map&lt;String, String[]&gt; getParameterMap();</td><td>获取所有请求参数的键值对集合</td></tr><tr><td>BufferedReader getReader() throws IOException;</td><td>获取读取请求体的字符输入流</td></tr><tr><td>ServletInputStream getInputStream() throws IOException;</td><td>获取读取请求体的字节输入流</td></tr><tr><td>int getContentLength();</td><td>获得请求体长度的字节数</td></tr></tbody></table><p>其他API</p><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getServletPath();</td><td>获取请求的Servlet的映射路径</td></tr><tr><td>ServletContext getServletContext();</td><td>获取ServletContext对象</td></tr><tr><td>Cookie[] getCookies();</td><td>获取请求中的所有cookie</td></tr><tr><td>HttpSession getSession();</td><td>获取Session对象</td></tr><tr><td>void setCharacterEncoding(String encoding) ;</td><td>设置请求体字符集</td></tr></tbody></table><h2 id="HttpServiceResponse"><a href="#HttpServiceResponse" class="headerlink" title="HttpServiceResponse"></a>HttpServiceResponse</h2><p>设置响应行相关</p><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setStatus(int  code);</td><td>设置响应状态码</td></tr></tbody></table><p>设置响应头相关</p><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setHeader(String headerName, String headerValue);</td><td>设置&#x2F;修改响应头键值对</td></tr><tr><td>void setContentType(String contentType);</td><td>设置content-type响应头及响应字符集(设置MIME类型)</td></tr></tbody></table><p>设置响应体相关</p><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>PrintWriter getWriter() throws IOException;</td><td>获得向响应体放入信息的字符输出流</td></tr><tr><td>ServletOutputStream getOutputStream() throws IOException;</td><td>获得向响应体放入信息的字节输出流</td></tr><tr><td>void setContentLength(int length);</td><td>设置响应体的字节长度,其实就是在设置content-length响应头</td></tr></tbody></table><p>其他API</p><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void sendError(int code, String message) throws IOException;</td><td>向客户端响应错误信息的方法,需要指定响应码和响应信息</td></tr><tr><td>void addCookie(Cookie cookie);</td><td>向响应体中增加cookie</td></tr><tr><td>void setCharacterEncoding(String encoding);</td><td>设置响应体字符集</td></tr></tbody></table><blockquote><p>MIME类型</p></blockquote><ul><li>MIME类型,可以理解为文档类型,用户表示传递的数据是属于什么类型的文档</li><li>浏览器可以根据MIME类型决定该用什么样的方式解析接收到的响应体数据</li><li>可以这样理解: 前后端交互数据时,告诉对方发给对方的是 html&#x2F;css&#x2F;js&#x2F;图片&#x2F;声音&#x2F;视频&#x2F;… …</li><li>tomcat&#x2F;conf&#x2F;web.xml中配置了常见文件的拓展名和MIMIE类型的对应关系</li><li>常见的MIME类型举例如下</li></ul><table><thead><tr><th>文件拓展名</th><th>MIME类型</th></tr></thead><tbody><tr><td>.html</td><td>text&#x2F;html</td></tr><tr><td>.css</td><td>text&#x2F;css</td></tr><tr><td>.js</td><td>application&#x2F;javascript</td></tr><tr><td>.png &#x2F;.jpeg&#x2F;.jpg&#x2F;… …</td><td>image&#x2F;jpeg</td></tr><tr><td>.mp3&#x2F;.mpe&#x2F;.mpeg&#x2F; … …</td><td>audio&#x2F;mpeg</td></tr><tr><td>.mp4</td><td>video&#x2F;mp4</td></tr><tr><td>.m1v&#x2F;.m1v&#x2F;.m2v&#x2F;.mpe&#x2F;… …</td><td>video&#x2F;mpeg</td></tr></tbody></table><h2 id="请求转发和响应重定向"><a href="#请求转发和响应重定向" class="headerlink" title="请求转发和响应重定向"></a>请求转发和响应重定向</h2><p>请求转发和响应重定向是web应用中间接访问项目资源的两种手段,也是Servlet控制页面跳转的两种手段</p><p>请求转发通过HttpServletRequest实现,响应重定向通过HttpServletResponse实现</p><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p><strong>请求转发特点：</strong></p><ul><li>请求转发通过HttpServletRequest对象获取请求转发器实现</li><li>请求转发是服务器内部的行为,对客户端是屏蔽的</li><li>客户端只发送了一次请求,客户端地址栏不变</li><li>服务端只产生了一对请求和响应对象, 这一对请求和响应对象会继续传递给下一个资源</li><li>因为全程只有一个HttpServletRequset对象,所以请求参数可以传递,请求域中的数据也可以传递</li><li>请求转发可以转发给其他Servlet动态资源,也可以转发给一些静态资源以实现页面跳转</li><li>请求转发可以转发给WEB-INF下受保护的资源</li><li>请求转发不能转发到本项目以外的外部资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//  获取请求转发器</span></span><br><span class="line">        <span class="comment">//  转发给servlet  ok</span></span><br><span class="line">        <span class="type">RequestDispatcher</span>  <span class="variable">requestDispatcher</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;servletB&quot;</span>);</span><br><span class="line">        <span class="comment">//  转发给一个视图资源 ok</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;welcome.html&quot;);</span></span><br><span class="line">        <span class="comment">//  转发给WEB-INF下的资源  ok</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;);</span></span><br><span class="line">        <span class="comment">//  转发给外部资源   no</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  做出转发动作</span></span><br><span class="line">        requestDispatcher.forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应重定向"><a href="#响应重定向" class="headerlink" title="响应重定向"></a>响应重定向</h3><p><strong>响应重定向特点：</strong></p><ul><li>响应重定向通过HttpServletResponse对象的sendRedirect方法实现</li><li>响应重定向是服务端通过302响应码和路径,告诉客户端自己去找其他资源,是在服务端提示下的客户端的行为</li><li>客户端至少发送了两次请求,客户端地址栏是要变化的</li><li>服务端产生了多对请求和响应对象,且请求和响应对象不会传递给下一个资源</li><li>因为全程产生了多个HttpServletRequset对象,所以请求参数不可以传递,请求域中的数据也不可以传递</li><li>重定向可以是其他Servlet动态资源,也可以是一些静态资源以实现页面跳转</li><li>重定向不可以到给WEB-INF下受保护的资源</li><li>重定向可以到本项目以外的外部资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//  响应重定向</span></span><br><span class="line">        <span class="comment">// 重定向到servlet动态资源 OK</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;servletB&quot;</span>);</span><br><span class="line">        <span class="comment">// 重定向到视图静态资源 OK</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;welcome.html&quot;);</span></span><br><span class="line">        <span class="comment">// 重定向到WEB-INF下的资源 NO</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;WEB-INF/views/view1&quot;);</span></span><br><span class="line">        <span class="comment">// 重定向到外部资源 OK</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h2><p><strong>相对路径</strong></p><ul><li>相对路径的规则是: 以当前资源所在的路径为出发点去寻找目标资源</li><li>相对路径不以 &#x2F; 开头</li><li>在file协议下,使用的是磁盘路径</li><li>在http协议下,使用的是url路径</li><li>相对路径中可以使用 .&#x2F;表示当前资源所在路径,可以省略不写</li><li>相对路径中可以使用..&#x2F;表示当前资源所在路径的上一层路径,需要时要手动添加</li></ul><p><strong>绝对路径</strong></p><ul><li>绝对路径的规则是: 使用以一个固定的路径做出出发点去寻找目标资源,和当前资源所在的路径没有关系</li><li>绝对路径要以&#x2F; 开头</li><li>绝对路径的写法中,不以当前资源的所在路径为出发点,所以不会出现  .&#x2F; 和..&#x2F;</li><li>不同的项目和不同的协议下,绝对路径的基础位置可能不同,要通过测试确定</li><li>绝对路径的好处就是:无论当前资源位置在哪,寻找目标资源路径的写法都一致</li></ul><p><strong>base标签</strong></p><blockquote><p>base标签定义页面相对路径公共前缀</p></blockquote><ul><li>base 标签定义在head标签中,用于定义相对路径的公共前缀</li><li>base 标签定义的公共前缀只在相对路径上有效,绝对路径中无效</li><li>如果相对路径开头有 .&#x2F; 或者..&#x2F;修饰,则base标签对该路径同样无效</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义相对路径的公共前缀,将相对路径转化成了绝对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;/web03_war_exploded/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;static/img/logo.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>缺省项目上下文路径</strong></p><blockquote><p>项目上下文路径变化问题</p></blockquote><ul><li>通过 base标签虽然解决了相对路径转绝对路径问题,但是base中定义的是项目的上下文路径</li><li>项目的上下文路径是可以随意变化的</li><li>一旦项目的上下文路径发生变化,所有base标签中的路径都需要改</li></ul><blockquote><p>解决方案</p></blockquote><ul><li><strong>将项目的上下文路径进行缺省设置,设置为 &#x2F;,所有的绝对路径中就不必填写项目的上下文了,直接就是&#x2F;开头即可</strong></li></ul><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><blockquote><p>HTTP是无状态协议</p></blockquote><p>无状态就是不保存状态,即无状态协议(stateless),HTTP协议自身不对请求和响应之间的通信状态进行保存,也就是说,在HTTP协议这个级别,协议对于发送过的请求或者响应都不做持久化处理</p><p><strong>会话管理实现的手段</strong></p><blockquote><p>Cookie和Session配合解决</p></blockquote><ul><li>cookie是在客户端保留少量数据的技术,主要通过响应头向客户端响应一些客户端要保留的信息</li><li>session是在服务端保留更多数据的技术,主要通过HttpSession对象保存一些和客户端相关的信息</li><li>cookie和session配合记录请求状态</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>cookie是一种客户端会话技术,cookie由服务端产生,它是服务器存放在浏览器的一小份数据,浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去</p><ul><li>服务端创建cookie,将cookie放入响应对象中,Tomcat容器将cookie转化为set-cookie响应头,响应给客户端</li><li>客户端在收到cookie的响应头时,在下次请求该服务的资源时,会以cookie请求头的形式携带之前收到的Cookie</li><li>cookie是一种键值对格式的数据,从tomcat8.5开始可以保存中文,但是不推荐</li><li>由于cookie是存储于客户端的数据,比较容易暴露,一般不存储一些敏感或者影响安全的数据</li></ul><p>servletA向响应中增加Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>servletB从请求中读取Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求中的cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">//迭代cookies数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != cookies &amp;&amp; cookies.length!= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                System.out.println(cookie.getName()+<span class="string">&quot;:&quot;</span>+cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cookie的时效性</strong></p><blockquote><p>默认情况下Cookie的有效期是一次会话范围内，我们可以通过cookie的setMaxAge()方法让Cookie持久化保存到浏览器上</p></blockquote><ul><li>会话级Cookie<ul><li>服务器端并没有明确指定Cookie的存在时间</li><li>在浏览器端，Cookie数据存在于内存中</li><li>只要浏览器还开着，Cookie数据就一直都在</li><li>浏览器关闭，内存中的Cookie数据就会被释放</li></ul></li><li>持久化Cookie<ul><li>服务器端明确设置了Cookie的存在时间</li><li>在浏览器端，Cookie数据会被保存到硬盘上</li><li>Cookie在硬盘上存在的时间根据服务器端限定的时间来管控，不受浏览器关闭的影响</li><li>持久化Cookie到达了预设的时间会被释放</li></ul></li></ul><blockquote><p>cookie.setMaxAge(int expiry)参数单位是秒，表示cookie的持久化时间，如果设置参数为0，表示将浏览器中保存的该cookie删除</p></blockquote><p>servletA设置一个Cookie为持久化cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        cookie1.setMaxAge(<span class="number">60</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cookie的提交路径</strong></p><blockquote><p>访问互联网资源时不能每次都需要把所有Cookie带上。访问不同的资源时,可以携带不同的cookie,我们可以通过cookie的setPath(String path) 对cookie的路径进行设置</p></blockquote><p>ServletA中设置cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置cookie的提交路径</span></span><br><span class="line">        cookie1.setPath(<span class="string">&quot;/web03_war_exploded/servletB&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>HttpSession是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象. 客户端在发送请求时,都可以使用自己的session. 这样服务端就可以通过session来记录某个客户端的状态了(记录用户的登录状态, 记录用户操作的历史)</p><ul><li>服务端在为客户端创建session时,会同时将session对象的id,即JSESSIONID以cookie的形式放入响应对象</li><li>后端创建完session后,客户端会收到一个特殊的cookie,叫做JSESSIONID</li><li>客户端下一次请求时携带JSESSIONID,后端收到后,根据JSESSIONID找到对应的session对象</li><li>通过该机制,服务端通过session就可以存储一些专门针对某个客户端的信息了</li><li>session也是域对象</li></ul><p>定义ServletA, 将键值对存入session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 向session对象中存入数据</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义其他Servlet,从session中读取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 从session中取出数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HttpSession时效性</strong></p><ul><li><p>用户量很大之后，Session对象相应的也要创建很多。如果一味创建不释放，那么服务器端的内存迟早要被耗尽。所以可用定义时效性</p></li><li><p>客户端关闭行为无法被服务端直接侦测,或者客户端较长时间不操作也经常出现,类似这些的情况,就需要对session的时限进行设置了</p></li><li><p>默认的session最大闲置时间(两次使用同一个session中的间隔时间) 在tomcat&#x2F;conf&#x2F;web.xml配置为30分钟</p></li><li><p>可以自己在当前项目的web.xml对最大闲置时间进行重新设定 。或者通过HttpSession的API 对最大闲置时间进行设定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最大闲置时间</span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">60</span>);</span><br><span class="line"><span class="comment">// 直接让session失效</span></span><br><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure></li></ul><h2 id="三大域"><a href="#三大域" class="headerlink" title="三大域"></a>三大域</h2><p>域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同</p><ul><li>请求域对象是HttpServletRequest ,传递数据的范围是一次请求之内及请求转发</li><li>会话域对象是HttpSession,传递数据的范围是一次会话之内,可以跨多个请求</li><li>应用域对象是ServletContext,传递数据的范围是本应用之内,可以跨多个会话</li></ul><blockquote><p>域对象的API</p></blockquote><table><thead><tr><th>API</th><th>功能</th></tr></thead><tbody><tr><td>void setAttribute(String name,String value)</td><td>向域对象中添加&#x2F;修改数据</td></tr><tr><td>Object getAttribute(String name);</td><td>从域对象中获取数据</td></tr><tr><td>removeAttribute(String name);</td><td>移除域对象中的数据</td></tr></tbody></table><ul><li>请求转发时,请求域可以传递数据<code>请求域内一般放本次请求业务有关的数据,如:查询到的所有的部门信息</code></li><li>同一个会话内,不用请求转发,会话域可以传递数据<code>会话域内一般放本次会话的客户端有关的数据,如:当前客户端登录的用户</code> </li><li>同一个APP内,不同的客户端,应用域可以传递数据<code>应用域内一般放本程序应用有关的数据 如:Spring框架的IOC容器</code></li></ul><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul><li>Filter接口定义了过滤器的开发规范,所有的过滤器都要实现该接口</li><li>Filter的工作位置是项目中所有目标资源之前,容器在创建HttpServletRequest和HttpServletResponse对象后,会先调用Filter的doFilter方法</li><li>Filter的doFilter方法可以控制请求是否继续,如果放行,则请求继续,如果拒绝,则请求到此为止,由过滤器本身做出响应</li><li>Filter不仅可以对请求做出过滤,也可以在目标资源做出响应前,对响应再次进行处理</li><li>Filter是GOF中责任链模式的典型案例</li><li>Filter的常用应用包括但不限于: 登录权限检查,解决网站乱码,过滤敏感字符,日志记录,性能分析… …</li></ul><table><thead><tr><th>API</th><th>目标</th></tr></thead><tbody><tr><td>default public void init(FilterConfig filterConfig)</td><td>初始化方法,由容器调用并传入初始配置信息filterConfig对象</td></tr><tr><td>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td><td>过滤方法,核心方法,过滤请求,决定是否放行,响应之前的其他处理等都在该方法中</td></tr><tr><td>default public void destroy()</td><td>销毁方法,容器在回收过滤器对象之前调用的方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span>  <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 参数父转子</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span>(HttpServletRequest)  servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span>  <span class="variable">response</span> <span class="operator">=</span>(HttpServletResponse)  servletResponse;</span><br><span class="line">        <span class="comment">// 拼接日志文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">beforeLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;被请求了&quot;</span>;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        System.out.println(beforeLogging);</span><br><span class="line">        <span class="comment">// 获取系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 放行请求</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">        <span class="comment">// 获取系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//  拼接日志文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">afterLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;的请求耗时:&quot;</span>+(t2-t1)+<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        System.out.println(afterLogging);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doFilter方法中的请求和响应对象是以父接口的形式声明的,实际传入的实参就是HttpServletRequest和HttpServletResponse子接口级别的,可以安全强转</li><li>filterChain.doFilter(request,response); 这行代码的功能是放行请求,如果没有这一行代码,则请求到此为止</li><li>filterChain.doFilter(request,response);在放行时需要传入request和response,意味着请求和响应对象要继续传递给后续的资源,这里没有产生新的request和response对象</li></ul><p><strong>配置 web.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置filter,并为filter起别名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.LoggingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过映射路径确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletA<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过后缀名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过servlet别名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletBName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>filter-mapping标签中定义了过滤器对那些资源进行过滤</li><li>子标签url-pattern通过映射路径确定过滤范围<ul><li>&#x2F;servletA  精确匹配,表示对servletA资源的请求进行过滤</li><li>*.html 表示对以.action结尾的路径进行过滤</li><li>&#x2F;* 表示对所有资源进行过滤</li><li>一个filter-mapping下可以配置多个url-pattern</li></ul></li><li>子标签servlet-name通过servlet别名确定对那些servlet进行过滤<ul><li>使用该标签确定目标资源的前提是servlet已经起了别名</li><li>一个filter-mapping下可以定义多个servlet-name</li><li>一个filter-mapping下,servlet-name和url-pattern子标签可以同时存在</li></ul></li></ul><h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote><p>过滤器作为web项目的组件之一,和Servlet的生命周期类似,略有不同,没有servlet的load-on-startup的配置,默认就是系统启动立刻构造</p></blockquote><table><thead><tr><th>阶段</th><th>对应方法</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>创建对象</td><td>构造器</td><td>web应用启动时</td><td>1</td></tr><tr><td>初始化方法</td><td>void init(FilterConfig filterConfig)</td><td>构造完毕</td><td>1</td></tr><tr><td>过滤请求</td><td>void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td>default void destroy()</td><td>web应用关闭时</td><td>1次</td></tr></tbody></table><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>一个web项目中,可以同时定义多个过滤器,多个过滤器对同一个资源进行过滤时,工作位置有先后,整体形成一个工作链,称之为过滤器链</p><ul><li>过滤器链中的过滤器的顺序由filter-mapping顺序决定</li><li>每个过滤器过滤的范围不同,针对同一个资源来说,过滤器链中的过滤器个数可能是不同的</li><li>如果某个Filter是使用ServletName进行匹配规则的配置，那么这个Filter执行的优先级要更低</li></ul><p><strong>web.xml配置</strong>: 顺序由filter-mapping顺序决定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter3<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter3<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--filter-mapping的顺序决定了过滤器的工作顺序--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter3<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注解配置</strong>: 顺序由过滤器类名字典序决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(</span></span><br><span class="line"><span class="meta">        filterName = &quot;loggingFilter&quot;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name=&quot;dateTimePattern&quot;,value=&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;,</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/servletA&quot;,&quot;*.html&quot;&#125;,</span></span><br><span class="line"><span class="meta">        servletNames = &#123;&quot;servletBName&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><blockquote><p>监听器：专门用于对域对象对象身上发生的事件或状态改变进行监听和相应处理的对象</p></blockquote><ul><li><p>监听器是GOF设计模式中,观察者模式的典型案例</p></li><li><p>观察者模式: 当被观察的对象发生某些改变时, 观察者自动采取对应的行动的一种设计模式</p></li><li><p>监听器使用的感受类似JS中的事件,被观察的对象发生某些情况时,自动触发代码的执行</p></li><li><p>监听器并不监听web项目中的所有组件,仅仅是对三大域对象做相关的事件监听</p></li></ul><blockquote><p>监听器的分类</p></blockquote><ul><li><p>web中定义八个监听器接口作为监听器的规范,这八个接口按照不同的标准可以形成不同的分类</p></li><li><p>按监听的对象划分</p><ul><li>application域监听器 ServletContextListener  ServletContextAttributeListener </li><li>session域监听器 HttpSessionListener  HttpSessionAttributeListener  HttpSessionBindingListener  HttpSessionActivationListener  </li><li>request域监听器 ServletRequestListener  ServletRequestAttributeListener</li></ul></li><li><p>按监听的事件分</p><ul><li>域对象的创建和销毁监听器 ServletContextListener   HttpSessionListener   ServletRequestListener  </li><li>域对象数据增删改事件监听器 ServletContextAttributeListener  HttpSessionAttributeListener   ServletRequestAttributeListener </li><li>其他监听器  HttpSessionBindingListener  HttpSessionActivationListener</li></ul></li></ul><h3 id="application域监听器"><a href="#application域监听器" class="headerlink" title="application域监听器"></a>application域监听器</h3><blockquote><p>ServletContextListener  监听ServletContext对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>contextInitialized(ServletContextEvent sce)</td><td>ServletContext创建时调用</td></tr><tr><td>contextDestroyed(ServletContextEvent sce)</td><td>ServletContext销毁时调用</td></tr></tbody></table><ul><li>ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。</li></ul><blockquote><p>ServletContextAttributeListener 监听ServletContext中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletContextAttributeEvent scab)</td><td>向ServletContext中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletContextAttributeEvent scab)</td><td>从ServletContext中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletContextAttributeEvent scab)</td><td>当ServletContext中的属性被修改时调用</td></tr></tbody></table><ul><li>ServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletContext()</td><td>获取ServletContext对象</td></tr></tbody></table><h3 id="session域监听器"><a href="#session域监听器" class="headerlink" title="session域监听器"></a>session域监听器</h3><blockquote><p>HttpSessionListener  监听HttpSession对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>sessionCreated(HttpSessionEvent hse)</td><td>HttpSession对象创建时调用</td></tr><tr><td>sessionDestroyed(HttpSessionEvent hse)</td><td>HttpSession对象销毁时调用</td></tr></tbody></table><ul><li>HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。</li></ul><blockquote><p>HttpSessionAttributeListener 监听HttpSession中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(HttpSessionBindingEvent se)</td><td>向HttpSession中添加属性时调用</td></tr><tr><td>attributeRemoved(HttpSessionBindingEvent se)</td><td>从HttpSession中移除属性时调用</td></tr><tr><td>attributeReplaced(HttpSessionBindingEvent se)</td><td>当HttpSession中的属性被修改时调用</td></tr></tbody></table><ul><li>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table><h3 id="request域监听器"><a href="#request域监听器" class="headerlink" title="request域监听器"></a>request域监听器</h3><blockquote><p>ServletRequestListener 监听ServletRequest对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>requestInitialized(ServletRequestEvent sre)</td><td>ServletRequest对象创建时调用</td></tr><tr><td>requestDestroyed(ServletRequestEvent sre)</td><td>ServletRequest对象销毁时调用</td></tr></tbody></table><ul><li>ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。</li></ul><blockquote><p>ServletRequestAttributeListener 监听ServletRequest中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletRequestAttributeEvent srae)</td><td>向ServletRequest中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletRequestAttributeEvent srae)</td><td>从ServletRequest中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletRequestAttributeEvent srae)</td><td>当ServletRequest中的属性被修改时调用</td></tr></tbody></table><ul><li>ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletRequest ()</td><td>获取触发事件的ServletRequest对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2023/11/12/maven/"/>
      <url>/2023/11/12/maven/</url>
      
        <content type="html"><![CDATA[<p><a href="https://maven.apache.org/what-is-maven.html?spm=wolai.workspace.0.0.34c02306vOKvp8">Maven</a></p><p>maven需要本机安装java环境、必需包含java_home环境变量！</p><h2 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h2><p><strong>本地仓库配置</strong></p><p>本地仓库默认值：**<code>用户家目录/.m2/repository</code>**。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>镜像仓库配置</strong></p><p>在<code>settting.xml</code>文件中配置阿里云镜像仓库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置具体的仓库的下载镜像--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此镜像的唯一标识符,用来区分不同的mirror元素--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对哪种仓库进行镜像，简单说就是替代哪个仓库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--镜像名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--镜像URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置 Maven 工程的基础 JDK 版本</strong></p><p>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 profile 标签整个复制到 settings.xml 文件的 profiles 标签内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置jdk版本项目构建</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-17<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>17<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Maven工程的GAVP属性"><a href="#Maven工程的GAVP属性" class="headerlink" title="Maven工程的GAVP属性"></a>Maven工程的GAVP属性</h2><p>Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。</p><p><strong>GAV遵循一下规则：</strong></p><p>  1） <strong>GroupID 格式</strong>：com.{公司&#x2F;BU }.业务线.[子业务线]，最多 4 级。</p><p>  2） <strong>ArtifactID 格式</strong>：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。</p><p>  3） <strong>Version版本号格式推荐</strong>：主版本号.次版本号.修订号 1.0.0</p><pre><code>1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。例如： 初始→1.0.0  修改bug → 1.0.1  功能调整 → 1.1.1等</code></pre><p><strong>Packaging定义规则：</strong></p><p>  指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！</p><p>  packaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。</p><p>  packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。</p><p>  packaging 属性为 pom，代表不会打包，用来做继承的父工程。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 坐标对应的 jar 包在 Maven 本地仓库中的位置：Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Maven构建管理与插件配置"><a href="#Maven构建管理与插件配置" class="headerlink" title="Maven构建管理与插件配置"></a>Maven构建管理与插件配置</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mvn clean</td><td>清理编译或打包后的项目结构,删除target文件夹</td></tr><tr><td>mvn compile</td><td>编译项目，生成target文件</td></tr><tr><td>mvn test</td><td>执行测试源码 (测试)</td></tr><tr><td>mvn site</td><td>生成一个项目依赖信息的展示页面</td></tr><tr><td>mvn package</td><td>打包项目，生成war &#x2F; jar 文件</td></tr><tr><td>mvn install</td><td>打包后上传到maven本地仓库(本地部署)</td></tr><tr><td>mvn deploy</td><td>只打包，上传到maven私服仓库(私服部署)</td></tr></tbody></table><p><strong>构建命令周期:</strong></p><p>构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！也是一种简化构建的思路!</p><ul><li><p>清理周期：主要是对项目编译生成文件进行清理</p><p>  包含命令：clean</p></li><li><p>默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分</p><p>  包含命令：compile - test - package - install &#x2F; deploy</p></li><li><p>报告周期</p><p>  包含命令：site</p><p>  打包: mvn clean package 本地仓库: mvn clean install</p></li></ul><p><strong>最佳使用方案:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打包: mvn clean package</span><br><span class="line">重新编译: mvn clean compile</span><br><span class="line">本地部署: mvn clean install </span><br></pre></td></tr></table></figure><p>插件配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- jdk17 和 war包版本插件不匹配 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="依赖管理和配置"><a href="#依赖管理和配置" class="headerlink" title="依赖管理和配置"></a>依赖管理和配置</h2><p><strong>maven项目信息属性配置和读取：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--打包方式</span></span><br><span class="line"><span class="comment">    默认：jar</span></span><br><span class="line"><span class="comment">    jar指的是普通的java项目打包方式！ 项目打成jar包！</span></span><br><span class="line"><span class="comment">    war指的是web项目打包方式！项目打成war包！</span></span><br><span class="line"><span class="comment">    pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar/pom/war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖管理和添加：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   通过编写依赖jar包的gav必要属性，引入第三方依赖！</span></span><br><span class="line"><span class="comment">   scope属性是可选的，可以指定依赖生效范围！</span></span><br><span class="line"><span class="comment">   依赖信息查询方式：</span></span><br><span class="line"><span class="comment">      1. maven仓库信息官网 https://mvnrepository.com/</span></span><br><span class="line"><span class="comment">      2. mavensearch插件搜索</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入具体的依赖包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            生效范围</span></span><br><span class="line"><span class="comment">            - compile ：main目录 test目录  打包打包 [默认]</span></span><br><span class="line"><span class="comment">            - provided：main目录 test目录  Servlet</span></span><br><span class="line"><span class="comment">            - runtime： 打包运行           MySQL</span></span><br><span class="line"><span class="comment">            - test:    test目录           junit</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖版本提取和维护:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--命名随便,内部制定版本号即可！--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用properties声明版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="依赖传递和冲突"><a href="#依赖传递和冲突" class="headerlink" title="依赖传递和冲突"></a>依赖传递和冲突</h2><p><strong>依赖传递：</strong></p><ol><li>减少重复依赖：当多个项目依赖同一个库时，Maven 可以自动下载并且只下载一次该库。这样可以减少项目的构建时间和磁盘空间。</li><li>自动管理依赖: Maven 可以自动管理依赖项，使用依赖传递，简化了依赖项的管理，使项目构建更加可靠和一致。</li><li>确保依赖版本正确性：通过依赖传递的依赖，之间都不会存在版本兼容性问题，确实依赖的版本正确性！</li></ol><p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p><ul><li>B 依赖 C 时使用 compile 范围：可以传递</li><li>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li></ul><p><strong>依赖传递冲突问题</strong></p><p>当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！</p><ul><li>短路优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高。</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。</li><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。</li></ul><p><strong>可选依赖（不透明）</strong></p><p>可选依赖指对外隐藏当前所依赖的资源一一不透明。</p><p>将某依赖的<code>&lt;optional&gt;</code>标签指定为true时，间接引用该依赖的项目将无法看到该依赖资源。</p><p><strong>排除依赖（不需要）</strong></p><p>排除依赖指主动断开间接依赖的资源，被排除的资源无需指定版本一一不需要。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖范围</strong></p><p>依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>scope的可选值有4种，分别为 <strong>compile</strong>&#x2F;<strong>test</strong>&#x2F;<strong>provided</strong>&#x2F;system&#x2F;runtime&#x2F;**import **.它们在项目中的作用范围各不相同。</p><p><strong>①compile 和 test 对比</strong></p><table><thead><tr><th></th><th>main目录（空间）</th><th>test目录（空间）</th><th>开发过程（时间）</th><th>部署到服务器（时间）</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>test</td><td>无效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><p><strong>②compile 和 provided 对比</strong></p><table><thead><tr><th></th><th>main目录（空间）</th><th>test目录（空间）</th><th>开发过程（时间）</th><th>部署到服务器（时间）</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>provided</td><td>有效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><p><strong>③结论</strong></p><p>compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</p><p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。</p><p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。说白了就是：“<strong>服务器上已经有了，你就别带啦！</strong>”</p><h2 id="继承和聚合"><a href="#继承和聚合" class="headerlink" title="继承和聚合"></a>继承和聚合</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在父模块指定所有子模块用到的依赖的资源和对应版本，子模块使用资源时指定依赖资源即可，无需再声明版本，解决资源版本一致性问题。</p><ul><li>父工程</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子工程</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。</p><p>优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。</p><p>父项目中包含的子项目列表。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-project1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-project2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><strong>自定义属性</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>内置属性</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;basedir&#125;</span><br><span class="line">$&#123;version&#125;</span><br></pre></td></tr></table></figure><p><strong>setting属性</strong></p><p>使用maven配置文件setting.xml中的标签属性，用于动态配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;settings.localRepository&#125;</span><br></pre></td></tr></table></figure><p><strong>Java系统属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;user.home&#125;</span><br></pre></td></tr></table></figure><p><strong>环境变量属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;env.JAVA_HOME&#125;</span><br></pre></td></tr></table></figure><p><strong>系统属性查询方式：</strong><code>mvn help:system</code></p><h2 id="多环境开发配置"><a href="#多环境开发配置" class="headerlink" title="多环境开发配置"></a>多环境开发配置</h2><p>很多情况下，生产环境、开发环境、测试环境的属性值配置各不同。因此需要在不同的环境上加载其对应的属性配置。达到多环境兼容的目的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义具体的环境：生成环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义环境对应的唯一名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>pro_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义环境中专用的属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置默认启动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义具体的环境：开发环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>dev_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>加载指定环境</strong>：<code>mvn 指令 –P 环境定义id</code></p><p>例如，<code>mvn install –P pro_env</code></p><h2 id="依赖导入失败场景和解决方案"><a href="#依赖导入失败场景和解决方案" class="headerlink" title="依赖导入失败场景和解决方案"></a>依赖导入失败场景和解决方案</h2><p>  在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种：</p><ol><li>下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。</li><li>依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。</li><li>本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项，并且也无法重新下载！</li></ol><p>  解决方案：</p><ol><li>检查网络连接和 Maven 仓库服务器状态。</li><li>确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。</li><li>清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！</li></ol><p>​      </p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus</title>
      <link href="/2023/11/06/mybatis-plus/"/>
      <url>/2023/11/06/mybatis-plus/</url>
      
        <content type="html"><![CDATA[<p><strong>官方网站</strong>：<a href="https://baomidou.com/">https://baomidou.com/</a></p><p><strong>官方文档</strong>：<a href="https://baomidou.com/pages/24112f/">https://baomidou.com/pages/24112f/</a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><ol><li><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置文件application.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据源</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment">#配置连接数据库的信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> &#123;<span class="string">username</span>&#125;</span><br><span class="line">    <span class="attr">password:</span> &#123;<span class="string">password</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;指定Mapper接口所在的包&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusDemoApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(MybatisPlusDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;`user`&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写Mapper接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="Mapper层CRUD接口"><a href="#Mapper层CRUD接口" class="headerlink" title="Mapper层CRUD接口"></a>Mapper层CRUD接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通用 CRUD 封装BaseMapper (opens new window)接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器</span><br><span class="line">泛型 T 为任意实体对象</span><br><span class="line">参数 Serializable 为任意类型主键 Mybatis-Plus 不推荐使用复合主键约定每一张表都有自己的唯一 id 主键</span><br><span class="line">对象 Wrapper 为条件构造器</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 修改</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><h3 id="Service层CRUD接口"><a href="#Service层CRUD接口" class="headerlink" title="Service层CRUD接口"></a>Service层CRUD接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通用 Service CRUD 封装IService (opens new window)接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆，</span><br><span class="line">泛型 T 为任意实体对象</span><br><span class="line">建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类</span><br><span class="line">对象 Wrapper 为 条件构造器</span><br></pre></td></tr></table></figure><p>MyBatis-Plus中有一个接口 <code>IService</code>和其实现类 <code>ServiceImpl</code>，封装了常见的业务层逻辑，详情查看源码 IService 和 ServiceImpl</p><p>因此我们在使用的时候仅需在自己定义的<code>Service</code>接口中继承<code>IService</code>接口，在自己的实现类中实现自己的Service并继承<code>ServiceImpl</code>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserServicce</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServicceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure><h4 id="saveOrUpdate"><a href="#saveOrUpdate" class="headerlink" title="saveOrUpdate"></a>saveOrUpdate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 queryWrapper 设置的条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br></pre></td></tr></table></figure><h4 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><p><strong>MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h3><p>MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id, 通过<code>@TableId</code>将属性标识为主键</p><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><p><strong>value属性</strong></p><p>若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解@TableId，则抛出异常<code>Unknown column ‘id’ in ‘field list’</code>，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，<code>@TableId(&quot;uid&quot;)</code>或<code>@TableId(value=&quot;uid&quot;)</code></p><p><strong>type属性</strong></p><p>type属性用来定义主键策略：默认雪花算法</p><p>常用的主键策略：</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IdType.ASSIGN_ID（默认）</td><td align="center">基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td></tr><tr><td align="center">IdType.AUTO</td><td align="center">使用数据库的自增策略，注意，该类型请确保数据库设置了id自增</td></tr></tbody></table><p><strong>配置全局主键策略：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#MyBatis-Plus相关配置</span><br><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    #配置日志</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      #配置主键策略为自增</span><br><span class="line">      id-type: auto</span><br><span class="line">      # 设置实体类所对应的表的统一前缀</span><br><span class="line">      table-prefix: t_</span><br></pre></td></tr></table></figure><h3 id="TbaleField"><a href="#TbaleField" class="headerlink" title="@TbaleField"></a>@TbaleField</h3><p>解决属性名和字段名不一致的情况</p><h3 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a>@TableLogic</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</span><br><span class="line"></span><br><span class="line">逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</span><br><span class="line"></span><br><span class="line">使用场景：可以进行数据恢复</span><br></pre></td></tr></table></figure><p>使用：</p><ol><li><p>数据库中创建逻辑删除状态列，设置默认值为0 <code>is_deleted int</code></p></li><li><p>实体类中添加逻辑删除属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@TableLogic</span><br><span class="line">private int idDeleted;</span><br></pre></td></tr></table></figure></li><li><p>测试删除功能，真正执行的是修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userMapper.deleteById(1);</span><br><span class="line">//UPDATE t_user SET is_deleted=1 WHERE uid=? AND is_deleted=0;</span><br></pre></td></tr></table></figure></li></ol><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><ul><li><code>Wrapper</code> ： 条件构造抽象类，最顶端父类<ul><li><code>AbstractWrapper </code>： 用于查询条件封装，生成 sql 的 where 条件<ul><li><code>QueryWrapper </code>： 查询条件封装</li><li><code>UpdateWrapper </code>： Update 条件封装</li><li><code>AbstractLambdaWrapper </code>： 使用Lambda 语法<ul><li><code>LambdaQueryWrapper </code>：用于Lambda语法使用的查询Wrapper</li><li><code>LambdaUpdateWrapper </code>： Lambda 更新封装Wrapper</li></ul></li></ul></li></ul></li></ul><h3 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">allEq: 全部eq(或个别isNull)</span><br><span class="line">eq: =</span><br><span class="line">ne: !=</span><br><span class="line">gt: &gt;</span><br><span class="line">ge: &gt;=</span><br><span class="line">lt: &lt;</span><br><span class="line">le: &lt;=</span><br><span class="line">between</span><br><span class="line">notBetween</span><br><span class="line">like: LIKE &#x27;%值%&#x27;</span><br><span class="line">notLike</span><br><span class="line">likeLeft: LIKE &#x27;%值&#x27;</span><br><span class="line">likeRight</span><br><span class="line">notLikeLeft</span><br><span class="line">notLikeRight</span><br><span class="line">isNull</span><br><span class="line">isNotNull</span><br><span class="line">in</span><br><span class="line">notIn</span><br><span class="line">inSql: 字段 IN (sql语句) </span><br><span class="line">inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3)</span><br><span class="line">notInSql</span><br><span class="line">groupBy</span><br><span class="line">orderByAsc</span><br><span class="line">orderByDesc</span><br><span class="line">orderBy</span><br><span class="line">having: HAVING ( sql语句 )</span><br><span class="line">having(&quot;sum(age) &gt; &#123;0&#125;&quot;, 11)---&gt;having sum(age) &gt; 11</span><br><span class="line">func: func 方法(主要方便在出现if...else下调用不同方法能不断链)</span><br><span class="line">func(i -&gt; if(true) &#123;i.eq(&quot;id&quot;, 1)&#125; else &#123;i.ne(&quot;id&quot;, 1)&#125;)</span><br><span class="line">or: 主动调用or表示紧接着下一个方法不是用and连接!(不调用or则默认为使用and连接)</span><br><span class="line">and</span><br><span class="line">nested: 正常嵌套 不带 AND 或者 OR</span><br><span class="line">apply: 拼接sql</span><br><span class="line">该方法可用于数据库函数 动态入参的params对应前面applySql内部的&#123;index&#125;部分.这样是不会有sql注入风险的,反之会有!</span><br><span class="line">apply(&quot;date_format(dateColumn,&#x27;%Y-%m-%d&#x27;) = &#123;0&#125;&quot;, &quot;2008-08-08&quot;)---&gt;date_format(dateColumn,&#x27;%Y-%m-%d&#x27;) = &#x27;2008-08-08&#x27;&quot;)</span><br><span class="line">last: 无视优化规则直接拼接到 sql 的最后.只能调用一次,多次调用以最后一次为准 有sql注入的风险,请谨慎使用</span><br><span class="line">exists</span><br><span class="line">notExists</span><br></pre></td></tr></table></figure><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><p>UpdateWrapper不仅拥有QueryWrapper的组装条件功能，还提供了set方法进行修改对应条件的数据库信息</p><h3 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h3><p>提供了Lambda表达式的语法可以避免填错列名。</p><h3 id="LambdaUpdateWrapper"><a href="#LambdaUpdateWrapper" class="headerlink" title="LambdaUpdateWrapper"></a>LambdaUpdateWrapper</h3><p>提供了Lambda表达式的语法可以避免填错列名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(User::getAge, <span class="number">20</span>).or().isNull(User::getEmail));</span><br><span class="line">    updateWrapper.set(User::getName, <span class="string">&quot;小黑&quot;</span>).set(User::getEmail,<span class="string">&quot;abc@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h2><p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果</p><p>我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p><p><strong>添加配置类<code>MyBatisPlusConfig</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;scan.your.mapper.package&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加分页插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<span class="comment">//如果配置多个插件,切记分页最后添加</span></span><br><span class="line">        <span class="comment">//interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); 如果有多数据源可以不配具体类型 否则都建议配上具体的DbType</span></span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//new Page()中的两个参数分别是当前页码，每页显示数量</span></span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="literal">null</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义分页</strong></p><p><strong>在<code>UserMapper</code>接口中定义一个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据年龄查询用户列表，分页显示 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> age 年龄 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">Page&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page,<span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br></pre></td></tr></table></figure><p><strong>在<code>UserMapper.xml</code>中编写SQL实现该方法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select id,username as name,age,email from t_user where age &gt; #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageVo</span><span class="params">()</span>&#123;</span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPageVo(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;User&gt;(<span class="number">1</span>,<span class="number">2</span>), <span class="number">20</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><strong>OptimisticLockerInnerInterceptor</strong></p><p>当要更新一条记录的时候，希望这条记录没有被别人更新<br>乐观锁实现方式：</p><blockquote><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li><li>如果 version 不对，就更新失败</li></ul></blockquote><p><strong>实现</strong></p><p><strong>实体类<code>version</code>字段添加注解<code>@Version</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加乐观锁插件配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="comment">//添加乐观锁插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h2><p><strong>使用 @EnumValue 注解枚举属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GradeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    PRIMARY(<span class="number">1</span>, <span class="string">&quot;小学&quot;</span>),  SECONDORY(<span class="number">2</span>, <span class="string">&quot;中学&quot;</span>),  HIGH(<span class="number">3</span>, <span class="string">&quot;高中&quot;</span>);</span><br><span class="line"></span><br><span class="line">    GradeEnum(<span class="type">int</span> code, String descp) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.descp = descp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span><span class="comment">//标记数据库存的值是code</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h2><p><strong>@DS</strong> 可以注解在方法上或类上，<strong>同时存在就近原则 方法上注解 优先于 类上注解</strong>。</p><p><strong>引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>编写配置文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br><span class="line">        <span class="attr">slave_1:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure><p><strong>创建实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建Mapper和Service</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>新建Service接口<code>UserService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;master&quot;)</span> <span class="comment">//指定操作的数据源，master为user表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>新建Service接口<code>ProductService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;slave_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>建立Service的实现类</strong></p><p><strong>测试</strong></p><h2 id="MyBatisX"><a href="#MyBatisX" class="headerlink" title="MyBatisX"></a>MyBatisX</h2><p><a href="https://baomidou.com/pages/ba5b24/#%E5%8A%9F%E8%83%BD">MybatisX快速开发插件 | MyBatis-Plus (baomidou.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis-Plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger</title>
      <link href="/2023/11/02/swagger/"/>
      <url>/2023/11/02/swagger/</url>
      
        <content type="html"><![CDATA[<h3 id="集成SpringBoot"><a href="#集成SpringBoot" class="headerlink" title="集成SpringBoot"></a>集成SpringBoot</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>在配置文件 <code>config</code> 目录下，添加 swagger 的配置文件 <code>SwaggerConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">// 开启 swagger2 的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 swagger 的 bean 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// 配置基本信息</span></span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本信息设置</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(</span><br><span class="line">                <span class="string">&quot;xxx&quot;</span>, <span class="comment">// 作者姓名</span></span><br><span class="line">                <span class="string">&quot;https://blog.csdn.net/xhmico?type=blog&quot;</span>, <span class="comment">// 作者网址</span></span><br><span class="line">                <span class="string">&quot;xxx@163.com&quot;</span>); <span class="comment">// 作者邮箱</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;多加辣-接口文档&quot;</span>) <span class="comment">// 标题</span></span><br><span class="line">                .description(<span class="string">&quot;众里寻他千百度，慕然回首那人却在灯火阑珊处&quot;</span>) <span class="comment">// 描述</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://www.baidu.com&quot;</span>) <span class="comment">// 跳转连接</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>) <span class="comment">// 版本</span></span><br><span class="line">                .license(<span class="string">&quot;Swagger-的使用(详细教程)&quot;</span>)</span><br><span class="line">                .licenseUrl(<span class="string">&quot;https://blog.csdn.net/xhmico/article/details/125353535&quot;</span>)</span><br><span class="line">                .contact(contact)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 swagger 的 bean 实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置接口信息</span></span><br><span class="line">            .select() <span class="comment">// 设置扫描接口</span></span><br><span class="line">            <span class="comment">// 配置如何扫描接口</span></span><br><span class="line">            .apis(RequestHandlerSelectors</span><br><span class="line">                    <span class="comment">//.any() // 扫描全部的接口，默认</span></span><br><span class="line">                    <span class="comment">//.none() // 全部不扫描</span></span><br><span class="line">                    .basePackage(<span class="string">&quot;com.duojiala.mikeboot.controller&quot;</span>) <span class="comment">// 扫描指定包下的接口，最为常用</span></span><br><span class="line">                    <span class="comment">//.withClassAnnotation(RestController.class) // 扫描带有指定注解的类下所有接口</span></span><br><span class="line">                    <span class="comment">//.withMethodAnnotation(PostMapping.class) // 扫描带有只当注解的方法接口</span></span><br><span class="line"></span><br><span class="line">            )</span><br><span class="line">        <span class="comment">//过滤</span></span><br><span class="line">            .paths(PathSelectors</span><br><span class="line">                    .any() <span class="comment">// 满足条件的路径，该断言总为true</span></span><br><span class="line">                    <span class="comment">//.none() // 不满足条件的路径，该断言总为false（可用于生成环境屏蔽 swagger）</span></span><br><span class="line">                    <span class="comment">//.ant(&quot;/user/**&quot;) // 满足字符串表达式路径</span></span><br><span class="line">                    <span class="comment">//.regex(&quot;&quot;) // 符合正则的路径</span></span><br><span class="line">            )</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置swagger开启"><a href="#配置swagger开启" class="headerlink" title="配置swagger开启"></a>配置swagger开启</h4><p>application.yml ————————– 全局配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p>application-dev.yml ——————– 开发环境配置文件<br>application-test.yml ——————– 测试环境配置文件<br>application-pro.yml ——————– 生产环境配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * swagger 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment 环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置环境范围</span></span><br><span class="line">    <span class="type">Profiles</span> <span class="variable">profiles</span> <span class="operator">=</span> Profiles.of(<span class="string">&quot;dev&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果在该环境返回内则返回：true，反之返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> environment.acceptsProfiles(profiles);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 swagger 的 bean 实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .enable(flag) <span class="comment">// 是否开启 swagger：true -&gt; 开启，false -&gt; 关闭</span></span><br><span class="line">            ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置分组"><a href="#配置分组" class="headerlink" title="配置分组"></a>配置分组</h4><p>swagger 文档中组名默认是 <code>default</code>，可通过 <code>.groupName(String )</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 swagger 的 bean 实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .groupName(<span class="string">&quot;mike&quot;</span>) <span class="comment">// 修改组名为 &quot;mike&quot;</span></span><br><span class="line">            ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要配置多个组的话，就需要配置多个 <code>docket() 方法</code></p><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><h5 id="ApiModel"><a href="#ApiModel" class="headerlink" title="@ApiModel"></a>@ApiModel</h5><p>该注解是作用于类上面的，是用来描述类的一些基本信息的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value：提供类的一个备用名，如果不设置，默认情况下将使用 class 类的名称</span><br><span class="line">description：对于类，提供一个详细的描述信息</span><br><span class="line">parent：这个属性用于描述的是类的一些父类信息</span><br><span class="line">discriminator：这个属性解释起来比较麻烦，因为这个类主要体现在断言当中</span><br><span class="line">subTypes：可以通过这个属性，指定我们想要使用的子类</span><br></pre></td></tr></table></figure><h5 id="ApiModelProperty"><a href="#ApiModelProperty" class="headerlink" title="@ApiModelProperty"></a>@ApiModelProperty</h5><p><a href="https://blog.csdn.net/weixin_44356055/article/details/109451892">@ApiModelProperty注解的用法</a></p><p>它的作用是添加和操作属性模块的数据</p><h5 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a>@ApiOperation</h5><p>该注解用来对某个方法&#x2F;接口进行描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value：对该操作进行简单的描述，尽量控制在120字符以内。</span><br><span class="line">notes：对操作的详细描述。</span><br><span class="line">httpMethod：指定操作使用的HTTP方法类型，可选值 “GET”、“HEAD”、“POST”、“PUT”、“DELETE”、“OPTIONS”和“PATCH”。</span><br></pre></td></tr></table></figure><h5 id="ApiParam"><a href="#ApiParam" class="headerlink" title="@ApiParam"></a>@ApiParam</h5><p>该注解使用在方法上或者参数上，字段说明，表示对参数的添加元数据（说明或者是否必填等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name：参数名</span><br><span class="line">value：参数说明</span><br><span class="line">required：是否必填</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/10/28/git/"/>
      <url>/2023/10/28/git/</url>
      
        <content type="html"><![CDATA[<h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><h4 id="Git-使用前配置"><a href="#Git-使用前配置" class="headerlink" title="Git 使用前配置"></a>Git 使用前配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 配置提交人姓名：git config --global user.name “提交人姓名” # (对当前系统用户有效)</span><br><span class="line">2. 配置提交人姓名：git config --global user.email  “提交人邮箱” # (对当前系统用户有效)</span><br><span class="line">作用：识别开发人员，与登良github的账户无关</span><br><span class="line">3. 查看git配置信息：git config --list</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add XX ：将XX文件添加到暂存区</span><br><span class="line">git commit -m &quot;给自己看的备注信息&quot;：将暂存区的内容提交到当前分支</span><br><span class="line">git status：查看仓库状态</span><br><span class="line">git log：查看当前分支的所有版本</span><br><span class="line">git push -u (第一次需要-u以后不需要) ：将当前分支推送到远程仓库</span><br><span class="line">git clone git@git.acwing.com:xxx/XXX.git：将远程仓库XXX下载到当前目录下</span><br><span class="line">git branch：查看所有分支和当前所处分支</span><br></pre></td></tr></table></figure><h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git diff XX：查看XX文件相对于暂存区修改了哪些内容</span><br><span class="line">git status：查看仓库状态</span><br><span class="line">git log：查看当前分支的所有版本</span><br><span class="line">git log --pretty=oneline：用一行来显示</span><br><span class="line">git reflog：查看HEAD指针的移动历史（包括被回滚的版本）</span><br><span class="line">git branch：查看所有分支和当前所处分支</span><br><span class="line">git pull ：将远程仓库的当前分支与本地仓库的当前分支合并</span><br></pre></td></tr></table></figure><h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached XX：将文件从仓库索引目录中删掉，不希望管理这个文件</span><br><span class="line">git restore --staged xx：==将xx从暂存区里移除==</span><br><span class="line">git checkout — XX或git restore XX：==将XX文件尚未加入暂存区的修改全部撤销==</span><br></pre></td></tr></table></figure><h4 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^ 或git reset --hard HEAD~ ：将代码库回滚到上一个版本</span><br><span class="line">git reset --hard HEAD^^：往上回滚两次，以此类推</span><br><span class="line">git reset --hard HEAD~100：往上回滚100个版本</span><br><span class="line">git reset --hard 版本号：回滚到某一特定版本</span><br></pre></td></tr></table></figure><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git remote -v：查看当前所有远程地址别名</span><br><span class="line">git remote add origin git@git.acwing.com:xxx/XXX.git：将本地仓库关联到远程仓库，origin是别名</span><br><span class="line">git push -u (第一次需要-u以后不需要) ：将当前分支推送到远程仓库</span><br><span class="line">git push origin branch_name：将本地的某个分支推送到远程仓库</span><br><span class="line">git clone git@git.acwing.com:xxx/XXX.git：将远程仓库XXX下载到当前目录下</span><br><span class="line">git push --set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支</span><br><span class="line">git push -d origin branch_name：删除远程仓库的branch_name分支</span><br><span class="line">git checkout -t origin/branch_name 将远程的branch_name分支拉取到本地</span><br><span class="line">git pull ：将远程仓库的当前分支与本地仓库的当前分支合并</span><br><span class="line">git pull 远程库地址别名 branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并</span><br><span class="line">git branch --set-upstream-to=origin/branch_name1 branch_name2：将远程的branch_name1分支与本地的branch_name2分支对应</span><br></pre></td></tr></table></figure><h4 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git branch branch_name：创建新分支</span><br><span class="line">git branch：查看所有分支和当前所处分支</span><br><span class="line">git checkout -b branch_name：创建并切换到branch_name这个分支</span><br><span class="line">git checkout branch_name：切换到branch_name这个分支</span><br><span class="line">git merge branch_name：将分支branch_name合并到当前分支上</span><br><span class="line">git branch -d branch_name：删除本地仓库的branch_name分支</span><br><span class="line">git push --set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支</span><br><span class="line">git push -d origin branch_name：删除远程仓库的branch_name分支</span><br><span class="line">git checkout -t origin/branch_name 将远程的branch_name分支拉取到本地</span><br><span class="line">git pull ：将远程仓库的当前分支与本地仓库的当前分支合并</span><br><span class="line">git pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并</span><br><span class="line">git branch --set-upstream-to=origin/branch_name1 branch_name2：将远程的branch_name1分支与本地的branch_name2分支对应</span><br></pre></td></tr></table></figure><h4 id="stash暂存"><a href="#stash暂存" class="headerlink" title="stash暂存"></a>stash暂存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash：将工作区和暂存区中尚未提交的修改存入栈中</span><br><span class="line">git stash apply：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</span><br><span class="line">git stash drop：删除栈顶存储的修改</span><br><span class="line">git stash pop：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</span><br><span class="line">git stash list：查看栈中所有元素</span><br></pre></td></tr></table></figure><h4 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生成秘钥：ssh-keygen</span><br><span class="line">秘钥存储目录：C:\Users\用户\\.ssh</span><br><span class="line">公钥名称：id_rsa.pub</span><br><span class="line">私钥名称：id_rsa</span><br><span class="line">解析：使用ssh-keygen命令，然后生成秘钥，私钥</span><br><span class="line">保存在自己的电脑中，公钥发布在自己的远程仓库</span><br><span class="line">中（在settings中找到设置ssh的地方，将公钥的</span><br><span class="line">内容复制到那里），然后复制相应仓库的ssh地址，</span><br><span class="line">然后正常操作就可以实现免密码登录。</span><br></pre></td></tr></table></figure><h4 id="团队合作流程"><a href="#团队合作流程" class="headerlink" title="团队合作流程"></a>团队合作流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">同队开发</span><br><span class="line">1.首先A方创建远程仓库，将本地仓库推送到远程仓库</span><br><span class="line">（我们本地仓库的版本必须大于远程仓库的版本，否则push失败。），</span><br><span class="line">采用git push 远程仓库地址 分支名称。</span><br><span class="line">git push https://github.com/yxjgithub-png/git-demo.git master # 将master分支推送到远程仓库。但是这里地址麻烦，可以采用步骤2添加别名</span><br><span class="line"></span><br><span class="line">2. git remote add 远程仓库地址别名(可以自定义,一般为origin)  远程仓库地址 # (查看当前远程地址的别名</span><br><span class="line">git remote -v )</span><br><span class="line">git remote add origin https://github.com/yxjgithub-png/git-demo.git # 如果不想使用地址形式，可以采用别名来代替。如果想直接使用git push，则可以采用步骤3</span><br><span class="line"></span><br><span class="line">3. git push -u 远程仓库地址别名 分支名称</span><br><span class="line">git push origin master  # 推送远程分支</span><br><span class="line">git push -u origin master # -u 记住推送地址及分支，下次推送只需要输入git push即可.B方想加入团队进行开发，则需要步骤4.</span><br><span class="line">解析：第一次输入需要用户名和密码，以后不用，window系统会帮助我们记住用户名和密码，在那个控制面板的凭据管理器中。</span><br><span class="line"></span><br><span class="line">4.git clone 仓库地址 </span><br><span class="line">git clone 远程仓库地。B方想推送自己修改的内容，则需要步骤5</span><br><span class="line">效果:1.下载内容到本地 2.克隆别人远程仓库的别名 3.初始化仓库</span><br><span class="line"></span><br><span class="line">当我们需要clone后想把内容推送到别人的远程仓库时，不可以直接推送，而是需要别人在相应的远程仓库的settings里面操作，填写邀请队友的账号。当我们用git clone的时候，不仅将对方的东西复制过来，而且连对方远程仓库的别名也复制过来。</span><br><span class="line">5. git push 远程仓库地址 推送的分支</span><br><span class="line">git push origin master  # B方想把内容推送给A方，然后A方可以采用步骤6进行版本的更新</span><br><span class="line"></span><br><span class="line">git push &lt;远程主机名&gt;  &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.git pull</span><br><span class="line">拉取远程仓库中最新的版本：git pull 远程仓库地址 远程地址分支名称</span><br><span class="line">git pull origin master # 拉取origin主机的master分支，与本地当前分支合并</span><br><span class="line"></span><br><span class="line">比如，要取回origin主机的next分支，与本地的master分支合并，需要写成下面这样   git pull origin next:master</span><br><span class="line">如果远程分支(next)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为：git pull origin next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git clone 跟 git pull的区别</span><br><span class="line">git clone是在没有本地仓库的基础上clone别人的东西，而git pull则是在有本地仓库的基础上拉取代码到本地。git clone</span><br><span class="line">只是第一次参与开发时用，以后都是用git pull命令</span><br><span class="line"></span><br><span class="line">解决冲突</span><br><span class="line">在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。</span><br><span class="line">先把远程仓库pull下来，然后删除冲突的标记，再做相应的修改即可。然后git add，git commit，git push上去。</span><br><span class="line"></span><br><span class="line">跨团队协作</span><br><span class="line">1. 程序员 C fork仓库：把对方远程仓库的内容复制到自己的远程仓库</span><br><span class="line">2. 程序员 C 将远程仓库克隆在本地进行修改</span><br><span class="line">3. 程序员 C 将仓库推送到自己的远程仓库</span><br><span class="line">4. 程序员 C如果想要把修改内容发给对方，则需要点击pull request命令</span><br><span class="line">5. 然后等待原远程仓库作者审核</span><br><span class="line">6. 原远程仓库作者合并代码即可</span><br></pre></td></tr></table></figure><h4 id="Git忽略清单"><a href="#Git忽略清单" class="headerlink" title="Git忽略清单"></a>Git忽略清单</h4><p>将不需要被git管理的文件名字添加到git.gitignore中，在执行git命令的时候，git就会忽略这些文件。这个文件的存放位置原则上在哪里都可以，为了便于让~&#x2F;.gitconfig 文件引用，建议也放在用 户家目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"># virtual machine crash logs, see </span><br><span class="line">http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>在.gitconfig 文件中引用忽略配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = Layne</span><br><span class="line">email = Layne@atguigu.com</span><br><span class="line">[core]</span><br><span class="line">excludesfile = C:/Users/asus/git.ignore</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2023/09/14/java/"/>
      <url>/2023/09/14/java/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><ul><li><p>删除行(delete line)：<code>ctrl</code>+<code>d</code></p></li><li><p>复制行(duplicate)：<code>ctrl</code>+<code>alt</code>+向下箭头</p></li><li><p>补全：<code>alt</code>+<code>/</code></p></li><li><p>注释：<code>ctrl</code>+<code>/</code></p></li><li><p>导入该行需要的类：先配置<code>Auto import</code>, <code>alt</code>+<code>enter</code></p></li><li><p>快速格式化代码：<code>ctrl</code>+<code>alt</code>+<code>L</code></p></li><li><p>快速运行代码(run)：<code>ctrl</code>+<code>R</code></p></li><li><p>生成代码：<code>alt</code>+<code>insert</code></p></li><li><p>查看类的层级关系：<code>ctrl</code>+<code>H</code></p></li><li><p>定位方法：<code>ctrl</code>+<code>B</code></p></li><li><p>自动创建变量名：通过在后面加<code>.var</code></p></li><li><p>模板：file-&gt;settings-&gt;editor-&gt;Live templates-&gt;查看模板快捷键和增加自己的模板</p></li></ul><h3 id="JAVA开发注意事项和细节"><a href="#JAVA开发注意事项和细节" class="headerlink" title="JAVA开发注意事项和细节"></a>JAVA开发注意事项和细节</h3><ul><li><p>执行入口是<code>main()</code>方法</p><p><code>public static void main(String[] args)&#123;...&#125;</code></p></li><li><p>一个源文件中最多只能有一个public类，其他类个数不限。也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。</p></li><li><p>如果源文件包含一个public类，则文件名必须按该类命名</p></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>单行注释：&#x2F;&#x2F;</p></li><li><p>多行注释：&#x2F;*    *&#x2F;，不允许多行注释嵌套</p></li><li><p>文档注释：<code>javadoc -d 文件夹名 -xx -yy file.java</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @author xx</span><br><span class="line">  * @version yy</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>标签</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">@author</td><td align="center">标识一个类的作者</td><td align="center">@author description</td></tr><tr><td align="left">@deprecated</td><td align="center">指名一个过期的类或成员</td><td align="center">@deprecated description</td></tr><tr><td align="left">{@docRoot}</td><td align="center">指明当前文档根目录的路径</td><td align="center">Directory Path</td></tr><tr><td align="left">@exception</td><td align="center">标志一个类抛出的异常</td><td align="center">@exception exception-name explanation</td></tr><tr><td align="left">{@inheritDoc}</td><td align="center">从直接父类继承的注释</td><td align="center">Inherits a comment from the immediate surperclass.</td></tr><tr><td align="left">{@link}</td><td align="center">插入一个到另一个主题的链接</td><td align="center">{@link name text}</td></tr><tr><td align="left">{@linkplain}</td><td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td align="center">Inserts an in-line link to another topic.</td></tr><tr><td align="left">@param</td><td align="center">说明一个方法的参数</td><td align="center">@param parameter-name explanation</td></tr><tr><td align="left">@return</td><td align="center">说明返回值类型</td><td align="center">@return explanation</td></tr><tr><td align="left">@see</td><td align="center">指定一个到另一个主题的链接</td><td align="center">@see anchor</td></tr><tr><td align="left">@serial</td><td align="center">说明一个序列化属性</td><td align="center">@serial description</td></tr><tr><td align="left">@serialData</td><td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td align="center">@serialData description</td></tr><tr><td align="left">@serialField</td><td align="center">说明一个ObjectStreamField组件</td><td align="center">@serialField name type description</td></tr><tr><td align="left">@since</td><td align="center">标记当引入一个特定的变化时</td><td align="center">@since release</td></tr><tr><td align="left">@throws</td><td align="center">和 @exception标签一样.</td><td align="center">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td align="left">{@value}</td><td align="center">显示常量的值，该常量必须是static属性。</td><td align="center">Displays the value of a constant, which must be a static field.</td></tr><tr><td align="left">@version</td><td align="center">指定类的版本</td><td align="center">@version info</td></tr></tbody></table></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li><p>整数类型：byte[1], short[2], int[4], long[8]。long类型后面要声明<code>l</code>或<code>L</code> </p></li><li><p>浮点类型：float[4], double[8]。默认double，float要加声明<code>l</code>或<code>L</code></p></li><li><p>字符类型：char[2]</p></li><li><p>布尔类型：boolean[1]</p></li></ul><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul><li><p>类(class)</p></li><li><p>接口(interface)</p></li><li><p>数组([])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义：数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[大小]</span><br><span class="line"> 数据类型 数组名[] = <span class="keyword">new</span> 数据类型[大小]</span><br><span class="line"> 数据类型[][] 数组名 = <span class="keyword">new</span> 数据类型[大小][大小]</span><br><span class="line"> </span><br><span class="line">数组默认情况下是引用传递，赋的值是地址</span><br><span class="line">数组拷贝：先开辟新空间，然后逐一拷贝元素</span><br><span class="line">数组扩容：定义一个更大的数组，然后使用引用传递（数组直接赋值）</span><br><span class="line"></span><br><span class="line">二维数组:多个一维数组组成，一维数组大小不要求相同</span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li><p>自动类型转换</p><ul><li><p>精度小的类型自动转换为精度大的类型</p></li><li><p>byte、short不能与char相互自动转换</p></li><li><p>byte, short, char三者之间可以计算，在计算时首先转换为int类型</p></li><li><p>boolean类型不参与自动转换</p></li></ul></li><li><p>强制类型转换: 使用强制转换符<code>()</code></p><ul><li>强制符号只针对最近的操作数有效，可以使用小括号提升优先级</li></ul></li><li><p>基本数据类型和字符串之间转换</p><ul><li><p>基本数据类型-&gt;字符串：基本数据类型 + “”</p></li><li><p>字符串-&gt;基本数据类型：通过基本数据类型的包装类调用parseXXX方法即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = Integer.parseInt(s);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p>取模：本质：a%b &#x3D; a - a &#x2F; b * b</p><p>a为小数，则：a%b &#x3D; a - (int)a &#x2F; b * b</p></li><li><p>短路与(&amp;&amp;)和逻辑与(&amp;)：短路与第一个为false，第二个不判断；逻辑与不管第一个如何都要判断第二个条件</p></li><li><p>短路或(||)和逻辑或(|)：短路或第一个为true，第二个不判断；逻辑或不管第一个如何都要判断第二个条件</p></li><li><p>符合赋值运算会进行类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 2;</span><br><span class="line">b+=2; //等价于b = (byte)(b + 2);</span><br></pre></td></tr></table></figure></li></ul><h3 id="键盘键入"><a href="#键盘键入" class="headerlink" title="键盘键入"></a>键盘键入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Scanner类所在的包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScaner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//使用相关方法接收输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> myScanner.next();</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> myScanner.nextInt();</span><br></pre></td></tr></table></figure><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><ul><li>二进制：以<code>0b</code>或<code>0B</code>开头</li><li>八进制：以<code>0</code>开头</li><li>十六进制：以<code>0x</code>或<code>0X</code>开头</li></ul><h3 id="JAVA内存结构分析"><a href="#JAVA内存结构分析" class="headerlink" title="JAVA内存结构分析"></a>JAVA内存结构分析</h3><p>创建对象过程：</p><ol><li>加载类信息（属性和方法，只会加载一次）</li><li>堆中分配空间，进行默认初始化，返回地址</li><li>指定初始化</li></ol><ul><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象（对象、数组等）</li><li>方法区：常量池（常量，比如字符串）、类加载信息</li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li><p>java中允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。通过可变参数实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回类型 方法名（数据类型... 形参名）&#123;&#125;</span><br><span class="line">public int sum(int... nums)&#123;&#125;//nums当作数组使用</span><br></pre></td></tr></table></figure></li><li><p>可变参数实参可以是数组，可变参数的本质就是数组</p></li><li><p>可变参数可以和普通类型的参数一起放在形参列表，但必须保证<strong>可变参数在最后</strong></p></li><li><p>一个形参列表<strong>只能出现一个</strong>可变参数</p></li></ul><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 方法名（形参列表）&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器没有返回值</li><li>方法名和类名一样</li><li>构造器的调用系统自动完成</li><li>没有定义构造器，系统自动给类生成一个默认无参构造器；一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显示的定义一下。</li></ul><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ul><li>调用本类构造器：<code>this(参数列表)</code>，只能在构造器中使用且必须放在第一条语句</li><li>在类定义的方法中用来访问类属性</li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li><p>作用：区分相同名字的类；管理类；控制访问范围</p></li><li><p>基本语法：<code>package 包名;</code></p></li><li><p>命名规范：一般小写。一般<code>com.公司名.项目名.业务模块</code></p></li></ul><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><table><thead><tr><th>访问级别</th><th>修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>公开</td><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>受保护</td><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>默认</td><td></td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>私有</td><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>修饰符可以用来修饰属性，成员方法和类</li><li>只有默认和<code>public</code>才能修饰类</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>隐藏细节，对数据进行验证以保证合理合法性</p><p>封装实现步骤：1.属性私有化；2.提供一个公共的set方法对属性进行判断和赋值；3.提供一个公共的get方法获取属性</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>子类继承了所有属性和方法，但是私有属性和方法不能在子类直接访问，要通过父类公共的方法</p></li><li><p>子类必须调用父类的构造器完成父类的初始化</p></li><li><p>当创建子类的对象时，默认总会区调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super(参数列表);</code>去指定使用父类的哪个构造器完成父类的初始化工作，否则编译不会通过。</p></li><li><p><code>super()</code>使用时必须放在构造器第一行</p></li><li><p><code>super()</code>和<code>this()</code>都只能放在构造器第一行，因此不能共存在一个构造器</p></li><li><p>所有类都是<code>Object</code>类的子类</p></li><li><p>子类只能继承一个父类，即单继承机制</p></li></ul><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super代表父类的引用，用于访问父类的属性、方法、构造器。</p><p>就近原则，如果父类没有则往上查找。</p><ul><li>访问父类的属性，但不能访问父类的私有属性 </li><li>访问父类的方法，但不能访问父类的私有方法</li><li>访问父类的构造器，只能放在构造器第一句 <code>super(参数列表)</code></li></ul><table><thead><tr><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>访问属性</td><td>访问本类中属性，如果没有从父类中继续查找</td><td>从父类开始查找属性</td></tr><tr><td>调用方法</td><td>访问本类中方法，如果没有从父类中继续查找</td><td>从父类开始查找方法</td></tr><tr><td>调用构造器</td><td>调用本类构造器，必须放在首行</td><td>调用父类构造器，必须放在首行</td></tr><tr><td>特殊</td><td>表示当前对象</td><td>子类中访问父类对象</td></tr></tbody></table><h3 id="方法重写-x2F-覆盖"><a href="#方法重写-x2F-覆盖" class="headerlink" title="方法重写&#x2F;覆盖"></a>方法重写&#x2F;覆盖</h3><ul><li>子类的方法的参数，方法名称必须和父类一样</li><li>子类方法的返回类型和父类一样，或者是父类返回类型的子类，例如<code>public Object getInfo()&#123;&#125;</code>和<code>public String getInfo()&#123;&#125;</code></li><li>子类方法不能缩小父类方法的访问权限</li></ul><table><thead><tr><th>名称</th><th>发生范围</th><th>方法名</th><th>参数列表</th><th>返回类型</th><th>修饰符</th></tr></thead><tbody><tr><td>重载(overload)</td><td>本类</td><td>相同</td><td>不同</td><td>无要求</td><td>无要求</td></tr><tr><td>重写(override)</td><td>父子类</td><td>相同</td><td>相同</td><td>返回类型和父类一致，或者是其子类</td><td>不能缩小父类方法的访问范围</td></tr></tbody></table><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>重载和重写</li><li>对象的多态<ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时就确定了，不能改变</li><li>运行类型是可以变化的</li><li>编译类型看定义时<code>=</code>左边，运行类型看<code>=</code>右边</li></ul></li><li>多态的前提是：两个对象存在继承关系</li><li>多态的向上转型<ul><li>本质：父类的引用指向子类对象</li><li>语法：<code>父类 引用名 = new 子类();</code></li><li>可以调用父类的所有成员（需要遵守访问权限）；不能调用子类中的特有成员；最终运行效果看子类的具体实现</li></ul></li><li>向下转型<ul><li>语法：<code>子类 引用名 = (子类类型) 父类引用</code></li><li>只能强转父类的引用，不能强转父类的对象</li><li>要求父类对象的引用必须指向当前目标类型的对象</li><li>可以调用子类类型中的所有成员</li></ul></li></ul><h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h4><ul><li>当调用对象方法时，该方法会和该对象的<strong>内存地址&#x2F;运行类型</strong>绑定</li><li>当调用对象属性时，<strong>没有动态绑定机制</strong>，哪里声明哪里使用</li></ul><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><ul><li><p>数组的定义类型为父类，保存的实际类型是子类</p></li><li><p>调用子类特有的方法时，先用<code>instanceof</code>判断，再向下转型</p></li></ul><h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><ul><li>方法定义的形参为父类类型，实参允许为子类类型</li></ul><h3 id="x3D-x3D-运算符"><a href="#x3D-x3D-运算符" class="headerlink" title="&#x3D;&#x3D;运算符"></a>&#x3D;&#x3D;运算符</h3><ul><li>既可以判断基本类型，又可以判断引用类型</li><li>判断基本类型，判断的是值是否相等；判断引用类型，判断的是地址是否相等</li><li>只要有基本数据类型，则判断的是值是否相等</li></ul><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><ul><li>equals是Object类中的方法，只能判断引用类型</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="类变量-x2F-静态变量"><a href="#类变量-x2F-静态变量" class="headerlink" title="类变量&#x2F;静态变量"></a>类变量&#x2F;静态变量</h4><ul><li><p>定义：<code>修饰符 static 数据类型 变量名;</code>或<code>static 修饰符 数据类型 变量名;</code></p></li><li><p>访问：<code>类名.变量名;</code>或<code>对象名.变量名</code></p></li><li><p><code>static</code>变量被对象所共享，在<strong>类加载的时候就生成</strong></p></li><li><p>静态变量保存再class实例的尾部，而class对象<strong>保存在堆中</strong></p></li><li><p>生命周期为类加载到类消亡</p></li></ul><h4 id="类方法-x2F-静态方法"><a href="#类方法-x2F-静态方法" class="headerlink" title="类方法&#x2F;静态方法"></a>类方法&#x2F;静态方法</h4><p>当方法中不涉及任何对象相关的成员或一些通用的方法，可以设计成静态方法提高开发效率</p><ul><li><p>定义：<code>修饰符 static 返回类型 方法名()&#123;&#125;</code></p></li><li><p>访问：<code>类名.方法名;</code></p></li><li><p>类方法和普通方法都随着类加载而加载，将结构信息存储到方法区</p></li><li><p>类方法中<strong>不允许使用和对象有关的关键字</strong>，如<code>this</code>和<code>super</code></p></li><li><p><strong>静态方法只能访问静态变量或静态方法</strong></p></li></ul><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><ul><li>main方法是虚拟机调用，访问权限必须是public</li><li>执行main方法时不必创建对象，所以必须是static</li><li>接收String类型的数组形参，保存运行时传递的参数</li><li>main方法中可以直接使用所在类的静态属性和静态方法；访问非静态成员，必须创建对象去调用</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块又叫初始化块，在加载类或创建对象时隐式调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">代码</span><br><span class="line">&#125;; //;可以省略</span><br></pre></td></tr></table></figure><ul><li><p>修饰符只能选<code>static</code>，分别称为静态代码块和普通代码块。<strong>静态代码块随类的加载而执行，只执行一次，而普通代码块每创建对象都会执行</strong></p></li><li><p>静态代码块只能调用静态成员，普通代码块可以调用任意成员</p></li><li><p>好处：</p><ul><li>相当于另一种形式的构造器，可以做初始化操作，代码块的<strong>调用优先于构造器</strong></li><li>如果多个构造器中都有重复语句，可以抽取到代码块中，提高复用性</li></ul></li></ul><p><strong>类什么时候加载？</strong></p><ul><li>创建对象实例（new)</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时</li></ul><p><strong>创建一个对象时，在一个类调用顺序</strong></p><ol><li>调用静态代码块和静态属性初始化（多个则按照定义顺序）</li><li>普通代码块和普通属性初始化</li><li>调用构造方法。构造器的最前面其实隐藏了<code>super()</code>和调用普通代码块</li></ol><p><strong>创建一个子类对象时，调用顺序</strong></p><ol><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性初始化</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性初始化</li><li>子类的构造方法</li></ol><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul><li><p>使用场景</p><ul><li>不希望类被继承 <code>final class 类名</code></li><li>不希望父类的某个方法被子类覆盖&#x2F;重写时 <code>修饰符 final 返回类型 方法名</code></li><li>不希望类的某个属性被修改 <code>修饰符 final 类型 变量名</code> </li><li>不希望某个局部变量被修改 <code>final 变量名</code></li></ul></li><li><p>final修饰的属性一般为常量，一般用<code>XX_XX</code>来命名</p></li><li><p>修饰的属性必须赋初值，以后不能修改，初始化位置：</p><ol><li>定义时</li><li>在构造器中</li><li>在代码块中</li></ol></li><li><p>修饰静态属性时，初始化位置：</p><ol><li>定义时</li><li>静态代码块</li></ol></li><li><p>类不是final类，但含有final方法，则该方法不能重写，但是可以被继承</p></li><li><p>final不能修饰构造器</p></li><li><p>final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理</p></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>某些方法不确定实现时可以声明为抽象方法让子类来实现，含抽象方法的类称为抽象类</p><p>声明为抽象方法：<code>public abstract void eat();</code> <strong>没有方法体</strong>，此时类也必须声明为<code>abstract</code>类</p><ul><li><p>抽象类不能被实例化</p></li><li><p>抽象类不一定要包含<code>abstract</code>方法，一旦包含<code>abstract</code>方法就必须声明为抽象类</p></li><li><p><code>abstract</code>只能用于声明类和方法</p></li><li><p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类</p></li><li><p>抽象方法不能用<code>private</code>, <code>final</code>, <code>static</code>来修饰，因为这些关键字于重写相违背。静态方法可以被子类继承，但不能被重写</p></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法实现出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">//属性</span><br><span class="line">//方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">//自己属性</span><br><span class="line">//自己方法</span><br><span class="line">//必须实现的接口的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>JDK7.0</code>之前 接口里的所有方法都没有方法体，即都是抽象方法；<code>JDK8.0</code>后接口可以有静态方法（加<code>static</code>），默认方法（加<code>default</code>关键字修饰），也就是说接口中可以有方法的具体实现</li><li>接口不能被实例化</li><li>接口中所有方法都是public方法，接口中抽象方法可以不用abstract修饰</li><li>一个普通类实现接口就必须将该接口的所有方法都实现</li><li>抽象类实现接口可以不用实现接口的方法</li><li>一个类可以同时实现多个接口</li><li>接口中的属性只能是final的，而且是<code>public static final</code>修饰，通过<code>接口名.属性</code>访问</li><li>接口不能继承类，但可以继承别的接口</li><li>接口的修饰符只能是public和默认，和类一样</li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类。内部类最大的特点是可以直接访问私有属性，并且可以直接体现类之间的包含关系。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>定义在外部类局部位置上，比如方法内：<ul><li>局部内部类（有类名）</li><li>匿名内部类（没有类名）<strong>重点！！！</strong></li></ul></li><li>定义在外部类的成员位置上：<ul><li>成员内部类</li><li>静态内部类（用static修饰）</li></ul></li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul><li>内部类可以直接访问外部类的所有成员，包括私有的；外部类先创建内部类的对象再进行调用，必须在作用域中</li><li><strong>不能添加访问修饰符，因为它的地位是一个局部变量</strong>，局部变量是不能使用修饰符的。但可以使用final修饰</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.this.成员</code>访问</li></ul><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>一个接口&#x2F;类的方法的某个实现方式在程序中<strong>只会执行一次</strong>，但为了使用它，我们需要创建它的实现类&#x2F;子类去实现重写。此时可以使用匿名内部类的方式，可以<strong>无需创建新的类，减少代码冗余</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new A()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;.cry();</span><br></pre></td></tr></table></figure><ul><li><p>匿名内部类既是一个类的定义，同时也是一个对象</p></li><li><p>可以访问外部类的所有成员，包括私有的</p></li><li><p><strong>不能添加修饰符，因为它的地位就是一个局部变量</strong></p></li><li><p>作用域：仅仅是在定义它的方法或代码块中</p></li><li><p>外部其他类不能访问匿名类</p></li><li><p>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.this.成员</code>访问</p></li><li><p>可以当作实参直接传递，简洁高效</p></li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul><li>定义在外部类的成员位置，并且<strong>没有static修饰</strong></li><li>可以直接使用外部类的所有成员，包括私有成员</li><li><strong>可以添加任意的访问修饰符，因为它的地位是一个成员</strong></li><li>作用域：和外部类的其他成员一样，为整个类体</li><li>外部其他类访问内部类<ul><li><code>外部类名.内部类名 对象名 = 外部类名.new 内部类名();</code></li><li>方法返回</li><li><code>new 外部类名().new 内部类();</code></li></ul></li></ul><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul><li><p>定义在外部类的成员位置，<strong>有static修饰</strong></p></li><li><p>可以访问外部类所有静态成员，不能访问非静态成员</p></li><li><p>可以添加任意修饰符</p></li><li><p>作用域：整个类体</p></li><li><p>外部其他类访问内部类</p><ul><li>通过类名直接访问，但要满足访问权限</li><li>方法</li></ul></li><li><p>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.成员</code>访问</p></li></ul><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul><li><p>使用<code>enum</code>代替<code>class</code>声明枚举类，就不能继承其他类了（因为隐式继承<code>Enum</code>类，<code>java</code>是单继承机制），但是可以继承接口</p></li><li><p>使用<code>enum</code>关键字开发一个枚举类时，默认会继承<code>Enum</code>类, 而且是一个final类</p></li><li><p>枚举简化为<code>枚举对象(参数列表)</code></p></li><li><p>使用无参构造器创建枚举对象，则实参和小括号都可以省略</p></li><li><p>当有多个枚举对象时，使用<code>,</code>分隔，最后一个<code>;</code>结尾</p></li><li><p>枚举对象必须放在枚举类首行</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color </span><br><span class="line">&#123; </span><br><span class="line">    RED, GREEN, BLUE; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解用来修饰解释包、类、方法、属性、构造器、局部变量等。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</p><ul><li><p><strong>@Override</strong>：限定某个方法，是重写某个父类方法，该注解只能用于方法</p></li><li><p><strong>@Deprecated</strong>：用于表示某个程序元素（类、方法等）已过时，即不推荐使用，但是仍然能使用</p></li><li><p><strong>@SuppressWarnings</strong>：抑制编译器警告</p></li></ul><p><strong>元注解</strong>：注解的注解</p><ul><li>Retention：指定注解的作用范围，三种SOURCE, CLASS, RUNTIME</li><li>Target：指定注解可以在哪些地方使用</li><li>Documented：指定注解是否会在javadoc体现</li><li>Inherited：子类会继承父类注解</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p>执行过程中发生的异常分为两大类</p><ol><li>Error(错误)：Java虚拟机无法解决的严重问题，如<code>JVM</code>系统内部错误、资源耗尽等。比如<code>StackOverflowError</code>和<code>OOM（out of memory)</code></li><li>Exception：其他因编程或偶然的外在因素导致的一般问题，可以使用针对性的代码处理，分为两大类：运行时异常和编译时异常。编译异常程序中必须处理，运行时异常程序中没有处理默认是<code>throws</code></li></ol></li><li><p>异常处理方式: <code>ctrl</code>+<code>alt</code>+<code>t</code>选择 或者 <code>alt</code>+<code>enter</code></p><ol><li><p><code>try-catch-finally</code>：捕获异常，自行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(EXception e)&#123;</span><br><span class="line"><span class="comment">//当异常发生时异常后面的代码不执行，直接进入catch，系统将异常封装成Exception对象e传递给catch，得到异常后程序员自己处理</span></span><br><span class="line"><span class="comment">//异常没有发生，catch不执行</span></span><br><span class="line"><span class="comment">//在实际开发中，通常将编译异常转换为允许异常抛出，调用者可以捕获或抛出 throw new RuntimeException(e);</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//不管代码是否有异常，finally都要执行</span></span><br><span class="line"><span class="comment">//通常将释放资源的代码放在finally，保证关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以有多个<code>catch</code>语句，捕获不同的异常，要求父类异常在后，子类异常在前，比如<code>Exception</code>在后，<code>NullPointException</code>在前，如果发生异常，只会匹配一个<code>catch</code></p><p>可以进行<code>try-finally</code>配合使用，相当于没有捕获异常，因此程序会直接奔溃。应用场景：执行一段代码不管是否发生异常都必须执行某个业务逻辑</p></li><li><p><code>throws</code>：将异常抛出，交给调用者处理，最顶级的处理者是<code>JVM</code></p><p>编译异常程序中必须处理，运行时异常程序中没有处理默认是<code>throws</code></p><p>子类重写父类的方法时，对抛出异常的规定：子类重写的方法抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类型</p><p>在<code>throws</code>过程中，如果有<code>try-catch</code>，相当于处理异常，就可以不必<code>throws</code></p></li></ol></li><li><p>自定义异常：<code>异常类名 extends Exception/RuntimeException</code>如果继承<code>Exception</code>，属于编译异常；如果继承<code>RuntimeException</code>，属于运行异常，一般继承<code>RuntimeException</code></p><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table></li></ul><h3 id="包装类（Wrapper类）"><a href="#包装类（Wrapper类）" class="headerlink" title="包装类（Wrapper类）"></a>包装类（Wrapper类）</h3><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><ul><li><p>jdk5之后自动装箱和拆箱，自动装箱底层调用的是<code>valueOf()</code>方法，</p><p>如果是在基本数据类型对应范围内就直接返回，否则返回 <code>new 包装类(xx)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"><span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">装箱: int -&gt; Integer</span><br><span class="line"> int m;</span><br><span class="line"> Interger n = m;</span><br><span class="line">拆箱: Integer -&gt; int</span><br><span class="line"> Integer n = new Integer(2);</span><br><span class="line"> int m = n;</span><br></pre></td></tr></table></figure></li><li><p>包装类和String</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">包装类 -&gt; String</span><br><span class="line">Integer i = 100;</span><br><span class="line">String s1 = i + &quot;&quot;;//方法一</span><br><span class="line">String s2 = i.toString();//方法二</span><br><span class="line">String s3 = String.valueOf(i);//方法三</span><br><span class="line"></span><br><span class="line">String -&gt; 包装类</span><br><span class="line">String s = &quot;123&quot;;</span><br><span class="line">Integer i1 = Integer.parseInt(s); //方法一，用到自动装箱</span><br><span class="line">Integer i2 = new Integer(s);//方法二，用到构造器</span><br></pre></td></tr></table></figure></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><p>String类是一个<strong>final类</strong>，实现了接口Serializable（可串行化：可以在网络传输）和Comparable（对象可以比较大小）</p></li><li><p>有属性<code>private final char value[]</code>, value赋值后<strong>不可以修改，指不能指向新的地址，但单个字符内容可以改变</strong></p></li><li><p>字符串使用Unicode编码，一个字符占两个字节</p></li><li><p>常见构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String();</span><br><span class="line">String s2 = new String(String s);</span><br><span class="line">String s3 = new String(char[] a);</span><br><span class="line">String s4 = new String(char[] a, int startindex, int count);</span><br></pre></td></tr></table></figure></li><li><p><strong>创建对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">String s1 = &quot;str&quot;;</span><br><span class="line">先从常量池查看是否有&quot;str&quot;数据空间，如果有直接指向；如果没有则重新创建然后指向。s1最终指向的是常量池的空间地址</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">String s2 = new String(&quot;str&quot;);</span><br><span class="line">先从堆中创建空间，里面维护了value属性，指向常量池的str空间。如果常量池没有&quot;str&quot;重新创建，如果有直接通过value指向。s2最终指向的是堆中的空间地址</span><br></pre></td></tr></table></figure></li><li><pre><code>String s1 = &quot;ab&quot; + &quot;cd&quot;;//常量相加: 编译器会优化，常量池中只有&quot;abcd&quot;, s1指向常量池中的&quot;abcd&quot;String a = &quot;ab&quot;;String b = &quot;cd&quot;;String s2 = a+b;//变量相加: s2指向堆再通过堆中value指向常量池中的&quot;abcd&quot;, 常量池中有”ab&quot;, &quot;cd&quot;, &quot;abcd&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 常用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>equals//区分大小写判断内容是否相等equalsIgnoreCase//忽略大小写判断内容是否相等length//字符串长度indexOf//获取字符串第一次出现的索引lastInedxOf//获取字符串最后一次出现的索引substring//截取指定范围子串trim//去前后空格charAt//获取某索引处的字符，注意不能用Str[idx]方式toUpperCase//转换为大写toLowerCase//小写concat//拼接replace//替换, 原串不影响, 返回结果才是替换过的split//分割字符串toCharArray//转换为字符数组compareTo//比较字符串大小format//格式转换<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### StringBuffer</span><br><span class="line"></span><br><span class="line">可变的字符序列，可以对字符串内容进行增删。很多方法和String相同，但是StringBuffer是可变长度的。StringBuffer是一个容器。</span><br><span class="line"></span><br><span class="line">* 对比String：</span><br><span class="line">  * String保存的是字符串常量，里面的值不能修改，每次String类更新实际上是修改地址，效率低。`//private final char value[];`</span><br><span class="line">  * StringBuffer保存的是字符串变量，里面的值可以修改，每次更新实际上更新的是内容，不用每次更新地址，效率高。`//char[] value; //放在堆中`</span><br><span class="line"></span><br><span class="line">* 转换</span><br><span class="line"></span><br></pre></td></tr></table></figure>Stirng -&gt; StringBuffer// 1. 使用构造器String str = &quot;hello&quot;;StringBuffer sb1 = new StringBuffer(str);// 2. 使用append方法StringBuffer sb = new StringBuffer();sb = sb.append(str);StringBuffer -&gt; String// 1. 使用StringBuffer提供的toString方法// 2. 使用构造器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 常用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>append//增delete(st,ed)//删除[st,ed)字符replace(st,ed,str)//替换indexOf//查找第一次出现的索引insert(idx,str)//插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### StringBuilder</span><br><span class="line"></span><br><span class="line">一个可变的字符序列，此类提供一个与StringBuffer兼容的API，但并不能保证同步（存在线程安全问题），用作StringBuffer的一个简易替换，**用在字符串缓冲区被单个线程使用的时候**，如果可能建议优先使用，因为**比StringBuffer快**。</span><br><span class="line"></span><br><span class="line">三者比较</span><br><span class="line"></span><br><span class="line">* StringBuffer和StringBuilder非常类似，均代表可变字符序列，而且方法也一样</span><br><span class="line">* String：不可变字符序列，效率低，但复用率高</span><br><span class="line">* StringBuffer：可变字符序列，效率较高（增删），线程安全</span><br><span class="line">* StringBuilder：可变字符序列，效率最高，线程不安全</span><br><span class="line">* 如果需要对String做大量的修改，不要使用String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Arrays</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>toString&#x2F;&#x2F;返回数组的字符串形式，显示数组<br>sort&#x2F;&#x2F;自然排序和定制排序<br>传入一个接口Comparator实现定制排序，要求实现匿名内部类Comparator的compare方法<br>Arrays.sort(arr, new Comparator<Integer>() {<br>    @Override<br>    public int compare(Integer o1, Integer o2) {<br>        return 0;&#x2F;&#x2F;自己实现<br>    }<br>});<br>binarySearch&#x2F;&#x2F;二分查找<br>copyOf&#x2F;&#x2F;数组元素的复制<br>fill&#x2F;&#x2F;元素填充<br>equals&#x2F;&#x2F;数组比较<br>asList&#x2F;&#x2F;将一组值转换为list集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### BigInteger 和 BigDecimal</span><br><span class="line"></span><br><span class="line">* BigInteger 适合保存比较大的整数；BigDecimal 适合保存精度更高的浮点数</span><br><span class="line">* 对其进行加减乘除运算时需要使用相应的方法，不能直接使用`+ - * /`</span><br><span class="line">* BigDecimal 进行`divide`运算时可能除不尽而抛出异常，指定精度即可，`BigDecimal.ROUND_CEILING`, 结果保留分子精度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 日期类</span><br><span class="line"></span><br><span class="line">#### 第一代日期类Date </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 获取当前时间，在java.util包，默认输出格式是国外格式，可以通过格式转换</span><br><span class="line">// 1. 创建SimpleDateFormat对象可以指定相应格式</span><br><span class="line">// 2. 格式是字母规定好的</span><br><span class="line">Date d = new Date();//获取当前时间</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年mm月dd日 hh:mm:ss E&quot;);</span><br><span class="line">String format = sdf.format(d);</span><br><span class="line">System.out.println(format);//2023年43月21日 07:43:11 周四</span><br><span class="line"></span><br><span class="line">// 把字符串转换为对应时间</span><br><span class="line">String s = &quot;2023年43月21日 07:43:11 周四&quot;;</span><br><span class="line">Date parse = sdf.parse(s);//Sat Jan 21 07:43:11 CST 2023</span><br></pre></td></tr></table></figure><h4 id="第二代日期类Calendar"><a href="#第二代日期类Calendar" class="headerlink" title="第二代日期类Calendar"></a>第二代日期类Calendar</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar 是一个抽象类，构造器是私有的，通过getInstance()获取实例，提供大量的方法和字段</span><br><span class="line">月份从0开始</span><br><span class="line">24小时制: Calendar.HOUR -&gt; Calendar.HOUR_OF_DAY</span><br><span class="line"></span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c.get(Calendar.YEAR));//2023</span><br></pre></td></tr></table></figure><h4 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h4><p>建议使用第三代日期类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalDate(日期)</span><br><span class="line">LocalTime(时间)</span><br><span class="line">LocalDateTime(时间日期)</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);//2023-09-21T20:39:47.018543</span><br><span class="line"></span><br><span class="line">使用DateTimeFormatter类格式化日期</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter dd = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh小时mm分钟ss秒&quot;);</span><br><span class="line">String s = dd.format(localDateTime);</span><br><span class="line">System.out.println(s);//2023年09月21日 08小时47分钟35秒</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>允许重复</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul><li><p>基本等同于Vector，效率高，但是线程不安全</p></li><li><p>ArrayList 中维护了一个Object类型的数组elementData <code>transient Object[] elementData;//transient表示属性不会被序列化</code></p></li><li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始的elementData容量为0，第一添加，则扩容为10，如需再次扩容则扩容为1.5倍</p></li><li><p>如果使用指定大小的构造器，初始容量为指定大小，如果需要扩容则扩容为1.5倍</p></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul><li><p><code>protected Object[] elementData;</code></p></li><li><p>线程同步的，即线程安全, 操作方法带 <code>synchronized</code></p></li></ul><table><thead><tr><th></th><th>底层结构</th><th>线程安全 效率</th><th>扩容机制</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>不安全，效率高</td><td>有参扩容1.5倍 <br>无参默认0，第一次扩容为10，后面扩容1.5倍</td></tr><tr><td>Vector</td><td>可变数组</td><td>安全，效率不高</td><td>有参扩容2倍<br>无参默认是10，后面扩容2倍</td></tr></tbody></table><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul><li>底层实现了双向链表和双端队列的特点</li><li>可以添加任意元素</li><li>线程不安全</li><li>LinkedList底层维护了一个双向链表，属性first和last分别指向首结点和尾结点</li></ul><table><thead><tr><th></th><th>底层结构</th><th>增删效率</th><th>改查效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高</td><td>较低</td></tr></tbody></table><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>不能存放重复元素，取出顺序和添加顺序不一致</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li><p>HashSet实际上是HashMap , HashMap底层是（数组+链表+红黑树）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第一次添加时，table数组扩容到16，临界值是16*loadFactor(0.75)=12, 如果table数组使用到了临界值，就会扩容2倍，依次类推</span><br><span class="line">1. 添加一个元素时，先得到hash值然后转换为索引值</span><br><span class="line">2. 找到存储数据的table，看索引位置是否有元素</span><br><span class="line">3. 如果没有，直接加入</span><br><span class="line">4. 如果有，调用equals比较，如果相同放弃添加，如果不同添加到最后。equals不能简单的认为是比较内容或是地址，程序员可以进行重写 </span><br><span class="line">5. 在java8中，如果一条链表的元素个数 &gt;= TREEIFY_THRESHOLD(默认8)，并且table大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)</span><br></pre></td></tr></table></figure></li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li><p>是HashSet的子类</p></li><li><p>底层是一个LinkedHashMap，底层维护了一个数组+双向链表</p></li><li><p>根据元素的hashCode值决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的</p></li><li><p>不允许元素重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次添加元素时，table数组扩容到16，数组是HashMap$Node[],存放的结点类型是LinkedHashMap$Entry</span><br></pre></td></tr></table></figure></li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li><p>底层是TreeMap</p></li><li><p>可以实现排序，构造器可以传入一个比较器（匿名内部类）对TreeSet进行排序</p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>存放具有映射关系的数据：key-value, 两者可以是任何引用类型的数据，会封装到HashMap$Node中，key不能重复（相同的key等价于替换）, value可以重复</p><ul><li><p>接口遍历方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containKey//键是否存在</span><br><span class="line">keySet//获取所有键</span><br><span class="line">entrySet//获取所有关系</span><br><span class="line">values//获取所有值</span><br></pre></td></tr></table></figure></li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul><li>键和值都不能为空</li><li>使用方法基本和HashMap一样</li><li>Hashtable是线程安全的，HashMap是线程不安全的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">底层数组Hashtable$Entry[] 初始化大小 11</span><br><span class="line">临界值 threshold = 8 (11*0.75)</span><br><span class="line">扩容机制</span><br></pre></td></tr></table></figure><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul><li><p>继承自Hashtable类并实现了Map接口，也是使用一种键值对的形式来保存数据</p></li><li><p>还可以用于从XXX.properties文件中加载数据到Properties类对象，并进行读取和修改，通常作为配置文件</p></li><li><p>常用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">load//加载配置文件的键值到对象</span><br><span class="line">list//将数据显示到指定设备</span><br><span class="line">getProperty(key)//根据键获取值</span><br><span class="line">setProperty(key,value)//设置键值对到对象</span><br><span class="line">store//将键值存储到配置文件，在IDEA中保存信息到配置文件，如果含有中文，会存储为unicode码</span><br></pre></td></tr></table></figure></li></ul><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><ul><li><p>是一个操作Set, List, Map的工具类</p></li><li><p>提供了一系列静态的方法对集合元素进行排序、查询、修改等操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)//反转</span><br><span class="line">shuffle(List)//随机排序</span><br><span class="line">sort(List)</span><br><span class="line">sort(List, Comparator)</span><br><span class="line">swap(int i, int j)//交换List集合中位置i和j的元素</span><br><span class="line">max/min(Collection)</span><br><span class="line">max/min(Collection, Comparator)</span><br><span class="line">frequency(Collection, Object)//返回集合中指定元素出现次数</span><br><span class="line">copy(List desc, List src)//src -&gt;desc</span><br><span class="line">replaceAll(List list, Object oldVal, Object newVal)</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型又称参数化类型，解决数据的安全性问题</p><ul><li><p>编译时，检查添加元素的类型，提高了安全性</p></li><li><p>减少了类型转换的次数，提高效率</p></li><li><p>可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值类型，或是参数类型</p></li><li><p>泛型指定数据类型时要求是引用类型，不能是基本数据类型</p></li><li><p>给泛型指定类型后，可以传入该类型或其子类类型</p></li><li><p>如果不指定泛型，默认是Object</p></li><li><p>泛型没有继承性 <code>List&lt;Object&gt; list = new ArrayList&lt;String&gt;();//错误</code></p></li></ul><p>自定义泛型类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class 类名&lt;T,R...&gt;&#123;//泛型标识符可以有多个，一般单个大写字母</span><br><span class="line">成员</span><br><span class="line">&#125;//自定义类后面有泛型, 就称为自定义泛型</span><br><span class="line"></span><br><span class="line">注意细节：</span><br><span class="line">普通成员可以使用泛型(属性, 方法)</span><br><span class="line">使用泛型的数组，不能初始化。例如不能：T[] t = new T[8]; //因为数组在new时不能确定T的类型无法在内存开辟空间。</span><br><span class="line">静态方法和属性中不能使用泛型。因为静态是和类相关的，类加载时对象还没有创建</span><br><span class="line">泛型类的类型，是在创建对象时确定的</span><br><span class="line">如果创建对象时没有指定类型，默认Object</span><br></pre></td></tr></table></figure><p>自定义泛型接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&lt;T,R...&gt;&#123;&#125;</span><br><span class="line">注意细节：</span><br><span class="line">接口中静态成员也不能使用泛型</span><br><span class="line">泛型接口的类型，是在继承接口或实现接口时确定的</span><br><span class="line">没有指定泛型默认Object</span><br></pre></td></tr></table></figure><p>自定义泛型方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,R..&gt; 返回类型 方法名（参数列表）&#123;&#125;</span><br><span class="line">注意细节：</span><br><span class="line">泛型方法可以定义在普通类中，也可以定义在泛型类中</span><br><span class="line">当泛型方法被调用时，类型会确定</span><br><span class="line">public void eat(E e)&#123;&#125;不是泛型方法，而是使用了泛型</span><br></pre></td></tr></table></figure><p>通配符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt;: 支持任意泛型类型</span><br><span class="line">&lt;? extends A&gt;: 支持A类和A类的子类，规定了泛型的上限</span><br><span class="line">&lt;? super A&gt;: 支持A类和A类的父类，不限于直接父类，规定了下限</span><br></pre></td></tr></table></figure><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p>java中线程使用的两种方法：</p><ol><li>继承Thread类，重写run方法。</li><li>实现Runnable接口，重写run方法</li></ol><p>两者本质上并没有什么区别，实现Runnable接口方式更适合多个线程共享一个资源的情况，并且避免了单继承的限制</p><ul><li><p>线程常用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setName</span><br><span class="line">getName</span><br><span class="line">start//使线程开始执行，java虚拟机调用该线程的start0方法</span><br><span class="line">run //调用线程对象run方法</span><br><span class="line">setPriority//设置优先级</span><br><span class="line">getPriority</span><br><span class="line">sleep//是静态方法，休眠</span><br><span class="line">interrupt//中断线程,并没有真正结束线程，一般用于中断正在休眠的线程</span><br><span class="line">yield//让出CPU让其他线程执行，但礼让的时间不确定，所以不一定成功</span><br><span class="line">join//线程的插队，肯定先执行</span><br></pre></td></tr></table></figure></li><li><p>用户线程：工作线程，当线程的任务执行完或通知方式结束</p></li><li><p>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。常见的守护线程：垃圾回收机制。通过<code>.setDaemon(true)</code>设置为守护线程</p></li><li><p>线程同步</p><ul><li><p>同步代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象)&#123;//得到对象的锁才能操作同步代码</span><br><span class="line">//需要同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void m(String name)&#123;</span><br><span class="line">//需要被同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象），默认锁对象为<code>this</code></p></li><li><p>同步方法（静态的）的锁为当前类本身，默认锁对象为：<code>当前类.class</code></p></li></ul></li><li><p>释放锁</p><ul><li>同步方法、代码执行结束</li><li>同步方法、代码遇到break, return </li><li>出现未处理的Error或Exception导致异常结束</li><li>执行了线程对象的wait()方法，当前线程暂停并释放锁</li><li>调用Thread.sleep(), Thread.yield()方法暂停当前线程的执行，不会释放锁</li></ul></li></ul><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>常用的文件操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new File(String path)</span><br><span class="line">new File(File parent, String path)//根据父目录文件+子路径</span><br><span class="line">new File(String parent, String child)//父目录+子路径</span><br><span class="line">createNewFile//创建文件</span><br><span class="line"></span><br><span class="line">mkdir创建一级目录，mkdirs创建多级目录，delete删除空目录或文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png"></p><h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><p>节点流可以从一个特定的数据源读取数据，如FileReader，FileWriter。处理流（包装流）是”连接”在已存在的流之上，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader, BufferedWriter。</p><p>区别和联系：</p><ul><li>节点流是底层流&#x2F;低级流，直接和数据源相接</li><li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出，例如BufferedReader中有Reader属性，可以封装任意流只要是Reader的子类</li><li>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li></ul><p>处理流的功能体现：</p><ul><li>性能的提高：主要以增加缓冲的方式提高输入输出的效率</li><li>操作的便捷：处理流可能提供一些便捷的方法来一次输入输出大量数据，使用更加灵活</li></ul><h4 id="序列化和反序列化-ObjectOutputStream-x2F-ObjectInputStream"><a href="#序列化和反序列化-ObjectOutputStream-x2F-ObjectInputStream" class="headerlink" title="序列化和反序列化 ObjectOutputStream&#x2F;ObjectInputStream"></a>序列化和反序列化 ObjectOutputStream&#x2F;ObjectInputStream</h4><p>序列化就是在保存数据时保存值和数据类型，<code>ObjectOutputStream</code>提供序列化；反序列化就是在恢复数据时恢复值和数据类型，<code>ObjectInputStream</code>提供反序列化。</p><p>需要让某个类支持序列化机制，则必须让类可序列化，必须实现两个接口之一：</p><ol><li><p><code>Serializable</code> &#x2F;&#x2F;标记接口，没有方法。推荐使用</p></li><li><p><code>Externalizable</code></p></li></ol><p>注意事项和细节：</p><ol><li>读写顺序一致</li><li>序列化或反序列化的对象需要实现<code>Serializable</code>接口</li><li>序列化的类中建议添加<code>SerialVersionUID</code>，为了提高版本兼容性</li><li>序列化对象时默认将里面所有属性都进行序列化，除了<code>static</code>和<code>transient</code>修饰的成员</li><li>序列化对象时，要求里面的属性的类型也需要实现序列化接口</li><li>序列化具有可继承性，如果某类实现了序列化，则它的所有子类也已经默认实现了序列化</li></ol><h4 id="转换流-InputStreamReader-x2F-OutputStreamReader"><a href="#转换流-InputStreamReader-x2F-OutputStreamReader" class="headerlink" title="转换流 InputStreamReader&#x2F;OutputStreamReader"></a>转换流 InputStreamReader&#x2F;OutputStreamReader</h4><p>InputStreamReader: Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）</p><p>OutputStreamReader: Writer的子类，可以将OutputStream（字节流）包装成Writer（字符流）</p><p>当处理纯文本数据时，使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换为字符流</p><p>可以在使用时指定编码格式</p><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p><code>netstat -an | more</code> ：分页显示主机网络情况</p><h4 id="TCP字节流编程"><a href="#TCP字节流编程" class="headerlink" title="TCP字节流编程"></a>TCP字节流编程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="comment">// 1.连接服务端(ip, 端口)</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line"><span class="comment">// 2.连接成功返回Socket对象</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">// 3.通过输出流写数据到数据通道</span></span><br><span class="line">outputStream.write(<span class="string">&quot;hello server&quot;</span>.getBytes());</span><br><span class="line">socket.shutdownOutput();<span class="comment">//设置结束标记。## 也可以改用Write.newLine()标记结束，对应的需要服务端使用readLine()读取数据##</span></span><br><span class="line"><span class="comment">// 4.关闭流</span></span><br><span class="line">outputStream.close();</span><br><span class="line">socket.close();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="comment">// 1.设置监听端口</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"><span class="comment">// 2.没有客户端连接端口时阻塞等待</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"><span class="comment">// 3.通过输入流获取数据</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="comment">// 4.IO读取b</span></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readline</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((readline = inputStream.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readline));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5.关闭流</span></span><br><span class="line">inputStream.close();</span><br><span class="line">socket.close();</span><br><span class="line">serverSocket.close();</span><br></pre></td></tr></table></figure><h4 id="TCP字符流编程"><a href="#TCP字符流编程" class="headerlink" title="TCP字符流编程"></a>TCP字符流编程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;hello server....&quot;</span>);</span><br><span class="line">bufferedWriter.flush();<span class="comment">//需要手动刷新，否则数据不会写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line"><span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readline</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((readline = bufferedReader.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readline));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>通过外部文件配置，在不修改源码的情况下来控制程序，也符合设计模式的ocp原则(开闭原则: 不修改源码，扩容功能)。</p><p>反射机制允许程序在执行期间借助于ReflectionAPI取得任何类的内部信息，并能操作对象的属性及方法。</p><p>加载完类之后，在堆中产生一个Class类型的对象（一个类只有一个Class对象），这个对象包含类的完整结构信息。</p><p>反射相关的主要类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class //代表一个类，Class对象表示某个类加载后在堆中的对象</span><br><span class="line">java.lang.reflect.Method//代表类方法</span><br><span class="line">java.lang.reflect.Field//代表类成员变量</span><br><span class="line">java.lang.reflect.Constructor//代表类构造方法</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p>​优点：可以动态的创建和使用对象（框架底层核心），使用灵活</p><p>​缺点：使用反射是解释执行，对执行速度有影响</p><p><strong>反射调用优化：关闭访问检查</strong></p><p>​Method和Field、Constructor对象都有setAccessible()方法，作用是启动和禁用访问安全检查，参数为true表示反射的对象在使用时取消访问检查，提高反射效率</p><p><strong>通过反射获取类结构信息</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getName:获取全类名</span><br><span class="line">getSimpleName:获取简单类名</span><br><span class="line">getFields:获取所有public属性，包含本类和父类</span><br><span class="line">getDeclaredFields:获取所有属性</span><br><span class="line">getMethods:获取所有public方法</span><br><span class="line">getDeclaredMethods:获取所有方法</span><br><span class="line">getModifiers:以int形式返回修饰符（默认修饰符是0，public是1，private是2，protected是4，static是8，final是16）</span><br><span class="line">getType:以Class形式返回类型</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>通过反射创建对象</strong></p><ol><li><p>调用类中的public修饰的无参构造器</p></li><li><p>调用类中的指定构造器</p></li><li><p>Class类相关方法：</p><p>newInstance: 调用类中的无参构造器，获取对应类的对象</p><p>getConstructor(Class.class, …): 根据参数列表获取对应构造器对象</p><p>getDecalaredConstructor(Class.class, …): 根据参数列表获取对应构造器对象</p></li><li><p>Constructor类相关方法</p><p>setAccessible: 爆破, 使用反射可以访问private构造器&#x2F;属性&#x2F;方法</p><p>newInstance(Object.object, …): 调用构造器</p></li></ol><p><strong>通过反射访问类中成员</strong></p><ol><li><p>根据属性名获取Field对象 &#x2F;&#x2F;getField获取public属性, getDeclaredField获取所有类型属性</p><p><code>Field f = clazz对象.getDeclaredField(属性名);//f即为对应属性</code></p></li><li><p>爆破：<code>f.setAccessible(true)</code></p></li><li><p>访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.set(object, 值);//object为对象</span><br><span class="line">f.get(object);</span><br><span class="line">//如果是静态属性，set和get中的参数object，可以写成null</span><br></pre></td></tr></table></figure></li></ol><p><strong>通过反射访问方法</strong></p><ol><li><p>根据方法名和参数列表获取Method方法对象</p><p><code>Method m = clazz对象.getDeclaredMethod(方法名, XX.class);</code></p></li><li><p>获取对象 ：<code>Object o = clazz.newInstance();</code></p></li><li><p>爆破：<code>m.setAccessible(true);</code> &#x2F;&#x2F;私有的需要爆破</p></li><li><p>访问：<code>Object returnValue = m.invoke(o, 实参列表); //如果是静态方法，o可以写成null</code></p></li></ol><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>Class类也是类，因此继承Object类</p><p>Class类对象不是new出来的，而是系统创建的</p><p>对于某个类的Class对象，在内存只有一份，因为类只加载一次</p><p>每个类的实例都会记得自己是由哪个Class实例所产生</p><p>通过Class对象可以完整的得到一个类的完整结构，通过一系列的API</p><p>Class对象存放在堆中</p><p>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码、变量名、方法名、访问权限等）</p><p><strong>获取Class对象的方法 :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 已知一个类的全类名，且在该类的路径下，可以通过Class类的静态方法forName()获取。</span></span><br><span class="line"><span class="comment">//  应用场景：多用于读取配置文件，读取类全路径加载类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Cat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 已知具体类，通过类的class获取，该方式最为安全可靠，性能最高</span></span><br><span class="line"><span class="comment">//  多用于参数传递，比如通过反射得到对应构造器对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Cat.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 已知某个类的实例，调用该实例的getClass()方法获取Class对象</span></span><br><span class="line"><span class="comment">//  通过创建好的对象获取Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> 对象.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 通过类加载器得到Class对象</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="comment">// 1) 先得到类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader();</span><br><span class="line"><span class="comment">// 2) 通过类加载器得到Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">aclass</span> <span class="operator">=</span> classLoader.loadClass(classAllPath);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><p>静态加载：编译时加载相关类，如果没有则报错，依赖性太强</p><p>动态加载：运行时加载需要的类，如果运行时没有用到该类则不会报错，降低了依赖性</p><p><strong>类加载时机：</strong></p><ol><li>创建对象时 &#x2F;&#x2F;静态加载</li><li>当子类被加载时  &#x2F;&#x2F;静态加载</li><li>调用该类的静态成员时 &#x2F;&#x2F;静态加载</li><li>通过反射  &#x2F;&#x2F; 动态加载</li></ol><p><strong>类加载阶段：（加载-&gt;连接（验证，准备，解析）-&gt;初始化）</strong></p><ol><li><p>加载阶段：将字节码从不同数据源转化为二进制字节流加载到内存中，并生成一个代表该类的Class对象</p></li><li><p>连接-验证：确保Class文件的字节流中包含的信息符合当前虚拟机要求并且不会危害虚拟机安全。可以考虑使用<code>-Xverify:none</code>参数来关闭大部分类验证措施，缩短类加载时间</p><p>连接-准备：JVM对静态变量分配内存并默认初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int n1 = 10;//不是静态变量，准备阶段不是分配内存</span><br><span class="line">public static int n2 = 20;//是静态变量分配内存，默认初始化是0，而不是20</span><br><span class="line">public static final int n3 = 30;//是static final常量，一旦赋值就不变，初始化为30</span><br></pre></td></tr></table></figure><p>连接-解析：虚拟机将常量池的符号引用替换为直接引用的过程</p></li><li><p>初始化：才真正开始执行程序代码，依次收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并</p></li></ol><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>命令行连接数据库：<code>mysql -h 主机ip -P 端口 -u 用户名 -p[密码]</code></p><p>备份数据库(在DOS执行)：<code>mysqldump -u 用户名 -p -B 数据库1 数据库2 &gt; 文件名.sql</code></p><p>备份数据库表(在DOS执行)：<code>mysqldump -u 用户名 -p 表1 表2 &gt; 文件名.sql</code></p><p>恢复数据库（mysql命令行执行）：<code>Source 文件名.sql</code></p><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><ul><li><p>添加列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">ADD(column datatype...);</span><br></pre></td></tr></table></figure></li><li><p>修改列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">MODIFY(column datatype...);</span><br></pre></td></tr></table></figure></li><li><p>删除列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">DROP(column);</span><br></pre></td></tr></table></figure></li><li><p>查看表结构：<code>desc 表名</code></p></li><li><p>修改表名：<code>rename table 表名 to 新表名</code></p></li><li><p>修改表字符集：<code>alter table 表名 character set 字符集</code></p></li><li><p>修改列名：<code>alter table tablename change 原列名 新列名 datatype</code></p></li></ul><h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><ul><li><p>insert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tablename[column...]</span><br><span class="line">VALUES(value...);</span><br></pre></td></tr></table></figure></li><li><p>update</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tablename</span><br><span class="line">SET column=expr,...</span><br><span class="line">[WHERE ...];</span><br></pre></td></tr></table></figure></li><li><p>delete</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM tablename</span><br><span class="line">[WHERE ...];</span><br></pre></td></tr></table></figure></li><li><p>select</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT [DISTINCT] column as name,...</span><br><span class="line">FROM tablename;</span><br><span class="line">GROUP BY column HAVING ...</span><br></pre></td></tr></table></figure><p>分页查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ...limit start,rows//表示从start+1开始取，取出rows行，start从0开始</span><br></pre></td></tr></table></figure><p><strong>select语句中顺序：group by, having, order by, limit</strong></p></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h5><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>CHARSET(str)</td><td>返回字串字符集</td></tr><tr><td>CONCAT(string1, […])</td><td>连接字符串</td></tr><tr><td>INSTR(string, substring)</td><td>返回子串位置，没有返回0</td></tr><tr><td>UCASE(string)</td><td>转换大写</td></tr><tr><td>LCASE(string)</td><td>转换小写</td></tr><tr><td>LEFT(string，length)</td><td>左边起取length个字符</td></tr><tr><td>LENGTH(string)</td><td>string长度[按照字节]</td></tr><tr><td>REPLACE(str, search_str, replace_str)</td><td>在str中用replace_str替换search_str</td></tr><tr><td>STRCMP(string1, string2)</td><td>比较字符串</td></tr><tr><td>SUBSTRING(str, position [, length])</td><td>从str的position(从1开始)开始取length个字符</td></tr><tr><td>LTRIM(string), RTRIM(string), TRIM(string)</td><td>去前端空格，后端空格，前后端空格</td></tr></tbody></table><h5 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h5><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>abs(num)</td><td>绝对值</td></tr><tr><td>bin(num)</td><td>十进制转二进制</td></tr><tr><td>CEILING(num)</td><td>向上取整</td></tr><tr><td>CONV(num, from_base, to_base)</td><td>进制转换</td></tr><tr><td>FLOOR(num)</td><td>向下取整</td></tr><tr><td>FORMAT(num，decimal_places)</td><td>保留小数位数</td></tr><tr><td>HEX(num)</td><td>转十六进制</td></tr><tr><td>LEAST(num1, …)</td><td>最小值</td></tr><tr><td>MOD(num, denominator)</td><td>取余</td></tr><tr><td>RAND([seed])</td><td>随即数 [0-1], seed是随机种子</td></tr></tbody></table><h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>CURRENT_DATE()</td><td>当前日期</td></tr><tr><td>CURRENT_TIME()</td><td></td></tr><tr><td>CURRENT_TIMESTAMP()</td><td></td></tr><tr><td>DATE&#x2F;YEAR&#x2F;MONTH&#x2F;DAY(datetime)</td><td>返回datetime的日期部分&#x2F;年&#x2F;月&#x2F;日</td></tr><tr><td>DATE_ADD(date, INTERVAL d_value d_type)</td><td>date说加上时间或日期，d_type可以是year, day, minute,hour等</td></tr><tr><td>DATE_SUB(date, INTERVAL d_value d_type)</td><td>减</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>日期差（结果是天）</td></tr><tr><td>TIMEDIFF(date1, date2)</td><td>时间差</td></tr><tr><td>NOW()</td><td>当前时间</td></tr></tbody></table><h5 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>USER()</td><td>查询用户</td></tr><tr><td>DATABASE()</td><td>当前数据库</td></tr><tr><td>MD5(str)</td><td>对字符串加密</td></tr><tr><td>PASSWORD(str)</td><td>加密函数</td></tr></tbody></table><h5 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>IF(expr1, expr2, expr3)</td><td>expr1为true则返回expr2，否则返回expr3</td></tr><tr><td>IFNULL(expr1, expr2)</td><td>expr1不为空返回expr1，否则返回expr2</td></tr><tr><td>SELECT CASE<br>     WHEN expr1 THEN expr2<br>     WHEN expr3 THEN expr4<br>     ELSE expr5<br>END</td><td>多重分支</td></tr></tbody></table><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><h5 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h5><ol><li>外键指向的表的字段要求是primary key或者unique</li><li>表的类型是innodb才支持外键</li><li>外键字段类型和主键字段类型一致</li><li>外键字段的值，必须在主键字段中出现过，或者为null [前提是外键字段允许为空]</li><li>一旦建立外键关系，数据就不能随意删除了</li></ol><h5 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字段名 整型 primary key auto_increment</span><br><span class="line">添加自增长的字段方式：</span><br><span class="line">insert into xxx values(null, value...);</span><br><span class="line">insert into xxx (字段1...字段n) values(null, value...);</span><br><span class="line">insert into xxx (字段2...字段n) values(value...);</span><br></pre></td></tr></table></figure><ul><li>一般和primary key配合使用</li><li>也可以单独使用，但要配合一个unique</li><li>自增长修饰的字段为整型（可以是小数但是很少使用）</li><li>自增长默认从1开始，可以修改<code>alter table 表名 auto_increment = x;</code></li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//添加索引</span><br><span class="line">create [unique] index idx_name on table_name(column);</span><br><span class="line">alter table table_name add index idx_name(column);</span><br><span class="line"></span><br><span class="line">//删除索引</span><br><span class="line">drop index idx_name on table_name;</span><br><span class="line">//删除主键索引</span><br><span class="line">alter table table_name drop primary key;</span><br><span class="line"></span><br><span class="line">//查询索引</span><br><span class="line">show index from table_name</span><br></pre></td></tr></table></figure><ul><li>频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合创建索引</li><li>不会出现在where语句的字段不该创建索引</li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>事务操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 开启事务</span><br><span class="line">START TRANSACTION</span><br><span class="line">set autocommit=off</span><br><span class="line">// 设置保存点</span><br><span class="line">SAVEPOINT point_name</span><br><span class="line">// 回退</span><br><span class="line">ROLLBACK TO point_name</span><br><span class="line">// 回退全部事务</span><br><span class="line">ROLLBACK</span><br><span class="line">// 提交事务，提交后不能回退</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p><strong>InnoDB 存储引擎支持事务，MyISAM 不支持</strong></p><p><strong>隔离级别</strong></p><p>脏读：当一个事务读取另一个事务尚未提交的修改时</p><p>不可重复读：同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>修改或删除</strong>，每次返回不同结果集</p><p>幻读：同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>插入</strong>，每次返回不同结果集</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>读未提交(read uncommitted)</td><td>√</td><td>√</td><td>√</td><td>不加锁</td></tr><tr><td>读已提交(read committed)</td><td>x</td><td>√</td><td>√</td><td>不加锁</td></tr><tr><td>可重复读(repeatable read)</td><td>x</td><td>x</td><td>√</td><td>不加锁</td></tr><tr><td>可串行化(serializable)</td><td>x</td><td>x</td><td>x</td><td>加锁</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 查看当前会话隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">// 查看系统当前隔离级别</span><br><span class="line">select @@global.tx_isolation;</span><br><span class="line">// 设置当前会话隔离级别</span><br><span class="line">set session transaction isolation level repeatable read ...;</span><br><span class="line">// 设置系统当前隔离级别</span><br><span class="line">set global transaction isolation level repeatable read ...;</span><br><span class="line">mysql默认的事务隔离级别是repeatable read</span><br></pre></td></tr></table></figure><h4 id="表类型和存储引擎"><a href="#表类型和存储引擎" class="headerlink" title="表类型和存储引擎"></a>表类型和存储引擎</h4><p>mysql表类型由存储引擎决定，主要包括MyISAM, innoDB, Memory等</p><p>mysql数据表主要支持六种类型，分别是CSV, Memory, ARCHIVE, MRG_MYISAM, MYISAM,InnoDB。这六种又分为两类，一类是事务安全型，比如InnoDB；其余属于第二类，为非事务安全型</p><table><thead><tr><th>特点</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th><th>Archive</th></tr></thead><tbody><tr><td>批量插入速度</td><td>高</td><td>低</td><td>高</td><td>非常高</td></tr><tr><td>事务安全</td><td></td><td>√</td><td></td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>行锁</td><td>表锁</td><td>行锁</td></tr><tr><td>存储限制</td><td>没有</td><td>64TB</td><td>有</td><td>没有</td></tr><tr><td>支持外键</td><td></td><td>√</td><td></td><td></td></tr></tbody></table><ul><li>如果不需要事务，处理的只是基本的CRUD操作，那么MyISAM是不二选择，速度快</li><li>需要事务就使用InnoDB</li><li>Memory存储引擎就是将数据存储在内存中，由于没有磁盘I&#x2F;O的等待，速度极快。但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失</li></ul><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>视图是一个虚拟表，其内容由查询定义，<strong>数据来自对应的真实的表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create view view_name as select语句</span><br><span class="line">alter view view_name as select语句</span><br><span class="line">show create view view_name</span><br><span class="line">drop view view_name</span><br></pre></td></tr></table></figure><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建用户 user_name是用户名, localhost表示本地地址, password是password()加密后的密码</span><br><span class="line">// 不指定登录地址，则为%，表示所有IP都有连接权限</span><br><span class="line">create user &#x27;user_name&#x27;@&#x27;localhost&#x27; identified by &#x27;password&#x27;; </span><br><span class="line">// 删除用户</span><br><span class="line">drop user &#x27;user_name&#x27;@&#x27;localhost&#x27;</span><br></pre></td></tr></table></figure><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 授权</span><br><span class="line">grant 权限列表 on 库.对象名 to &#x27;user_name&#x27;@&#x27;localhost&#x27; [identified by &#x27;password&#x27;];</span><br><span class="line">grant all on ...//表示赋予该用户在该对象上的所有权限</span><br><span class="line"></span><br><span class="line">*.*: 表示本系统中的所有数据库的所有对象</span><br><span class="line">库.*: 表示某个数据库中的所有对象</span><br><span class="line">identified by 写上如果用户存在则修改密码，不存在会创建用户</span><br><span class="line"></span><br><span class="line">// 回收权限</span><br><span class="line">revoke 权限列表 on 库.对象名 from &#x27;user_name&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>Java提供一套用于数据库操作的接口</p><p>编写JDBC程序步骤：</p><ol><li><p>注册驱动</p></li><li><p>获取连接</p></li><li><p>执行增删改查</p><p>Statement对象，用于执行静态SQL语句并返回生成的结果的对象</p><p>在连接建立后，需要对数据进行访问，执行命名或是SQL语句，可以通过：</p><ul><li>Statement[存在SQL注入]</li><li>PrepareStatement  [预处理]</li><li>CallableStatement  [存储过程]</li></ul><p>使用PrepareStatement替代Statement解决SQL注入问题：</p><ol><li>PrepareStatement执行的sql语句中的参数用<code>?</code>来表示，调用setXxx()方法来设置这些参数</li><li>调用executeQuery(), 返回ResultSet对象</li><li>调用executeUpdate(), 执行更新，包括增删改</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 执行sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from admin where user=? and password=?&quot;</span>;</span><br><span class="line"><span class="type">PrepareStatement</span> <span class="variable">preparestatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">preparestatement.setString(<span class="number">1</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">preparestatement.setString(<span class="number">2</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//如果执行的是select语句，使用executeQuery</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultset</span> <span class="operator">=</span> preparestatement.executeQuery(); </span><br><span class="line"><span class="comment">// int rows = statement.executeUpdate();//如果是dml语句用executeUpdate(),返回的是影响行数</span></span><br></pre></td></tr></table></figure></li><li><p>释放资源</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置工作：将mysql-connector-j-8.1.0.jar文件拷贝到目录下，add to project 加入到项目中</span></span><br><span class="line"><span class="comment">// 1. 注册驱动</span></span><br><span class="line"><span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 得到连接(本质是Socket连接) &#x27;jdbc:mysql://&#x27; 表示协议; &#x27;localhost&#x27; 表示主机，可以是IP地址; &#x27;3306&#x27;表示端口号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306//数据库&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> driver.connect(url,properties);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into actor values()&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();<span class="comment">//执行sql语句，返回生成结果的对象</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> statement.executeUpdate(sql);<span class="comment">//如果是dml语句返回的是影响行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 释放资源</span></span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接方式2</span></span><br><span class="line"><span class="comment">//使用反射加载Driver类，动态加载，更加灵活，减少依赖性</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver)aClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306//数据库&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url,properties);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接方式3</span></span><br><span class="line"><span class="comment">//使用DriverManager 替代 Driver 进行统一管理</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver)aClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306//数据库&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">DriverManager.registerDriver(driver);<span class="comment">//注册驱动</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式4, 使用最多, 推荐使用</span></span><br><span class="line"><span class="comment">//使用反射加载了Driver类，自动完成注册驱动，简化代码</span></span><br><span class="line"><span class="comment">//因为静态代码块在类加载时会执行一次</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static &#123;</span></span><br><span class="line"><span class="comment">try &#123;</span></span><br><span class="line"><span class="comment">DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">catch(...)&#123;</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306//数据库&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式5</span></span><br><span class="line"><span class="comment">//方式4基础上使用Properties配置文件，让连接更加灵活</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path));</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class.forName(driver);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure><p><strong>事务</strong></p><p>JDBC程序中当一个Connection对象创建时，默认情况下自动提交事务：每次执行一个SQL语句时，如果执行成功就会向数据库自动提交，不能回滚</p><p>程序中为了让多个SQL语句作为一个整体执行，需要使用事务</p><p>调用Connection的 <code>setAutoCommit(false)</code> 可以取消自动提交事务</p><p>所有语句执行成功后调用Connection的 <code>commit()</code> 提交事务</p><p>在其中某个操作失败或异常时，调用 <code>rollback()</code> 回滚事务</p><p><strong>批处理</strong></p><p>JDBC连接MySQL时如果要使用批处理，需要在url中加参数 <code>?rewriteBatchedStatements=true</code></p><p>批处理往往和PrepareStatement搭配使用，可以减少编译次数和允许次数，提高效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addBatch():添加需要批量处理的SQL语句或参数</span><br><span class="line">executeBatch():执行批量处理语句</span><br><span class="line">clearBatch():清空批处理语句</span><br></pre></td></tr></table></figure><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p><strong>数据库连接池种类</strong></p><ol><li>JDBC数据库连接池使用javax.sql.DataSource来表示，是一个接口，由第三方实现</li><li><strong>C3P0 数据库连接池</strong>，速度相对较慢，稳定性不错</li><li>DBCP 数据库连接池，相对C3P0较快，不稳定</li><li>Proxool 数据库连接池，有监控连接池状态功能，稳定性较C3P0差一点</li><li>BoneCP 数据库连接池，速度快</li><li><strong>Druid（德鲁伊）数据库连接池</strong>，集2.3.4优点于一身</li></ol><p><strong>Druid使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 加入 Druid jar包</span></span><br><span class="line"><span class="comment">// 2. 加入 配置文件 druid.properties ,将该文件拷贝到src目录</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    # druid.properties文件的配置</span></span><br><span class="line"><span class="comment">    driverClassName=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">    url=jdbc:mysql://127.0.0.1:3306/数据库?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="comment">    username=root</span></span><br><span class="line"><span class="comment">    password=123456</span></span><br><span class="line"><span class="comment">    # 初始化连接数量</span></span><br><span class="line"><span class="comment">    initialSize=5</span></span><br><span class="line"><span class="comment">    # 最大连接数</span></span><br><span class="line"><span class="comment">    maxActive=10</span></span><br><span class="line"><span class="comment">    # 最大超时时间</span></span><br><span class="line"><span class="comment">    maxWait=3000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 3. 创建Properties对象，读取配置文件</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建数据库连接池</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭连接。不是真正断开, 而是将使用的连接对象放回连接池</span></span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p>**Apache-DBUtils **</p><p>commons-dbutils 是Apache提供的一个开源的JDBC工具类，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量</p><p>QueryRunner类：封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理</p><p>ResultSetHandler接口：用于处理java.sql.ResultSet, 将数据按要求转换为另一种形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayHandler：把结果集中的第一行数据转成对象数组。</span><br><span class="line">ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</span><br><span class="line">BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</span><br><span class="line">BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</span><br><span class="line">ColumnListHandler：将结果集中某一列的数据存放到List中。</span><br><span class="line">KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</span><br><span class="line">MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</span><br><span class="line">MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List</span><br><span class="line">ScalarHandler：对于查询后只有1个结果</span><br></pre></td></tr></table></figure><p>使用步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使用druid得到连接</span><br><span class="line">// 2. 引入DBUtils相关的jar包</span><br><span class="line">// 3. 创建QueryRunner类</span><br><span class="line">QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">// 4. 调用相关方法，返回ArrayList结果集</span><br><span class="line">connection: 连接</span><br><span class="line">sql: sql语句</span><br><span class="line">1: 给sql语句中的 ? 赋值。是可变形参</span><br><span class="line">new BeanListHandler&lt;&gt;(Actor.class): 使用反射机制获取Actor属性进行封装 ResultSet -&gt; Actor对象 -&gt; ArrayList</span><br><span class="line">String sql = &quot;select * from actor while id = ?&quot;;</span><br><span class="line">List&lt;Actor&gt; list = queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(Actor.class),1);</span><br><span class="line">// dml</span><br><span class="line">int rows = queryRunner.update(connection, sql, &quot;smith&quot;, 1);</span><br></pre></td></tr></table></figure><p><strong>BasicDao</strong></p><p>DAO: data access object 数据访问对象</p><p>这样的通用类，称为BasicDao，是专门和数据库交互的，即完成数据库crud操作</p><p>在BasicDao基础上，实现一张表对应一个Dao，更好的完成功能</p><p><img src="https://img-blog.csdnimg.cn/21c72bcb1b674325864b53b730bfa85e.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在dao包下分别建立domain, dao, utils, test四个子包，它们的功能如下——</span><br><span class="line">dao_ex.domain : 用于存放相关JavaBean类；</span><br><span class="line">dao_ex.dao : 用于存放XxxDAO 和 BasicDAO；</span><br><span class="line">dao_ex.utils : 用于存放相关工具类；</span><br><span class="line">dao_ex.test : 用于存放DAO的测试类。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开发BasicDAO,是其他DAO的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicDAO</span>&lt;T&gt; &#123;<span class="comment">//泛型指定具体的类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">QueryRunner</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开发通用的DML方法，针对任意的表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> qr.update(connection, sql, parameters);</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常，抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回多个对象(即查询的结果是多行)，针对任意表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql        sql语句可以有?号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz      传入一个类的Class对象 比如Actor.class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters 传入? 的具体的值，可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根据Actor.class 返回对应的ArrayList集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">queryMulti</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常，抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行结果的通用方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">querySingle</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常，抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行单列的方法，即返回单值的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryScalar</span><span class="params">(String sql, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>(), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常，抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Actor对象 和 actor表的记录对应</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Actor</span> &#123;<span class="comment">//JavaBean ,POJO,Domain对象</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Date borndate;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Actor</span><span class="params">()</span> &#123;<span class="comment">//一定要给一个无参构造器[反射需要]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Actor</span><span class="params">(Integer id, String name, String sex, Date borndate, String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.borndate = borndate;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getBorndate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> borndate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBorndate</span><span class="params">(Date borndate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.borndate = borndate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Actor&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, borndate=&quot;</span> + borndate +</span><br><span class="line">                <span class="string">&quot;, phone=&#x27;&quot;</span> + phone + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDAO</span> &#123;</span><br><span class="line">    <span class="comment">//测试ActorDAO 对Actor表的crud操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testActorDAO</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ActorDAO</span> <span class="variable">actorDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActorDAO</span>();</span><br><span class="line">        <span class="comment">//1.查询多行记录</span></span><br><span class="line">        List&lt;Actor&gt; actors = actorDAO.queryMulti(<span class="string">&quot;SELECT * FROM actor WHERE id &gt;= ?&quot;</span>, Actor.class, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===查询结果===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Actor actor : actors) &#123;</span><br><span class="line">            System.out.println(actor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询单行记录</span></span><br><span class="line">        <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> actorDAO.querySingle(<span class="string">&quot;SELECT * FROM actor WHERE id = ?&quot;</span>, Actor.class, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===查询单行结果===&quot;</span>);</span><br><span class="line">        System.out.println(actor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询单行单例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> actorDAO.queryScalar(<span class="string">&quot;SELECT name FROM actor WHERE id = ?&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===查询单行单列===&quot;</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DML操作 (insert,delete,update)</span></span><br><span class="line"><span class="comment">//        int affectedRows = actorDAO.update(&quot;UPDATE actor SET NAME=? WHERE id = ?&quot;, &quot;林青霞&quot;, 2);</span></span><br><span class="line"><span class="comment">//        int affectedRows = actorDAO.update(&quot;INSERT INTO actor VALUES(NULL,?,?,?,?)&quot;, &quot;许三多&quot;, &quot;男&quot;,&quot;1999-01-01&quot;,&quot;123456&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> actorDAO.update(<span class="string">&quot;DELETE FROM actor WHERE id = ?&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(affectedRows &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行没有影响表&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. \\d表示任意一个数字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regexp</span> <span class="operator">=</span> <span class="string">&quot;\\d\\d\\d\\d&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建模式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regexp,Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建匹配器</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 开始匹配</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* matcher.find() 完成的任务</span></span><br><span class="line"><span class="comment">* 1. 根据指定规则，定位满足规则的子字符串</span></span><br><span class="line"><span class="comment">* 2. 找到后将子字符串的开始索引记录到 matcher 对象的属性 int[] groups;</span></span><br><span class="line"><span class="comment">*    groups[0]记录开始索引, 把结束索引+1的值记录到 groups[1]中</span></span><br><span class="line"><span class="comment">* 3. 同时记录 oldLast 的值为：子字符串结束索引+1的值. 下次执行 find() 从此开始匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 考虑分组 正则表达式中含小括号即表示分组: String regexp = &quot;(\\d\\d)(\\d\\d)&quot;;</span></span><br><span class="line"><span class="comment">* groups[0]记录开始索引, 把结束索引+1的值记录到 groups[1]中</span></span><br><span class="line"><span class="comment">* groups[2]记录第一组开始索引, groups[3]记录第一组结束索引+1的值</span></span><br><span class="line"><span class="comment">* 依次类推...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* public String group(int group) &#123;</span></span><br><span class="line"><span class="comment">*    checkMatch();</span></span><br><span class="line"><span class="comment">*    checkGroup(group);</span></span><br><span class="line"><span class="comment">*    if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span></span><br><span class="line"><span class="comment">*        return null;</span></span><br><span class="line"><span class="comment">*    return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">System.out.println(matcher.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转义：\\在java的正则表达式中\\代表其他语言中的一个\</span><br><span class="line">  需要用到转义符号的字符：., *, +, (, ), /, \, ?, [, ], ^, &#123;, &#125;</span><br></pre></td></tr></table></figure><p><strong>匹配符</strong></p><table><thead><tr><th>符号</th><th>意义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>[]</td><td>可接收的字符列表</td><td>[efgh]</td><td>efgh中的任意字符</td></tr><tr><td>[^]</td><td>不可接收的字符列表</td><td>[^abc]</td><td>abc除外的任意字符</td></tr><tr><td>-</td><td>连字符</td><td>A-Z</td><td>任意大写字母</td></tr><tr><td>.</td><td>匹配除\n之外的任何字符</td><td>a..b</td><td>a开头b结尾中间任意两个字符的字符串</td></tr><tr><td>\\d</td><td>匹配单个数字字符，相当于[0-9]</td><td>\\d{3}(\\d)?</td><td>包含3个或4个数字的字符串</td></tr><tr><td>\\D</td><td>匹配单个非数字字符</td><td>\\D(\\d)*</td><td>以单个非数字字符开头，后接任意个数字字符的字符串</td></tr><tr><td>\\w</td><td>匹配单个数字、大小写字母字符、下划线<br>相当于[0-9a-zA-Z]</td><td>\\d{3}\\w{4}</td><td>以3个数字字符开头长度为7的数字字符串</td></tr><tr><td>\\W</td><td>匹配单个非数字、大小写字母字符、下划线<br/>相当于[ ^0-9a-zA-Z]</td><td>\\W+\\d{2}</td><td>以至少1个非数字字母字符开头，2个数字字符结尾的字符串</td></tr><tr><td>\\s</td><td>匹配任何空白字符（空格、制表符等）</td><td></td><td></td></tr><tr><td>\\S</td><td>匹配任何非空白字符</td><td></td><td></td></tr><tr><td><strong>选择匹配符</strong></td><td></td><td></td><td></td></tr><tr><td>|</td><td>选择匹配符,匹配之前或之后的</td><td>ab|cd</td><td>ab或cd</td></tr><tr><td><strong>限定符</strong></td><td></td><td></td><td></td></tr><tr><td>*</td><td>指定字符重复0次或n次</td><td>(abc)*</td><td>包含任意个abc的字符串</td></tr><tr><td>+</td><td>指定字符重复1次或n次</td><td>m+(abc)*</td><td>以至少1个m开头，后接任意个abc的字符串</td></tr><tr><td>？</td><td>指定字符重复0次或1次</td><td>m+abc?</td><td>以m开头，后接ab或abc的字符串</td></tr><tr><td>{n}</td><td>只能输入n个字符</td><td>[abcd]{3}</td><td>由abcd中字母组成的任意长度为3的字符串</td></tr><tr><td>{n, }</td><td>指定至少n个匹配</td><td>[abcd]{3, }</td><td>由abcd中字母组成的任意长度至少为3的字符串</td></tr><tr><td>{n, m}</td><td>指定至少n个但不多于m个匹配，尽可能匹配多的（贪婪匹配）</td><td>[abcd]{3, 5}</td><td>由abcd中字母组成的任意长度至少为3但不大于5的字符串</td></tr><tr><td>？</td><td>非贪婪匹配，限定符后加 ？</td><td>\\d+?</td><td>至少一个数字字符的字符串，尽可能匹配少的</td></tr><tr><td><strong>定位符</strong></td><td></td><td></td><td></td></tr><tr><td>^</td><td>指定起始字符</td><td>^[0-9]+[a-z]*</td><td>以至少1个数字开头，后接任意个小写字母的字符串</td></tr><tr><td>$</td><td>指定结束字符</td><td>^[0-9]\\-[a-z]+$</td><td>以1个数字开头后接’-‘，并以至少一个小写字母结尾的字符串</td></tr><tr><td>\\b</td><td>匹配目标字符串的边界</td><td>han\\b</td><td>边界指子串间有空格或是目标字符串的结束位置</td></tr><tr><td>\\B</td><td>匹配目标字符串的非边界</td><td>han\\B</td><td></td></tr></tbody></table><p><strong>java正则表达式默认区分大小写，实现不区分大小写：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.</span><br><span class="line">(?i)abc表示abc都不区分大小写</span><br><span class="line">a(?i)bc表示bc不区分大小写</span><br><span class="line">a((?i)b)c表示b不区分大小写</span><br><span class="line"></span><br><span class="line">// 2.</span><br><span class="line">Pattern pattern = Pattern.compile(regexp,Pattern.CASE_INSENSITIVE);</span><br></pre></td></tr></table></figure><p><strong>分组</strong></p><table><thead><tr><th>常用分组构造形式</th><th>说明</th></tr></thead><tbody><tr><td>(pattern)</td><td>非命名捕获。捕获匹配的子字符串，编号为0的第一个捕获是整个正则表达式模式匹配的文本，其他捕获结果根据左括号的顺序从1开始自动编号</td></tr><tr><td>(?&lt;name&gt;pattern)</td><td>命名捕获。将匹配子字符串捕获到一个组名称过编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头，可以使用单引号替代尖括号，例如 ?’name’</td></tr><tr><td>(?:pattern)</td><td>匹配但是不捕获子字符串，是一个非捕获匹配，不存储供以后使用的匹配。这对于用or字符(|)组合模式部件的情况很有用。例如 ‘industr(?:y|ies)’ 是比 ‘industry|industries’ 更经济的表达式</td></tr><tr><td>(?&#x3D;pattern)</td><td>非捕获匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配 “Windows 2000” 中的 “Windows”，但是不匹配 “Windows 3.1” 中的 “Windows”</td></tr><tr><td>(?!pattern)</td><td>非捕获匹配。例如，’Windows (!&#x3D;95|98|NT|2000’ 匹配 “Windows 3.1” 中的”Windows”, 但是不匹配”Windows 2000” 中的”Windows”</td></tr></tbody></table><p><strong>反向引用</strong></p><p>圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以是正则表达式内部，也可以是在正则表达式外部，内部反向引用<code>\\分组号</code>，外部反向引用<code>$分组号</code> </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="/2023/08/09/jin-cheng-he-xian-cheng/"/>
      <url>/2023/08/09/jin-cheng-he-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li><code>并行(parallel)</code>：指在同一时刻，有多条指令在多个处理器上同时执行</li><li><code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</li></ul><h4 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h4><p>Linux 内核的进程控制块是 <code>task_struct</code> 结构体: </p><ul><li><p><strong>进程id</strong>：系统中每个进程有唯一的 id，用 <code>pid_t</code> 类型表示，其实就是一个非负整数</p></li><li><p><strong>进程的状态</strong>：有<code>就绪</code>、<code>运行</code>、<code>挂起</code>、<code>停止</code>等状态</p></li><li><p>进程切换时需要<strong>保存和恢复的一些CPU寄存器</strong></p></li><li><p>描述<strong>虚拟地址空间</strong>的信息</p></li><li><p>描述<strong>控制终端</strong>的信息</p></li></ul><h4 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h4><h5 id="查看进程-静态"><a href="#查看进程-静态" class="headerlink" title="查看进程-静态"></a>查看进程-静态</h5><ul><li><p><code>ps</code>命令用来查看进程（静态），可以使用<code>man ps</code>查看使用说明</p><ul><li><p>常用参数含义</p><ul><li>a：显示终端上的所有进程，包括其他用户的进程</li><li>u：显示进程的详细信息</li><li>x：显示没有控制终端的进程</li><li>j：列出与作业控制相关的信息</li></ul></li><li><p><code>ps -aux</code>或<code>ps aux</code></p><ul><li><p><code>TTY</code>：进程所属终端，在终端直接执行<code>tty</code>可查看当前<code>Terminal</code>所属终端</p></li><li><p><code>STAT</code>：进程状态</p><ul><li>D ：不可中断 Uninterruptible（usually IO）</li><li>R：正在运行，或在队列中的进程</li><li>S(大写) ：处于休眠状态</li><li>T：停止或被追踪</li><li>Z：僵尸进程</li><li>W：进入内存交换（从内核2.6开始无效）</li><li>X：死掉的进程</li><li>&lt;：高优先级</li><li>N：低优先级</li><li>s：包含子进程</li><li>+：位于前台的进程组</li></ul></li><li><p><code>COMMAND</code>：进程执行命令</p></li></ul></li><li><p><code>ps -ajx</code>或<code>ps ajx</code></p><ul><li><code>PPID</code>：该进程的父进程ID</li><li><code>PGID</code>：该进程所属组ID</li><li><code>SID</code>：该进程所属会话(session)ID，多个组构成会话</li></ul></li></ul></li></ul><h5 id="查看进程-动态"><a href="#查看进程-动态" class="headerlink" title="查看进程-动态"></a>查看进程-动态</h5><ul><li><p><code>top</code></p></li><li><p>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔</p></li><li><p>在 top 命令执行后，可以按以下按键对显示的结果进行排序</p><ul><li>M：根据内存使用量排序</li><li>P：根据 CPU 占有率排序</li><li>T：根据进程运行时间长短排序</li><li>U：根据用户名来筛选进程</li><li>K：输入指定的 PID 杀死进程</li></ul></li></ul><h5 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h5><ul><li><p><code>kill [-signal] pid</code></p></li><li><p><code>kill -l</code>：列出所有信号</p></li><li><p><code>kill -9 进程ID</code> 等价于<code>kill –SIGKILL 进程ID</code></p></li><li><p><code>killall name</code>：根据进程名杀死进程</p></li></ul><h4 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a>进程号和相关函数</h4><ul><li>每个进程都由进程号来标识，其类型为 <code>pid_t（整型）</code>，进程号的范围：<code>0～32767</code>。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用</li><li><strong>任何进程（除 init 进程）都是由另一个进程创建</strong>，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）</li><li><strong>进程组是一个或多个进程的集合</strong>。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号</li><li>进程号和进程组相关函数<ul><li><code>pid_t getpid(void);</code>：获取进程ID</li><li><code>pid_t getppid(void);</code>：获取进程的父进程ID</li><li><code>pid_t getpgid(pid_t pid);</code>：获取进程的组ID</li></ul></li></ul><h4 id="进程创建：fork"><a href="#进程创建：fork" class="headerlink" title="进程创建：fork"></a>进程创建：fork</h4><ul><li><p>可通过<code>man 2 fork</code>查看帮助</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">    pid_t fork(void);</span><br><span class="line">        函数的作用：用于创建子进程。</span><br><span class="line">        返回值：</span><br><span class="line">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span><br><span class="line">            在父进程中返回创建的子进程的ID,</span><br><span class="line">            在子进程中返回0</span><br><span class="line">            如何区分父进程和子进程：通过fork的返回值。</span><br><span class="line">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>Linux 的 <code>fork()</code> 使用是通过<strong>写时拷贝 (copy- on-write) 实现</strong>。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让<strong>父子进程共享同一个地址空间</strong>，只有在<strong>需要写入的时候</strong>才会复制地址空间，从而使各个进程拥有各自的地址空间。即<strong>资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享</strong></p></li><li><p><strong>fork之后父子进程共享文件</strong>。fork产生的子进程与父进程<strong>有相同的文件描述符，指向相同的文件表</strong>，引用计数增加，共享文件偏移指针</p></li></ul><h4 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h4><ol><li><p>打断点及查看 <code>b 行号</code>，<code>i b</code></p></li><li><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，<strong>默认跟踪父进程</strong></p></li><li><p>查看当前跟踪的进程：<code>show follow-fork-mode</code></p></li><li><p>设置调试父进程或者子进程：<code>set follow-fork-mode [parent（默认）| child]</code></p></li><li><p>查看调试模式：<code>show detach-on-fork</code></p></li><li><p>设置调试模式：<code>set detach-on-fork [on | off]</code></p><ul><li>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起</li></ul></li><li><p>查看调试的进程：<code>info inferiors</code></p></li><li><p>切换当前调试的进程：<code>inferior Num</code></p></li><li><p>使进程脱离 GDB 调试：<code>detach inferiors Num</code></p></li></ol><h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><ul><li><p>可通过<code>man 3 exec</code>查看帮助，作用：<strong>在调用进程内部执行一个可执行文件</strong></p></li><li><p>基本组件为<code>exec</code>，后面跟不同参数，代表不同含义</p><ul><li><p><code>l(list) </code>：参数地址列表，以<strong>空指针结尾</strong></p></li><li><p><code>v(vector) </code>：存有各参数地址的指针数组的地址</p></li><li><p><code>p(path) </code>：按 PATH 环境变量指定的目录搜索可执行文件，可用<code>env</code>查看现有的环境变量</p></li><li><p><code>e(environment)</code>：存有环境变量字符串地址的指针数组的地址，增加新的环境变量</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">path：需要指定的执行的文件的路径或者名称</span><br><span class="line">arg：是执行可执行文件所需要的参数列表。第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称，从第二个参数开始往后，就是程序执行所需要的的参数列表，参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line">//会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功</span><br><span class="line">file：只需要提供名称（不需要提供路径）</span><br><span class="line"></span><br><span class="line">int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);</span><br><span class="line">envp：添加路径至环境变量，注意以`NULL`结尾，否则报`execle: Bad address`</span><br><span class="line">char* envp[] = &#123;&quot;/home/u/Desktop/Linux/&quot;, NULL&#125;;</span><br><span class="line">    execle(&quot;/home/u/Desktop/Linux/hello&quot;, &quot;hello&quot;, NULL, envp);</span><br><span class="line"></span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">argv：将运行参数都写在数组中</span><br><span class="line"></span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line"></span><br><span class="line">int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line"></span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><ul><li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为<code>孤儿进程（Orphan Process）</code></li><li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。</li><li>孤儿进程并不会有什么危害</li></ul><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><ul><li><p>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放</p></li><li><p>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成<code>僵尸（Zombie）进程</code></p></li><li><p><strong>僵尸进程不能被 <code>kill -9</code> 杀死</strong>，这样就会导致一个问题，如果父进程不调用 <code>wait()</code> 或 <code>waitpid()</code> 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免</p></li></ul><h4 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h4><ul><li><p><code>wait()</code> 和 <code>waitpid()</code> 函数的功能一样，区别在于，<code>wait()</code> 函数会阻塞；<code>waitpid()</code> 可以设置是否阻塞，<code>waitpid()</code> 还可以指定等待哪个子进程结束</p></li><li><p>一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应使用循环</p></li><li><pre><code>pid_t wait(int *wstatus);//等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源pid_t waitpid(pid_t pid, int *wstatus, int options);//回收指定进程号的子进程，可以设置是否阻塞<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 进程通信</span><br><span class="line"></span><br><span class="line">##### 管道</span><br><span class="line"></span><br><span class="line">- 管道其实是一个在**内核内存中维护的缓冲器**，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同</span><br><span class="line">- 管道拥有文件的特质：读操作、写操作</span><br><span class="line">  - **匿名管道**没有文件实体</span><br><span class="line">  - **有名管道**有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作</span><br><span class="line">- **一个管道是一个字节流**，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少</span><br><span class="line">- 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的</span><br><span class="line">- 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是**半双工**的</span><br><span class="line">- 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，**在管道中无法使用 lseek() 来随机的访问数据**</span><br><span class="line">- `匿名管道`只能在**具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用**</span><br><span class="line"></span><br><span class="line">###### 匿名管道</span><br><span class="line"></span><br><span class="line">`管道`也叫`无名（匿名）管道`，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制</span><br><span class="line"></span><br><span class="line">* 创建匿名管道</span><br><span class="line">  * `int pipe(int pipefd[2])`</span><br><span class="line">    - 功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">    - 参数：`int pipefd[2]` 这个数组是一个传出参数。</span><br><span class="line">      - `pipefd[0]` 对应的是管道的读端</span><br><span class="line">      - `pipefd[1]` 对应的是管道的写端</span><br><span class="line">    - 返回值：成功 0，失败 -1</span><br><span class="line">  * 注意</span><br><span class="line"></span><br><span class="line">    - 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line">    - 匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line"></span><br><span class="line">* 读管道</span><br><span class="line">  - 管道中有数据，read返回实际读到的字节数</span><br><span class="line">  - 管道中无数据</span><br><span class="line">    - 写端被全部关闭，read返回0（相当于读到文件的末尾）</span><br><span class="line">    - 写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">* 写管道</span><br><span class="line">  - 管道读端全部被关闭，进程异常终止（进程收到`SIGPIPE`信号）</span><br><span class="line">  - 管道读端没有全部关闭：</span><br><span class="line">    - 管道已满，write阻塞</span><br><span class="line">    - 管道没有满，write将数据写入，并返回实际写入的字节数</span><br><span class="line"></span><br><span class="line">###### 有名管道</span><br><span class="line"></span><br><span class="line">- 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了`有名管道（FIFO）`，也叫`命名管道`、`FIFO文件`</span><br><span class="line">- `有名管道（FIFO）`不同于匿名管道之处在于它**提供了一个路径名与之关联**，以 **FIFO 的文件形式存在于文件系统中**，并且其打开方式与打开一个普通文件是一样的，这样即使与 `FIFO` 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 `FIFO` 相互通信，因此，通过 `FIFO` 不相关的进程也能交换数据</span><br><span class="line">- 一旦打开了 `FIFO`，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如`read()`、`write()`和`close()`）。与管道一样，`FIFO` 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出</span><br><span class="line">- `有名管道（FIFO)`和`匿名管道（pipe）`有一些特点是相同的，不一样的地方在于</span><br><span class="line">  - `FIFO` 在文件系统中作为一个特殊文件存在，但 `FIFO` 中的**内容却存放在内存中**</span><br><span class="line">  - 当使用 `FIFO` 的进程退出后，`FIFO` 文件将继续保存在文件系统中以便以后使用</span><br><span class="line">  - `FIFO` 有名字，不相关的进程可以通过打开有名管道进行通信</span><br><span class="line"></span><br><span class="line">- 可使用`man fifo`查看帮助</span><br><span class="line"></span><br><span class="line">* 创建有名管道</span><br><span class="line">  * shell命令创建：`mkfifo 文件名`，可通过`man 1 mkfifo`查看帮助</span><br><span class="line">  * 函数创建：`int mkfifo(const char *pathname, mode_t mode);`，可通过`man 3 mkfifo`查看帮助</span><br><span class="line"></span><br><span class="line">##### 共享内存</span><br><span class="line"></span><br><span class="line">**共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）**。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 `IPC` 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用</span><br><span class="line"></span><br><span class="line">* 共享内存使用步骤</span><br><span class="line"></span><br><span class="line">  1. 调用 `shmget()` 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符</span><br><span class="line">  2. 使用 `shmat()`来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分</span><br><span class="line">  3. 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 `shmat()` 调用返回的 `addr` 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针</span><br><span class="line">  4. 调用 `shmdt()` 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步</span><br><span class="line">  5. 调用 `shmctl()` 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步</span><br><span class="line"></span><br><span class="line">* 共享内存操作函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>int shmget(key_t key, size_t size, int shmflg);void *shmat(int shmid, const void *shmaddr, int shmflg);int shmdt(const void *shmaddr);int shmctl(int shmid, int cmd, struct shmid_ds *buf);key_t ftok(const char *pathname, int proj_id);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 共享内存操作命令</span><br><span class="line"></span><br><span class="line">  * ### ipcs </span><br><span class="line"></span><br><span class="line">    - `ipcs -a`：打印当前系统中**所有的**进程间通信方式的信息</span><br><span class="line">    - `ipcs -m`：打印出**使用共享内存**进行进程间通信的信息</span><br><span class="line">    - `ipcs -q`：打印出**使用消息队列**进行进程间通信的信息</span><br><span class="line">    - `ipcs -s`：打印出**使用信号**进行进程间通信的信息</span><br><span class="line"></span><br><span class="line">  * ### ipcrm</span><br><span class="line"></span><br><span class="line">    - `ipcrm -M shmkey`：移除用`shmkey`创建的**共享内存段**</span><br><span class="line">    - `ipcrm -m shmid`：移除用`shmid`标识的**共享内存段**</span><br><span class="line">    - `ipcrm -Q msgkey`：移除用`msqkey`创建的**消息队列**</span><br><span class="line">    - `ipcrm -q msqid`：移除用`msqid`标识的**消息队列**</span><br><span class="line">    - `ipcrm -S semkey`：移除用`semkey`创建的**信号**</span><br><span class="line">    - `ipcrm -s semid`：移除用`semid`标识的**信号**</span><br><span class="line"></span><br><span class="line">##### 信号</span><br><span class="line"></span><br><span class="line">- 可通过`man 7 signal`查看帮助</span><br><span class="line"></span><br><span class="line">- 信号的 5 中默认处理动作</span><br><span class="line"></span><br><span class="line">  - `Term`：终止进程</span><br><span class="line">  - `Ign`：当前进程忽略掉这个信号</span><br><span class="line">  - `Core`：终止进程，并生成一个Core文件</span><br><span class="line">  - `Stop`：暂停当前进程</span><br><span class="line">  - `Cont`：继续执行当前被暂停的进程</span><br><span class="line"></span><br><span class="line">- 信号的几种状态：`产生`、`未决`、`递达`</span><br><span class="line"></span><br><span class="line">- `SIGKILL` 和 `SIGSTOP` 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</span><br><span class="line"></span><br><span class="line">- 常用信号</span><br><span class="line"></span><br><span class="line">  | 编号 | 信号名称 | 对应事件                                       | 默认动作               |</span><br><span class="line">  | ---- | -------- | ---------------------------------------------- | ---------------------- |</span><br><span class="line">  | 2    | SIGINT   | 按下&lt;Ctrl +c&gt;组合键时用户终端向程序发出此信号  | 终止进程               |</span><br><span class="line">  | 3    | SIGQUIT  | 按下&lt;Ctrl +\\&gt;组合键时用户终端向程序发出此信号 | 终止进程               |</span><br><span class="line">  | 9    | SIGKILL  | 无条件终止进程。该信号不能被忽略、处理和阻塞   | 终止进程               |</span><br><span class="line">  | 11   | SIGSEGV  | 指示进程进行了无效内存访问（段错误）           | 终止进程并产生core文件 |</span><br><span class="line">  | 13   | SIGPIPE  | Broke pipe向一个没有读端的管道写数据           | 终止进程               |</span><br><span class="line">  | 17   | SIGCHLD  | 子进程结束时，父进程会收到这个信号             | 忽略这个信号           |</span><br><span class="line">  | 18   | SIGCONT  | 如果进程已停止，则使其继续运行                 | 继续/忽略              |</span><br><span class="line">  | 19   | SIGSTOP  | 停止进程的执行。不能被忽略、处理和阻塞         | 终止进程               |</span><br><span class="line"></span><br><span class="line">* 当进程异常终止时，会生成`core`文件（需要进行相应设置），可以通过`gdb`调试查看错误</span><br><span class="line"></span><br><span class="line">  * 生成调试`core`文件需要做以下几步</span><br><span class="line">    1. 使用`ulimit -a`查看资源上限</span><br><span class="line">    2. 修改`core size`：`ulimit -c core-size`</span><br><span class="line">    3. 在编译运行程序时加上`-g`选项使得能够被`gdb`调试，运行后生成`core`文件</span><br><span class="line">    4. 调试`core`程序：`gdb 可执行文件`进入`gdb`终端，使用`core-file core`可以查看`core`定位错误</span><br><span class="line"></span><br><span class="line">* 信号相关函数</span><br><span class="line"></span><br><span class="line">  * `int kill(pid_t pid, int sig);` 给**任何的进程或者进程组**`pid`，发送**任何的信号** `sig`</span><br><span class="line"></span><br><span class="line">  * `int raise(int sig);` 给**当前进程**发送信号</span><br><span class="line"></span><br><span class="line">  * `void abort(void);` 发送`SIGABRT`信号给当前的进程，**杀死当前进程**</span><br><span class="line"></span><br><span class="line">  * `unsigned int alarm(unsigned int seconds);` 设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：`SIGALARM`：默认终止**当前的进程**，每一个进程都有且只有唯一的一个定时器</span><br><span class="line"></span><br><span class="line">  * `int setitimer(int which, const struct itimerval *new_val, struct itimerval *old_value);`  设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line"></span><br><span class="line">  * `sighandler_t signal(int signum, sighandler_t handler);` 设置某个信号的捕捉行为</span><br><span class="line"></span><br><span class="line">  * `int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);` 检查或者改变信号的处理，即信号捕捉</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">* 信号集</span><br><span class="line"></span><br><span class="line">  * 使用`man 3 sigset`查看帮助</span><br><span class="line">  * 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 `sigset_t`</span><br><span class="line">  * 在 PCB 中有两个非常重要的信号集。一个称之为 `阻塞信号集` ，另一个称之为`未决信号集`。这两个信号集都是**内核使用位图机制来实现**的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改</span><br><span class="line">  * 信号的 `未决` 是一种状态，指的是**从信号的产生到信号被处理前的这一段时间**</span><br><span class="line">  * 信号的 `阻塞` 是一个开关动作，指的是**阻止信号被处理，但不是阻止信号产生**。信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作</span><br><span class="line">  * 操作自定义信号集函数</span><br><span class="line">    * 使用`man 3 sigemptyset`查看帮助</span><br><span class="line">    * `int sigemptyset(sigset_t *set);`功能：清空信号集中的数据，将信号集中的所有的标志位置为0</span><br><span class="line">    * `int sigfillset(sigset_t *set);`将信号集中的所有的标志位置为1</span><br><span class="line">    * `int sigaddset(sigset_t *set, int signum);`设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="line">    * `int sigdelset(sigset_t *set, int signum);`设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="line">    * `int sigismember(const sigset_t *set, int signum);`判断某个信号是否阻塞</span><br><span class="line"></span><br><span class="line">  * 操作内核信号集函数</span><br><span class="line">    * `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">    * `int sigpending(sigset_t *set);`获取内核中的未决信号集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 线程</span><br><span class="line"></span><br><span class="line">- 与`进程（process）`类似，`线程（thread）`是允许应用程序**并发执行多个任务**的一种机制</span><br><span class="line">- 一个进程可以包含多个线程</span><br><span class="line"></span><br><span class="line">* **进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位**</span><br><span class="line"></span><br><span class="line">#### 进程和线程区别</span><br><span class="line"></span><br><span class="line">- **进程间的信息难以共享**。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换</span><br><span class="line">- 调用 `fork()` 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 `fork()` 调用在时间上的开销依然不菲</span><br><span class="line">- 线程之间能够方便、快速地共享信息。只需**将数据复制到共享（全局或堆）变量**中即可</span><br><span class="line">- 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</span><br><span class="line"></span><br><span class="line">#### 线程之间共享和非共享资源</span><br><span class="line"></span><br><span class="line">##### 共享资源</span><br><span class="line"></span><br><span class="line">- 进程 ID 和父进程 ID</span><br><span class="line">- 进程组 ID 和会话 ID</span><br><span class="line">- 用户 ID 和 用户组 ID</span><br><span class="line">- 文件描述符表</span><br><span class="line">- 信号处置</span><br><span class="line">- 文件系统的相关信息：文件权限掩码（`umask`）、当前工作目录</span><br><span class="line">- 虚拟地址空间（**除栈、.text**）</span><br><span class="line"></span><br><span class="line">##### 非共享资源</span><br><span class="line"></span><br><span class="line">- 线程 ID</span><br><span class="line">- 信号掩码</span><br><span class="line">- 线程特有数据</span><br><span class="line">- error 变量</span><br><span class="line">- 实时调度策略和优先级</span><br><span class="line">- 栈，本地变量和函数的调用链接信息</span><br><span class="line"></span><br><span class="line">#### 线程操作函数</span><br><span class="line"></span><br><span class="line">由于`pthread`属于第三方库，所以在编译时需要加上参数`-pthread`或`-lpthread`即指定包路径，如果不加报以下错误</span><br><span class="line"></span><br><span class="line">- 获取当前的线程的线程ID：`pthread_t pthread_self(void);`</span><br><span class="line"></span><br><span class="line">- 比较两个线程ID是否相等：`int pthread_equal(pthread_t t1, pthread_t t2);`</span><br><span class="line"></span><br><span class="line">  &gt; 不同的操作系统，`pthread_t`类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的</span><br><span class="line"></span><br><span class="line">- 线程创建：``int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);``</span><br><span class="line"></span><br></pre></td></tr></table></figure>- `thread`：传出参数，线程创建成功后，子线程的线程ID被写到该变量中- `attr` : 设置线程的属性，一般使用默认值，NULL- `start_routine` : 函数指针，这个函数是子线程需要处理的逻辑代码- `arg` : 给第三个参数(`start_routine`)使用，传参</code></pre></li></ul><ul><li><p>线程终止：<code>void pthread_exit(void *retval);</code></p></li><li><p>线程连接：<code>int pthread_join(pthread_t thread, void **retval);</code>，和一个已经终止的线程进行连接。回收子线程的资源，这个函数是阻塞函数，调用一次只能回收一个子线程，一般在主线程中使用</p></li><li><p>线程分离：<code>int pthread_detach(pthread_t thread);</code>，分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统</p></li><li><p>线程取消：<code>int pthread_cancel(pthread_t thread);</code></p></li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul><li><code>临界区</code>是指访问某一共享资源的代码片段，并且这段代码的执行应为<code>原子操作</code>，也就是同时访问同一共享资源的其他线程不应终端该片段的执行</li><li><code>线程同步</code>：即<strong>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态</strong></li></ul><h5 id="互斥量-互斥锁"><a href="#互斥量-互斥锁" class="headerlink" title="互斥量(互斥锁)"></a>互斥量(互斥锁)</h5><p><strong>互斥量能保证对任意共享资源的原子访问</strong>。任何时候，<strong>至多只有一个线程可以锁定该互斥量</strong>。</p><h6 id="相关操作函数"><a href="#相关操作函数" class="headerlink" title="相关操作函数"></a>相关操作函数</h6><ul><li><p>互斥量的类型：<code>pthread_mutex_t</code></p></li><li><p>初始化互斥量：<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></p><ul><li>参数<ul><li><code>mutex</code> ： 需要初始化的互斥量变量</li><li><code>attr</code> ： 互斥量相关的属性，设置为NULL，由内核指定</li></ul></li><li><code>restrict</code> : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作</li></ul></li><li><p>释放互斥量的资源：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p></li><li><p>加锁：<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p></li><li><p>尝试加锁：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p></li><li><p>解锁：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p></li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><ul><li>产生死锁的几种场景：<ul><li>忘记释放锁</li><li>重复加锁</li><li>多线程多锁，抢占锁资源</li></ul></li></ul><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul><li><p>读写锁的特点</p><ul><li><p>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</p></li><li><p>如果有其它线程写数据，则其它线程都不允许读、写操作</p></li><li><p>写是独占的，写的优先级高</p></li></ul></li><li><p>相关操作函数</p><ul><li><p>读写锁的类型：<code>pthread_rwlock_t</code></p></li><li><p>初始化读写锁：<code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></p></li><li><p>释放互斥量的资源：<code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p></li><li><p>读操作加锁：<code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p></li><li><p>读操作尝试加锁：<code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></p></li><li><p>写操作加锁：<code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p></li><li><p>写操作尝试加锁：<code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p></li><li><p>解锁：<code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p></li></ul></li></ul><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><ul><li>相关操作函数<ul><li>条件变量的类型：<code>pthread_cond_t</code></li><li>初始化：<code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></li><li>回收：<code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li><li>等待，调用了该函数，线程会阻塞：<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></li><li>等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束：<code>int pthread_cond_timedwait(pthread_cond_t *restrict cond,  pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></li><li>唤醒一个或者多个等待的线程：<code>int pthread_cond_signal(pthread_cond_t *cond);</code></li><li>唤醒所有的等待的线程：<code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li></ul></li></ul><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><ul><li>相关操作函数<ul><li>信号量的类型：<code>sem_t</code></li><li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code><ul><li>功能：初始化信号量</li><li>参数<ul><li><code>sem</code>：信号量变量的地址</li><li><code>pshared</code>：0 用在线程间 ，非0 用在进程间</li><li><code>value </code>：信号量中的值，代表容器大小</li></ul></li></ul></li><li><code>int sem_destroy(sem_t *sem);</code><ul><li>功能：释放资源</li></ul></li><li><code>int sem_wait(sem_t *sem);</code><ul><li>功能：对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</li></ul></li><li><code>int sem_trywait(sem_t *sem);</code></li><li><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></li><li><code>int sem_post(sem_t *sem);</code><ul><li>功能：对信号量解锁，调用一次对信号量的值+1</li></ul></li><li><code>int sem_getvalue(sem_t *sem, int *sval);</code></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>事务与并发</title>
      <link href="/2023/07/22/shi-wu-yu-bing-fa/"/>
      <url>/2023/07/22/shi-wu-yu-bing-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是访问并可能更新各种数据项的一个程序执行单元，事务是不可分割的，要么执行全部内容要么不执行。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>原子性：事务的所有操作要么全部正确的反映出来，要么完全不反映</li><li>一致性：数据库从一个一致的数据库状态开始，结束于另一个一致的状态。例如转账金额总和不变。</li><li>隔离性：尽管多个事务可能并发执行，但系统保证每个事务感觉不到其他事务在执行</li><li>持久性：一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障</li></ul><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul><li>活动的：初始状态，事务执行时处于该状态</li><li>部分提交的：最后一条语句执行后。事务已经完成执行，但可能仍驻留在主存中</li><li>失败的：发现正常的执行不能继续后</li><li>中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后。事务进入中止状态系统有两种选择：重启（中止由硬件错误而不是内部逻辑导致）和杀死</li><li>提交的：成功完成后</li></ul><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>如果I和J是有不同的事务在相同数据项上执行的操作，并且其中有一个指令是write操作，那么I和J是冲突的。</p><ul><li>冲突等价：一系列非冲突指令的交换得到的调度是等价的</li><li>冲突可串行化-优先图：优先图无环则是冲突可串行化（充分非必要条件）</li></ul><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><ul><li>丢失更新（对数据的修改丢失了）</li><li>读脏数据（读取的数据不存在）</li><li>不可重复读（两次读到的数据不一样）</li></ul><h4 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h4><ul><li><p>一级封锁协议：事务在修改数据之前必须加排他锁，直到事务结束才释放</p><ul><li>解决丢失更新</li><li>会出现脏读、不可重复读</li></ul></li><li><p>二级封锁协议：一级封锁协议+事务在读取数据之前加共享锁，读完立即释放</p><ul><li>解决脏读</li><li>会出现不可重复读</li></ul></li><li><p>三级封锁协议：一级封锁协议+事务在读取数据之前加共享锁，<strong>事务结束</strong>才释放</p><ul><li>解决不可重复读</li></ul></li><li><p>两阶段封锁协议：三级封锁协议，需要在事务结束时才能释放锁，代价太大。 放宽事务释放锁的时机。分两个阶段提出加锁和解锁申请</p><ol><li>增长阶段：可以获得锁，但不能释放锁</li><li>缩减阶段：可以释放锁，但不能获得锁</li></ol></li><li><p>共享锁和排他锁：共享锁对数据可读不可写，排他锁可读可写</p></li><li><p>锁的升级：事务T要读写X的新值，X首先持有一个共享锁，待到T准备好写入新值时，将锁升级为排他锁</p></li><li><p>更新锁：如果Ti 想要读A且知道之后可能会写A，那么它就请求一个更新锁（非共享锁）</p><ul><li>更新锁随后可以升级为写锁，读锁不可以升级</li><li>X上已经持有一个共享锁时可以被授予更新锁，可是一旦X上持有一个更新锁，我们就应当防止X上被添加其他锁</li></ul></li><li><p>增量锁：</p><ul><li>一个一致性事务仅仅只有在拥有X上的增量锁时才能执行增量动作。增量锁不同时允许读动作或写动作。</li><li>在一个合法调度中，任何数量的事务能够在任何时间持有在X上的增量锁</li><li>动作inci(X) 与 rj(X) 和 wj(X)冲突, 但是并不与incj(X) 冲突</li></ul></li></ul><h4 id="隔离性级别"><a href="#隔离性级别" class="headerlink" title="隔离性级别"></a>隔离性级别</h4><ul><li><p>读未提交：允许读未提交数据</p><ul><li>解决丢失更新</li><li>存在不可重复读、脏读、幻象</li></ul></li><li><p>读已提交：只允许读已提交数据</p><ul><li>解决丢失更新、脏读</li><li>存在不可重复读、幻象</li></ul></li><li><p>可重复读：只允许读已提交数据，一个事务两次读取一个数据项期间其他事务不得更新该数据</p><ul><li>解决丢失更新、脏读、不可重复读</li><li>存在幻象</li></ul></li><li><p>可串行化读</p></li><li><p>隔离性级别的实现</p><ul><li>锁：共享锁用于事务读的数据项，排他锁用于事务写的数据项</li><li>时间戳：事务按照时间戳顺序访问数据项</li><li>多版本和快照隔离：维护多个版本数据项。快照隔离中想象每个事务有自己的数据库版本或快照，从私有的版本中读取数据，与其他事务隔离</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库存储和查询</title>
      <link href="/2023/07/11/shu-ju-ku-cun-chu-he-cha-xun/"/>
      <url>/2023/07/11/shu-ju-ku-cun-chu-he-cha-xun/</url>
      
        <content type="html"><![CDATA[<h3 id="存储和文件结构"><a href="#存储和文件结构" class="headerlink" title="存储和文件结构"></a>存储和文件结构</h3><h4 id="文件中记录的组织"><a href="#文件中记录的组织" class="headerlink" title="文件中记录的组织"></a>文件中记录的组织</h4><ul><li><p>堆文件组织：任意存储</p></li><li><p>顺序文件组织：根据搜索码的值顺序存储</p><p>插入删除时维护记录的物理顺序困难，可以使用指针链表来管理，插入位置不为空时将新纪录插入溢出块中，顺序处理效率降低。文件重组来恢复顺序</p></li><li><p>散列文件组织：根据散列函数的结果决定存储位置</p></li><li><p>多表聚簇文件组织：通常每个关系的记录用到单独的文件存储。多表聚簇文件组织是一种在每一块中存储两个或多个关系的相关记录的文件组织结构，可以高效的执行特定查询。</p></li></ul><h3 id="索引与散列"><a href="#索引与散列" class="headerlink" title="索引与散列"></a>索引与散列</h3><h4 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h4><p>基于值的顺序排序</p><ul><li>聚集索引（主索引）：搜索码指定的顺序与文件中记录的物理顺序相同</li><li>非聚集索引（辅助索引）：搜索码指定的顺序与文件中记录的物理顺序不同</li><li>稠密索引：文件中的每个搜索码值都有一个索引项，索引项包括索引值和指向第一条数据的指针。查找快</li><li>稀疏索引：只为搜索码的某些值建立索引项。只有当关系按照搜索码顺序存储时（聚集索引）才能使用稀疏索引。所占空间小，插入和删除所需维护开销小</li><li>多级索引：原始的内层索引上构造一个稀疏的外层索引</li><li>辅助索引：不是主索引的索引。必须是稠密索引，对每个搜索码值都有一个索引项，而且对文件的每一条记录都有一个指针。</li><li>多码上的索引：复合搜索码</li></ul><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ul><li>插入：叶结点中仍有空间；叶结点溢出；非叶结点溢出；分裂、新根结点</li><li>删除：叶结点内直接删除；页结点与兄弟结点合并；从兄弟结点借键；合并根结点</li><li>结点分裂、合并会影响到辅助索引更新指针，为此：在辅助索引中，不存储指向被索引的记录的指针，而是存储主索引搜索码属性的值。现在辅助索引定位记录需两步：首先用辅助索引找到主索引搜索码的值，然后用主索引找对应记录。</li></ul><h4 id="B-树扩展"><a href="#B-树扩展" class="headerlink" title="B+树扩展"></a>B+树扩展</h4><ul><li><p>B+树文件组织：叶结点存储记录而不是指向记录的指针</p></li><li><p>辅助索引和记录重定向：一些文件组织可能改变记录的位置，即使记录并没有更新。这可能影响到辅助索引，解决方法是：在辅助索引中不存储指向被索引记录的指针，而是存储主索引搜索码的值。</p></li><li><p>字符串上的索引：字符串上使用B+树有两个问题：字符串是变长的；字符串很长导致结点扇出降低以及相应的增加树的高度。使用<strong>前缀压缩</strong>技术可以增加结点的扇出，不用存储整个搜索码值，只存储一个足以区分开的前缀</p></li><li><p>B+树索引的批量加载：大量项一次插入到索引中。方法：首先创建一个含有关系索引项的临时文件，然后根据创建好的索引的搜索码来排序文件，最后插入到索引中。</p></li><li><p><strong>静态散列（散列索引）</strong>：</p><ul><li>散列函数：分布均匀、随机</li><li>桶（存储一条或多条记录的存储单位）溢出：<ul><li>原因：桶不足；偏斜（某些桶分配记录多，其他桶仍有空间）</li><li>溢出桶解决桶溢出问题：若桶已满则插入到溢出桶中，形成溢出链。这种散列结构称为闭地址。</li><li>开地址：桶固定，没有溢出链，桶满后将其插入其他桶。在数据库重要性不大</li></ul></li></ul></li><li><p><strong>动态散列</strong>：散列函数动态改变适应数据库增大或缩小</p><ul><li><p>数据结构：通过桶的分裂或合并适应数据库大小变化。选择的散列函数的值范围较大，是b位二进制整数，一个典型的b值是32，使用 高i 位标记桶，i随数据库大小变化而增大或减小。</p></li><li><p>查询和更新</p><ul><li>插入：若桶满，则分裂这个桶并对记录重新分配。分裂桶需要确定是否增加位数，如果只有一个表项指向桶，则多引入一位；如果多个表项指向桶不需要增加位数</li><li>删除：桶空删除。位数也应随之变化</li></ul></li><li><p>线性散列：使用低i位标记桶。与上述可扩充散列不同的是线性散列不使用间接层（桶地址表）</p></li></ul></li><li><p><strong>多维索引结构</strong>：</p><ul><li><p>类散列方法</p><ul><li>网格文件：存储指向记录的指针。根据每维的分量确定所属的桶，桶没有空间可以添加溢出块或通过增加或移动网格重组结构。适用范围查询和最临近查询</li><li>分段散列函数：适用部分匹配查询</li></ul></li><li><p>类树方法</p><ul><li>多键索引</li><li>kd-树：内部结点有一对属性和值将数据点分成两部分，所有维的属性在层间交替出现，叶子层为存储记录的存储块。</li><li>四叉树</li><li>R树（区域树）</li></ul></li><li><p>位图索引：关系有n个记录，字段有m种取值，则位图索引是m个长度为n的位向量集合。位图索引只是找到记录号，但是记录对应的磁盘地址不知道，可以创建一个辅助索引，索引项是记录号和记录地址。</p><ul><li><p>压缩位图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">对位图进行压缩，i个0和后面的一个1是一个段，对段进行编码</span><br><span class="line">0000 0000 0000 01//13个0,log2(13) = 4,所以编码为：</span><br><span class="line">11101101            //1110表示后面4位是有效值,1101表示13个0和一个1</span><br><span class="line">特殊:如果没有0,编码00;如果1个0，编码01</span><br><span class="line">例如:100000001000 -&gt; 00 110111</span><br><span class="line">1-&gt;00</span><br><span class="line">00000001-&gt;110111</span><br><span class="line">000-&gt;忽略</span><br><span class="line">解码:111011011011-&gt;0000 0000 0000 01 1 0001</span><br><span class="line">11101101-&gt;0000 0000 0000 01</span><br><span class="line">00-&gt;1</span><br><span class="line">1011-&gt;0001</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h4><ul><li><p><strong>选择运算</strong></p><p><img src="https://github.com/RonronnerW/RonronnerW.github.io/blob/master/img/db3.jpg"></p></li><li><p><strong>排序</strong>：外部排序归并算法</p></li><li><p><strong>连接运算</strong></p><ul><li><p>嵌套循环连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for each 元组r in R do begin</span><br><span class="line">for each 元组s in S do begin</span><br><span class="line">测试元组对(r,s)是否满足连接条件</span><br><span class="line">如果满足输出r·s</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>块嵌套循环连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for each 块r in R do begin</span><br><span class="line">for each 块s in S do begin</span><br><span class="line">for each 元组t in 块r do begin</span><br><span class="line">for each 元组v in 块s do begin</span><br><span class="line">测试元组对(r,s)是否满足连接条件</span><br><span class="line">如果满足输出r·s</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>索引嵌套循环连接：内层循环连接的属性上有索引，用索引查找替换文件扫描</p></li><li><p>归并连接：归并连接算法（排序-归并-连接算法）可用于自然连接和等值连接</p></li><li><p>散列连接：用于自然连接和等值连接。思想：关系r的一个元组和关系s的一个元组满足连接条件时，他们在连接属性上就会有相同的值。</p></li></ul></li><li><p><strong>其他运算</strong></p><ul><li><p>去除重复：可以用排序方法和散列实现去除重复</p></li><li><p>投影：对单个元组进行投影在去重</p></li><li><p>集合运算：</p><ul><li>对两个关系进行排序，然后对已排序关系扫描一次产生结果</li><li>使用相同的散列函数对两个关系进行划分r_0…r_n和s_0…s_n, 对r_i建立散列索引，再对s_i中元组根据并、交、差不同情况输出到结果中</li></ul></li><li><p>外连接：</p><ul><li>计算相应连接，然后将适当元组加入到连接结果中</li><li>对连接算法加以修改。例如计算左外连接时对嵌套循环算法进行修改，与内层元组都不匹配的外层元组加入结果</li></ul></li><li><p>聚集</p></li></ul></li><li><p><strong>表达式计算</strong>：</p><ul><li>物化：构造临时关系将其写到磁盘上</li><li>流水线：同时计算多个运算<ul><li>需求驱动的流水线：系统不停向位于流水线顶端的操作发出需要元组的请求</li><li>生产者驱动的流水线：各个操作并不等待元组请求，而是积极的产生元组</li></ul></li></ul></li></ul><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><ul><li><p><strong>等价规则</strong></p><ul><li><p>合取选择运算可分解为单个选择运算的序列 <code>在关系E上选择a和b属性，可分解为在E上取a属性的基础上取b属性</code></p></li><li><p>选择运算满足交换律</p></li><li><p>一系列投影运算中只有最后一个运算是必须的，其余可省略</p></li><li><p>选择操作可与笛卡尔积以及θ连接相结合</p><p><img src="https://img8.php1.cn/3cdc5/fd11/bdf/7b0a2aa1f1fa1468.png" alt="选择操作可与笛卡尔积以及θ连接相结合"></p></li><li><p>θ连接运算满足交换律</p><p><img src="https://img8.php1.cn/3cdc5/fd11/bdf/ac88ac68dc7c04af.png"></p></li><li><p>选择运算在下面两个条件下对θ连接运算具有分配律</p><p><img src="https://kgithub.com/RonronnerW/RonronnerW.github.io/blob/master/img/db1.png?raw=true"></p></li><li><p>投影运算在下面条件下对θ连接运算具有分配律</p><p><img src="https://kgithub.com/RonronnerW/RonronnerW.github.io/blob/master/img/db2.png?raw=true"></p></li><li><p>集合的并于交满足交换律和结合律</p></li><li><p>选择运算对并、交、差运算具有分配律</p></li><li><p>投影运算对并运算具有分配律</p></li></ul></li><li><p><strong>物化视图</strong>：内容已计算并存储的视图</p><ul><li>视图维护：触发器、增量的视图维护</li><li>增量的视图维护：只对视图的受影响部分进行修改<ul><li>连接操作：<code>对于视图v = r连接s 对r插入元组i, 更新v仅需要将 元组i连接s 的结果加入到物化视图中</code></li><li>选择和投影操作：<code>投影操作：对投影的每个元组可保留一个计数，记录该元组由几条途径得到</code></li><li>聚集操作：类似投影操作</li></ul></li></ul></li><li><p><strong>查询优化中的高级话题</strong>：</p><ul><li>top-K优化：只取结果中前k个</li><li>连接极小化：连接中去掉一个关系</li><li>更新的优化：万圣节问题（更新操作本身可能影响自己执行的问题）将更新查询批量收集，然后将批量的更新在其影响的索引上执行</li><li>多查询优化和共享式扫描：不同查询中间共同的子表达式，仅执行它们一次并在需要时重用。不是对于需要扫描一个关系的每一个查询都从磁盘重复读，而是读一次然后流水线的传递给每一个查询。</li><li>参数化查询优化</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/2023/07/06/shu-ju-ku-she-ji/"/>
      <url>/2023/07/06/shu-ju-ku-she-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="数据库设计和E-R模型"><a href="#数据库设计和E-R模型" class="headerlink" title="数据库设计和E-R模型"></a>数据库设计和E-R模型</h4><h5 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a><strong>E-R模型</strong></h5><ul><li>实体集：相同类型或性质的实体的集合。</li><li>联系集：联系指多个实体间的关联。联系集是相同类型联系的集合。</li><li>属性：属性可取值的集合叫域<ul><li>简单属性：不能划分更小的部分</li><li>复合属性：可以再划分，如地址</li><li>单值属性：如id</li><li>多值属性：如电话</li><li>派生属性：属性值不存储，需要时计算，如根据出生计算年龄</li></ul></li></ul><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h5><ul><li>映射基数：表示一个实体通过联系集能关联的实体个数。有一对一、一对多、多对一和多对多</li><li>参与约束：全部的或部分的：根据实体是否全部参与联系区分</li><li>码</li></ul><h5 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a><strong>E-R图</strong></h5><ul><li><p>基本结构：</p><ul><li>分成两部分的矩形：实体集，属性加下划线表示主码</li><li>菱形：联系集</li><li>未分割的矩形：联系集的属性</li><li>线段：连接实体集和联系集</li><li>虚线：连接联系集属性和联系集</li><li>双实线：显示实体在联系集中的参与度</li><li>双菱形：代表连接到弱实体集的标志性联系集</li></ul></li><li><p>映射基数：</p><ul><li>一对一：联系集到实体集的箭头</li><li>一对多&#x2F;多对一&#x2F;多对多：一用箭头，多用线段</li><li>线上用<code>l..h</code>标明最小和最大映射基数，最小值为1表示实体集全部参与，最大值为1表示实体参与至多一个联系，*代表没有限制</li></ul></li></ul><h5 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a><strong>弱实体集</strong></h5><ul><li><p><strong>没有足够的属性以形成主码的实体集</strong>。有主码的实体集称为强实体集。弱实体集必须与称作标识或属主实体集的实体集关联才有意义。每个弱实体必须和一个标识实体关联。</p><p>区分弱实体集中实体的属性集合叫分辨符&#x2F;部分码</p><p>弱实体集的主码由标识实体集的主码加上分辨符构成</p><p>在E-R图中：</p><ul><li>弱实体集的分辨符以虚下划线标明</li><li>关联弱实体集和标识实体集的联系集以双菱形表示</li></ul></li></ul><h5 id="拓展的E-R特性"><a href="#拓展的E-R特性" class="headerlink" title="拓展的E-R特性"></a><strong>拓展的E-R特性</strong></h5><ul><li><p>特化：</p><ul><li><p>实体集中可能包含一些子集，子集中的实体某些方面区别于实体集中的其他实体。例如，实体集<code>person</code>可分为<code>employee</code>和<code>student</code>, 这两类中每一个都用一个属性集来描述，<code>employee</code>可以进一步用<code>salary</code>来描述，<code>student</code>进一步用<code>cred</code>来描述。</p></li><li><p>在实体集内部进行分组的过程称为<strong>特化</strong></p></li><li><p>E-R图中，特化用从特化实体指向另一方实体的空心箭头来表示。称这种关系为ISA关系，表示“是一个”。</p></li></ul></li><li><p>概化：高层实体集与低层实体集的包含关系。提取公共属性，概化是特化的逆过程</p><ul><li>全部概化&#x2F;特化：每个高层实体必须属于一个低层实体集</li><li>部分概化&#x2F;特化：允许一些高层实体不属于任何低层实体</li></ul></li><li><p>高层和低层实体集</p><ul><li>低层实体集有两种情况<ul><li>不相交：要求一个实体至多属于一个低层实体集</li><li>重叠：允许属于多个低层实体集</li></ul></li></ul></li><li><p>属性继承：高层实体集的属性被低层实体集所继承。</p></li><li><p>聚集：通过抽象将联系视为高层实体</p></li></ul><h4 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h4><h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h5><p>​一个域是原子的，如果该域的元素被认为是不可分的单元。</p><p>​关系的所有属性的域都是原子的（不可分的），则该关系模式属于第一范式。</p><h5 id="使用函数依赖分解"><a href="#使用函数依赖分解" class="headerlink" title="使用函数依赖分解"></a>使用函数依赖分解</h5><ul><li><p><strong>码和函数依赖</strong>：</p><ul><li>超码：可以唯一标识关系中一条元组的一个或多个属性的集合。子集K是超码的条件：关系r的实例中的所有元组对t1和t2总满足，若t1≠t2，则t1[K]≠t2[K]。</li><li>满足函数依赖 a-&gt;b 的条件：对所有元组对t1和t2，若t1[a]&#x3D;t2[a]，则t1[b]&#x3D;t2[b]</li><li>每个合法实例都满足函数依赖，则说该函数依赖在模式上成立</li><li>如果函数依赖K-&gt;R在r(R)上成立，则K是r(R)的一个超码。若t1[K]&#x3D;t2[K]，则t1[R]&#x3D;t2[R]（t1&#x3D;t2)</li><li>有些函数依赖称为平凡的，因为它们在所有关系中都满足。一般地，如果b包含于a，则形如a-&gt;b的函数依赖是平凡的。</li><li>A-&gt;B, B-&gt;C, 则A-&gt;C</li></ul></li><li><p><strong>Boyce-Codd范式（BCNF）</strong>：</p><ul><li><p>对F的闭包（F﹢）中所有形如 a-&gt;b 的函数依赖，下面至少一项成立：</p><ol><li><p>a-&gt;b 是平凡的函数依赖（即b包含于a）</p></li><li><p>a 是关系模式的一个超码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算a﹢，并且验证它是否包含R中的所有属性，即验证它是否是R的超码</span><br></pre></td></tr></table></figure></li></ol></li><li><p>分解不属于BCNF模式的一般规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设R不属于BCNF，则存在至少一个非平凡的函数依赖 a-&gt;b ,其中a不是R的超码。以下面两个模式取代R：</span><br><span class="line">(a∪b)</span><br><span class="line">(R-(b-a))</span><br><span class="line">产生的模式仍有不属于BCNF的，则继续分解，直至最终都是BCNF</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>第三范式</strong>：</p><ul><li><p>对F的闭包中所有形如 a-&gt;b 的函数依赖，下面至少一项成立：</p><ol><li><p>a-&gt;b 是一个平凡的函数依赖（b包含于a）</p></li><li><p>a 是 R 的一个超码</p></li><li><p>b-a 中的每个属性A都包含于R的一个候选码中（可能包含于不同的候选码中）</p></li></ol></li></ul></li></ul><h5 id="函数依赖理论"><a href="#函数依赖理论" class="headerlink" title="函数依赖理论"></a>函数依赖理论</h5><ul><li><p>Armstrong公理：</p><ul><li>自反律：若a为一属性集且b包含于a，则a-&gt;b成立</li><li>增补律：若a-&gt;b成立且r，则r∪a-&gt;r∪b</li><li>传递律：a-&gt;b和b-&gt;r，则a-&gt;r</li><li>合并律：a-&gt;b和a-&gt;r，则a-&gt;b∪r</li><li>分解律：a-&gt;b∪r，则a-&gt;b和a-&gt;r</li><li>伪传递律：a-&gt;b和c∪b-&gt;r，则a∪c-&gt;r</li></ul></li><li><p>计算闭包（F﹢）的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F﹢=F</span><br><span class="line">repeat</span><br><span class="line">for each F﹢中的函数依赖f</span><br><span class="line">在f上应用自反律和增补律</span><br><span class="line">将结果加入到F﹢中</span><br><span class="line">for each F﹢中的一对函数依赖f1和f2</span><br><span class="line">if f1和f2可以使用传递律结合起来</span><br><span class="line">将结果加入到F﹢中</span><br><span class="line">until F﹢不再发生变化</span><br></pre></td></tr></table></figure></li><li><p>属性集的闭包：a为一个属性集，函数依赖集下被a所确定的所有属性的集合称为a的<strong>闭包</strong>(a﹢)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ret:=a;</span><br><span class="line">repeat</span><br><span class="line">for each 函数依赖 b-&gt;c in F do</span><br><span class="line">begin</span><br><span class="line">if b包含于ret then ret:=ret∪c;</span><br><span class="line">            end</span><br><span class="line">     until (ret不变)</span><br></pre></td></tr></table></figure><ul><li>闭包的用途：<ul><li>判断a是否为超码，计算a﹢，检查a﹢是否包含所有属性</li><li>通过检查是否b包含于a﹢，我们可以检查函数依赖a-&gt;b是否成立</li></ul></li></ul></li><li><p>正则覆盖：是一个依赖集，其中任何函数依赖都不含无关属性（除去一个属性不影响闭包，则该属性是无关属性），函数依赖左半部都是唯一的。</p><ul><li><p>函数依赖集F及F中的函数依赖a-&gt;b</p><ul><li>如果A∈a并且F逻辑蕴含 (F-{a-&gt;b})∪(a-A)-&gt;b，则属性A在a中是无关的。</li><li>如果A∈b并且函数依赖集 (F-{a-&gt;b})∪a-&gt;(b-A)逻辑蕴含F，则属性A在b中是无关的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如，假设F包含AB-&gt;CD, A-&gt;E, E-&gt;C. 检验C在AB-&gt;CD中是否是无关的</span><br><span class="line">计算F&#x27;=&#123;A-&gt;E, E-&gt;C, AB-&gt;D&#125;下AB的闭包为ABCDE包含CD，所以是无关的</span><br></pre></td></tr></table></figure></li></ul></li><li><p>无损分解：把关系R投影到R1和R2上然后计算投影结果的自然连接，仍然能得到R。如果R1∩R2是R1或R2的超码，R上的分解就是无损分解。</p></li><li><p>保持依赖</p></li></ul><h5 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h5><ul><li><p>BCNF分解</p></li><li><p>3NF分解</p></li></ul><h5 id="使用多值依赖的分解"><a href="#使用多值依赖的分解" class="headerlink" title="使用多值依赖的分解"></a>使用多值依赖的分解</h5><ul><li><p>多值依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;-&gt;b</span><br><span class="line">关系r中任意一对满足t1[a]=t2[a]的元组对t1和t2,r中都存在元组t3和t4,使得</span><br><span class="line">t1[a]=t2[a]=t3[a]=t4[a]</span><br><span class="line">t3[b]=t1[b]</span><br><span class="line">t3[R-b]=t2[R-b]</span><br><span class="line">t4[b]=t2[b]</span><br><span class="line">t4[R-b]=t1[R-b]</span><br></pre></td></tr></table></figure></li><li><p>第四范式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数依赖和多值依赖集为D的关系模式r(R)属于第四范式的条件是，对D﹢中所有形如a-&gt;-&gt;b的多值依赖，至少有一下之一成立：</span><br><span class="line">a-&gt;-&gt;b是一个平凡的多值依赖</span><br><span class="line">a是R的一个超码</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计 E-R模型 关系数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系数据库</title>
      <link href="/2023/07/02/guan-xi-shu-ju-ku/"/>
      <url>/2023/07/02/guan-xi-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h4 id="码"><a href="#码" class="headerlink" title="码"></a>码</h4><ul><li><strong>超码</strong>：一个或多个属性的集合，这些属性的组合可以使我们在一个关系中<strong>唯一标识一个元组</strong>。</li><li><strong>候选码</strong>：最小超码称为候选码。</li><li><strong>主码</strong>：选中用来区分不同元组的候选码。</li><li><strong>外码</strong>：一个关系模式<code>r1</code>可能在它的属性中包括另一个关系模式<code>r2</code>的主码，这个属性在<code>r1</code>上称作参照<code>r2</code>的外码。</li></ul><h4 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h4><ul><li>选择（σ）：返回满足谓词的行</li><li>投影（π）：对输入关系的所有行输出指定属性。从输出中去除重复元组</li><li>自然连接（⋈）：两个关系相同名称的属性自动进行记录匹配，结果去除重复属性列</li><li>笛卡尔积（×）：两个关系中输出所有元组对（无论他们共同属性上的取值是否相同）</li><li>并（∪）：输出两个关系的元组的并</li></ul><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><h5 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h5><ul><li>数据定义语言：定义、删除、修改关系</li><li>数据操纵语言：插入、删除、修改元组</li><li>完整性</li><li>视图定义</li><li>事务控制：定义事务的开始和结束命令</li><li>嵌入式SQL和动态SQL</li><li>授权</li></ul><h5 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h5><ul><li><p><strong>基本类型</strong>：</p><table><thead><tr><th>类型</th><th>定义</th></tr></thead><tbody><tr><td>char(n)</td><td>固定长度字符串。会追加空格使其达到串长度。</td></tr><tr><td>varchar(n)</td><td>可变长度字符串。不会追加空格</td></tr><tr><td>int</td><td>整形</td></tr><tr><td>smallint</td><td>小整数类型</td></tr><tr><td>numeric(p,d)</td><td>定点数。p位数字，其中d位在小数点右边</td></tr><tr><td>real, double precision</td><td>浮点数和双精度浮点数</td></tr><tr><td>float(n)</td><td>精度至少为n的浮点数</td></tr></tbody></table></li><li><p><strong>基本模式定义</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table r</span><br><span class="line">(A1 D1,</span><br><span class="line">A2 D2,</span><br><span class="line">...</span><br><span class="line">An Dn,</span><br><span class="line">&lt;完整性约束k&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>完整性约束：<ul><li><code>primary key(a)</code>：主码</li><li><code>foreign key(a) references B</code>：外码</li><li><code>not null</code>：不允许空值</li></ul></li></ul><p>插入元组：<code>insert into r values(&#39;wang&#39;,&#39;a&#39;);</code></p><p>删除所有元组：<code>delete from r</code></p><p>删除关系：<code>drop table r</code></p><p>为关系添加属性：<code>alter table r add A D</code>,A为属性，D为属性的域</p><p>去掉属性：<code>alter table r drop A</code></p></li></ul><h5 id="查询的基本结构"><a href="#查询的基本结构" class="headerlink" title="查询的基本结构"></a>查询的基本结构</h5><ul><li>单关系查询：<code>select dept_name from department;</code><ul><li>强行删除重复：**<code>distinct</code>**</li><li>where 满足特定谓词：<code>select dept_name from department where ... ;</code></li></ul></li><li>多关系查询：把访问的关系都列在from中，where指定匹配条件</li><li>自然连接：**<code>natural join </code>**</li><li>指定列名连接：**<code>r1 join r2 using(A1, A2)</code>**</li></ul><h5 id="附加的基本运算"><a href="#附加的基本运算" class="headerlink" title="附加的基本运算"></a>附加的基本运算</h5><ul><li><p>更名运算：<code>old-name as new-name</code>，可以出现在<code>select</code>和<code>from</code>中。方便使用；适用于比较同一关系中元组的情况，便于区分。</p></li><li><p>字符串运算：使用<code>Like</code>操作实现模式匹配，模式是大小写敏感的</p><ul><li><code>%</code>：匹配任意子串</li><li><code>_</code>：匹配任意一个字符</li><li>使用<code>escape</code>定义转义字符。<code>like &#39;ab\%cd%&#39; escape &#39;\&#39;  匹配ab%cd开头字符串   </code></li></ul></li><li><p>正则表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mysql使用REGEXP</span><br><span class="line"></span><br><span class="line">^:匹配开始位置</span><br><span class="line">[A-Za-z]:匹配大小写字母</span><br><span class="line">[A-Za-z0-9_.-]:匹配字母(大写或小写)、数字、下划线 _、句点.和/或横杠-的字符串</span><br><span class="line">*:匹配前面的子表达式零次或多次</span><br><span class="line">@leetcode[.]com:匹配@leetcode.com</span><br><span class="line">$:匹配结尾</span><br><span class="line"></span><br><span class="line">where mail REGEXP &#x27;^[A-Za-z][A-Za-z0-9_.-]*@leetcode[.]com$&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>排序：**<code>order by </code>** 默认升序，可以用<code>desc</code>表示降序，<code>asc</code>表示升序</p></li><li><p>where子句谓词：</p><ul><li><code>between A and B  表示一个值属于[A,B]</code></li><li><code>and   增加一个条件</code></li><li>元组比较运算：<code>(a1,a2) &lt;= (b1,b2) 表示a1&lt;=b1且a2&lt;=b2时为真</code></li></ul></li></ul><h5 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h5><ul><li><code>union</code>：并。自动去重复，保留重复必须用<code>union all</code></li><li><code>intersect</code>：交。</li><li><code>except</code>：差。</li></ul><h5 id="空值"><a href="#空值" class="headerlink" title="空值"></a><strong>空值</strong></h5><ul><li>算数运算：任一输入为空，结果为空</li><li>比较运算：涉及空值的比较运算结果为<code>unknown</code>，where子句谓词对一个元组计算出false或unknown都不能加入到结果集中。在谓词中<code>null = null</code>会返回unknown，而不是true。</li><li>集合运算</li></ul><h5 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a><strong>聚集函数</strong></h5><p>以值的一个集合为 输入，返回单个值的函数。例如：<code>avg,min,max,sum,count</code></p><ul><li><p>基本聚集：计算元组个数使用<code>count(*)</code>，使用<code>count(*)</code>时不允许使用<code>distinct</code></p></li><li><p>分组聚集：<code>group by</code>给出一个或多个属性来构造分组。注意：出现在<code>select</code>中但是没有被聚集的属性只能是出现在<code>group by</code>子句中的那些属性。换句话说，任何没有出现在group by 中的属性如果出现在select 中的话，只能出现在聚集函数内部。</p></li><li><p>having 子句：对分组限定条件，跟在<code>group by</code>后面。<strong>having中的谓词在形成分组后才起作用，所以可以使用聚集函数</strong>。出现在<code>having</code>中但是没有被聚集的属性只能是出现在<code>group by</code>子句中的那些属性</p></li><li><p>操作序列</p><ul><li>满足where谓词的元组通过group by子句形成分组</li><li>如果出现了having子句，它将应用到每个分组上</li></ul></li><li><p>对空值和布尔值的聚集：除了<code>count(*)</code>外所有聚集函数都<strong>忽略空值</strong>。空集的count运算值为0，其他聚集函数输入为空集情况下返回一个空值。</p></li></ul><h5 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a><strong>嵌套子查询</strong></h5><ul><li><p>集合成员资格：<code>in</code>测试元组是否是集合中的成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct ID)</span><br><span class="line">from takes</span><br><span class="line">where (course_id,sec_id) in (select course_id,sec_id</span><br><span class="line">from teaches</span><br><span class="line">where tesches.ID = 10101);</span><br></pre></td></tr></table></figure></li><li><p>集合的比较：</p><ul><li><p>至少比某一个大: <code>&gt; some</code>, 也允许<code>&lt; some, &lt;= some, &gt;=some, =some等价于in, &lt;&gt; some并不等价于not in</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; some(select salary</span><br><span class="line">from instructor</span><br><span class="line">where dept_name = &#x27;Biology&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>比所有的都大：<code>&gt; all</code>, <code>&lt;&gt; all等价于not in, =all不等价于in</code></p></li></ul></li><li><p>空关系测试：子查询结果集中是否存在元组：<code>exists</code>，非空返回true；可将关系A包含关系B写成<code>not exists(B except A)</code></p></li><li><p>重复元组存在性测试：<code>unique</code>，没有重复返回true；</p></li><li><p>from子句中的子查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, avg_salary</span><br><span class="line">from (select dept_name,avg(salary)</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name</span><br><span class="line">as dept_avg(dept_name,avg_salary)) --as给子查询的结果关系起名字并对属性重命名</span><br><span class="line">where avg_salary &gt; 4200;</span><br></pre></td></tr></table></figure><p>from子句嵌套的子查询中不能使用来自from子句其他关系的相关变量，想要实现此操作需要以**<code>lateral</code>**作为前缀，只有少数数据库支持。</p></li><li><p>with子句：定义临时关系，只对包含with子句的查询有效。例如找出最大预算值的系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with max_budget(value) as</span><br><span class="line">(select max(budget)</span><br><span class="line">from department)</span><br><span class="line">select budget</span><br><span class="line">from department,max_budget</span><br><span class="line">where department.budget = max_budget.value;</span><br></pre></td></tr></table></figure></li><li><p>标量子查询：返回包含单个属性的单个元组，可以出现在任何地方</p></li></ul><h5 id="数据库的修改"><a href="#数据库的修改" class="headerlink" title="数据库的修改"></a>数据库的修改</h5><ul><li><p>删除：<code>delete</code>删除元组, 只能作用于一个关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from r</span><br><span class="line">where P；</span><br></pre></td></tr></table></figure></li><li><p>插入：<code>insert</code>, 单个元组插入请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into r</span><br><span class="line">values(&#x27;101&#x27;,&#x27;DS&#x27;,4);</span><br><span class="line"></span><br><span class="line">insert into r</span><br><span class="line">select *</span><br><span class="line">from s</span><br><span class="line">where P;</span><br></pre></td></tr></table></figure></li><li><p>更新：<code>update</code>, 改变元组部分属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update r</span><br><span class="line">set course_id = &#x27;102&#x27;</span><br><span class="line">where P;</span><br></pre></td></tr></table></figure></li><li><p>case语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">when pred1 then ret1</span><br><span class="line">when pres2 then ret2</span><br><span class="line">else retn</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><h4 id="中级SQL"><a href="#中级SQL" class="headerlink" title="中级SQL"></a>中级SQL</h4><h5 id="连接表达式"><a href="#连接表达式" class="headerlink" title="连接表达式"></a><strong>连接表达式</strong></h5><ul><li><p>连接条件：<code>on</code>可以指定任意的连接条件, 出现在连接表达式的末尾</p><p><code>on</code>和<code>where</code>在外连接中的表现不同：on条件是外连接声明的一部分，where子句却不是。具体表现就是使用<code>on</code>会补上空值的元组，<code>where</code>会排除条件为假的元组。</p></li><li><p>外连接：通过在结果中创建空值元组的方式，保留连接中丢失的元组</p><ul><li><p>左外连接：只保留出现在左外连接运算之前左边关系的元组,其余属性为空值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from student left outer join takes;</span><br></pre></td></tr></table></figure></li><li><p>右外连接：保留右边  <code>right outer join</code></p></li><li><p>全外连接：两边都保留 <code>full outer join</code></p></li></ul></li></ul><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a><strong>视图</strong></h5><ul><li><p>从基本表中导出的虚拟的表，数据库存储视图定义本身，而不存储执行结果。</p><ul><li><p>视图定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create view view_name as</span><br><span class="line">&lt;query ecpression&gt;;</span><br></pre></td></tr></table></figure></li><li><p>物化视图：允许存储视图关系，但是必须保证：定义视图的实际关系变化时，视图也随之修改。物化视图查询很快，避免了读取大量底层关系。</p></li><li><p>视图更新：一般不允许对视图关系进行修改</p><ul><li><p>视图可更新的条件</p><ul><li><p>from子句中只有一个关系</p></li><li><p>select子句中只包含关系的属性名，不包含任何表达式、聚集或distinct声明</p></li><li><p>任何没有出现在select子句中的属性可以取空值</p></li><li><p>查询中不包含group by或having子句</p></li></ul></li></ul></li></ul></li></ul><h5 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a><strong>完整性约束</strong></h5><p>防止对数据的意外破坏。作用于创建关系命令的一部分被声明，也可以通过<code>alter table table_name add ...</code>命令施加到关系上</p><ul><li><code>not null</code>：禁止主码出现空值，因此主码不必再显式声明为not null</li><li><code>unique( A1,A2,...)</code>：声明属性形成一个<strong>候选码</strong>，没有两个元组能在所列出的属性上取值相同. 候选码属性可以为null，因为空值不等于其他任何值</li><li><code>check( &lt;谓词&gt; )</code>：保证属性值满足指定的条件。例如：<code>check(budget&gt;0)</code></li><li>参照完整性：外码<code>foreign key(dept_name) references department</code><ul><li>违反参照完整性时，通常是拒绝执行，但<code>foreign key</code>可以指明进一步修改参照关系的元组来恢复参照完整性，例如<ul><li>级联<code>on delete/update cascade</code></li><li>其他，可将参照域设为null <code>set null代替cascade</code>，或者设置为域的默认值<code>set default</code></li></ul></li></ul></li></ul><h5 id="SQL数据类型与模式："><a href="#SQL数据类型与模式：" class="headerlink" title="SQL数据类型与模式："></a><strong>SQL数据类型与模式</strong>：</h5><ul><li><p>日期和时间：<code>data:日期; time:时间; timestamp:data于time的组合</code></p></li><li><p>默认值：<code>default 0:默认值为0</code></p></li><li><p>创建索引：高效的查找而不用扫描关系中的所有元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index student_index on student(ID);</span><br></pre></td></tr></table></figure></li><li><p>大对象类型：例如图片等。字符数据的大对象数据类型（clob）、二进制数据的大对象数据类型（blob）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book_review clob (10KB)</span><br><span class="line">image blob (10MB)</span><br></pre></td></tr></table></figure></li><li><p>用户定义类型</p><ul><li><p>独特类型：</p><ul><li><p>定义新类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create type Dollars as numeric(12,2) final; --Dollars定义为numeric(12,2)</span><br></pre></td></tr></table></figure></li><li><p>类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast(budget to numeric(12,2))</span><br></pre></td></tr></table></figure></li><li><p>删除和修改创建过的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop/alter type</span><br></pre></td></tr></table></figure></li><li><p>定义域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create domain DDolars as numeric(12,2) not null;</span><br></pre></td></tr></table></figure><p>域和类型区别：</p><ol><li>域上可以声明约束和默认值</li><li>域并不是强制类型的，一个域类型的值可以被赋给另一个域类型，只要它们基本类型相容</li></ol></li><li><p>创建模式相同的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table temp_r like r; --创建temp_r具有与r相同的模式</span><br><span class="line">create table t as</span><br><span class="line">(select *</span><br><span class="line">from r</span><br><span class="line">where ...</span><br><span class="line">)</span><br><span class="line">with data; --表t被创建，同时载入数据</span><br></pre></td></tr></table></figure></li></ul></li><li><p>结构化数据类型</p></li></ul></li></ul><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a><strong>授权</strong></h5><ul><li><p>权限的授予与收回：默认情况下，被授予权限的用户&#x2F;角色无权将权限再授予其他用户&#x2F;角色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &lt;权限列表&gt;--select/insert/update/delete</span><br><span class="line">on &lt;关系/视图&gt;</span><br><span class="line">to &lt;用户/角色列表&gt;;   --public指系统的所有当前用户和将来的用户</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revoke &lt;权限列表&gt;</span><br><span class="line">on &lt;关系/视图&gt;</span><br><span class="line">from &lt;用户/角色列表&gt;;</span><br></pre></td></tr></table></figure></li><li><p>角色：</p><ul><li>创建角色：<code>create role instrutor;</code></li><li>授予权限：同上</li><li>角色可以授予用户&#x2F;角色：<code>grant A to B;</code></li></ul></li><li><p>权限的转移：允许将得到的权限传递给其他用户，需要附加<code>with grant option</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on department to Amit with grant option;</span><br></pre></td></tr></table></figure></li><li><p>权限的收回：大多数数据库系统中，权限收回默认是级联的。可以申明<code>restrict</code>防止级联收回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke select on departmnet from Amit restrict;--防止级联收回</span><br></pre></td></tr></table></figure></li></ul><h4 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h4><h5 id="函数和过程"><a href="#函数和过程" class="headerlink" title="函数和过程"></a><strong>函数和过程</strong></h5><ul><li><p>声明和调用函数和过程</p><p>输入自己的函数和过程通常用<code>create or replace</code>对旧代码替换。SQL支持函数重载</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//函数：给定系名返回教师数目</span><br><span class="line">create function dept_count(dept_name varchar(20))</span><br><span class="line">returns integer</span><br><span class="line">begin</span><br><span class="line">declare d_count integer;</span><br><span class="line">select count(*) into d_count</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dpt_name = dept_name</span><br><span class="line">return d_count;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//过程：in和out 分别表示参数和返回值</span><br><span class="line">create procedure dept_count(in dept_name varchar(20),out d_count integer)</span><br><span class="line">begin</span><br><span class="line">select count(*) into d_count</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dept_name = dept_name</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>​表函数：返回关系作为结果的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create function instrutor_of(dept_name varchar(20))</span><br><span class="line">return table(</span><br><span class="line">ID varchar(5),</span><br><span class="line">name varchar(20))</span><br><span class="line">return table</span><br><span class="line">(select ID,name</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dept_name = dept_name);</span><br></pre></td></tr></table></figure><p>​使用<code>call</code>调用</p><ul><li><p>支持过程和函数的语言构造</p><ul><li><p>变量声明<code>declare d_cnt integer</code></p></li><li><p>变量赋值<code>set d_cnt = 10</code></p></li><li><p><code>while</code>和<code>repeat</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while 布尔表达式 do</span><br><span class="line">语句序列;</span><br><span class="line">end while</span><br><span class="line">repeat</span><br><span class="line">语句序列;</span><br><span class="line">until 布尔表达式</span><br><span class="line">end repeat</span><br></pre></td></tr></table></figure></li><li><p><code>if-then-else</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式</span><br><span class="line">than 语句</span><br><span class="line">elseif 布尔表达式</span><br><span class="line">than 语句</span><br><span class="line">else 语句</span><br><span class="line">end if</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h5><p>触发器是一条语句，当对数据库进行修改时，系统自动执行。</p><p>设置触发器必须满足两个条件：1、指明什么条件下执行触发器。2、指明触发器执行时的动作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create trigger check after insert on section--插入元组后启动触发器</span><br><span class="line">referencing new row as nrow--建立一个过渡变量用来在插入完成后存储所插入值</span><br><span class="line">for each row--插入多个元组时，可以显式迭代每一个元组</span><br><span class="line">when (nrow.id not in(--when指定一个条件</span><br><span class="line">select slot_id</span><br><span class="line">from slot))</span><br><span class="line">begin--触发器执行</span><br><span class="line">rollback--回滚</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 指定哪个属性更新执行触发器</span><br><span class="line">after updata of takes on grade</span><br></pre></td></tr></table></figure><h4 id="形式化关系查询语言"><a href="#形式化关系查询语言" class="headerlink" title="形式化关系查询语言"></a>形式化关系查询语言</h4><h5 id="关系代数-1"><a href="#关系代数-1" class="headerlink" title="关系代数"></a>关系代数</h5><ul><li>基本运算：选择（σ）、投影（Π）、并、集合差、笛卡儿积、更名运算（ρ）</li><li>附加的关系代数运算：集合交运算、自然连接、theta连接、赋值运算、外连接</li><li>拓展的关系代数运算：广义投影（允许投影列表中使用算数运算和字符串函数）、聚集</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/06/23/c/"/>
      <url>/2023/06/23/c/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>预处理器</strong>：</p><p><code>#define</code> 指令把一个名字设定为预处理变量</p><p><code>#ifdef</code> 当且仅当变量已定义时为真，<code>#ifndef</code> 当且仅当变量未定义时为真。一旦结果为真则执行后续操作直到遇到<code>#endif</code>指令为止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">std::string bookNo;</span><br><span class="line">unsigned units_sold  = 0;</span><br><span class="line">double revenue = 0.0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>第一次包含<code>Sales_data.h</code>时，<code>#ifndef</code>检查结果为真，预处理器执行后面操作直到遇到<code>#endif</code>。此时SALES_DATA_H值变为已定义，<code>Sales_data.h</code>也会被拷贝到程序中。后面再次包含<code>Sales_data.h</code>时检查结果为假，编译器忽略。</p></li><li><p><strong>声明和定义</strong>： </p><ul><li><p>声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含那个名字的声明。定义负责创建与名字关联的实体。声明规定了变量的类型和名字，定义还申请存储空间，也可能赋一个初值。</p></li><li><p>想声明而非定义变量，就在变量名前添加关键字<code>extern</code>, 而且不要显式地初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明</span><br><span class="line">int j; //定义</span><br><span class="line">extern int i = 1; //定义 任何包含显式初始化的声明成为定义</span><br></pre></td></tr></table></figure></li><li><p>多个文件中使用同一个变量，就必须声明和定义分离。此时，定义必须出现且只能出现在一个文件中，其他文件中对其声明。</p></li></ul></li><li><p><strong>复杂的数组声明</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *ptrs[10];//从右往左理解，表示含有十个整型指针的数组</span><br><span class="line">int (*parray)[10] = &amp;arr;//从内往外理解，parray指向一个含有10个整数的数组</span><br><span class="line">int (&amp;arrref)[10] = arr;//从内往外理解，arrref引用一个含有10个整数的数组</span><br><span class="line">int *(&amp;array)[10] = ptrs;//array是数组的引用，该数组含有10个指针</span><br></pre></td></tr></table></figure></li><li><p><strong>指针与引用</strong>：</p><ul><li><p>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针生命周期内它可以先后指向不同的对象。</p></li><li><p>指针无需再定义时赋初值。</p></li><li><p>引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p></li><li><p>一旦定义引用就无法再绑定到另外的对象，之后每次使用这个引用都是访问最初绑定的对象。</p></li><li><p>指向指针的引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int *p;//p是指针</span><br><span class="line">int *&amp;r = p;//r是一个对指针p的引用. 从右往左，首先r是一个引用，然后引用的是一个int指针</span><br><span class="line">r = &amp;i;//r引用了一个指针，和r赋值&amp;i就是另p指向i</span><br><span class="line">*r = 0;//解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>深拷贝和浅拷贝</strong>：</p><ul><li><p>浅拷贝：简单的赋值拷贝操作</p></li><li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">//浅拷贝</span><br><span class="line">Person(int age ,int height) &#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = height;</span><br><span class="line">&#125;</span><br><span class="line">//深拷贝</span><br><span class="line">Person(int age ,int height) &#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = new int(height);</span><br><span class="line">&#125;</span><br><span class="line">//析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">if (m_height != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">int* m_height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数指针</strong>：指向函数的指针。函数的类型由返回类型和形参类型共同决定，与函数名无关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool (*pf)(const int&amp; a, const int&amp; b);//函数指针，pf指向一个函数，返回值是bool类型</span><br><span class="line">bool *pf(const int&amp; a, const int&amp; b);//指针函数，名为pf的函数，返回bool*</span><br><span class="line"></span><br><span class="line">bool compare(const int&amp; a, const int&amp; b);</span><br><span class="line">//把函数名作为一个值使用时，该函数自动转换成指针</span><br><span class="line">pf = compare;//pf指向名为compare的函数</span><br><span class="line">pf = &amp;compare;//等价，取地址符是可选的</span><br></pre></td></tr></table></figure></li><li><p><strong><code>const</code>作用</strong>：</p><ol><li><p>定义常量</p></li><li><p>类型检查。const与#define定义常量的区别：const常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，只是简单的字符替换，不能进行安全检查。</p></li><li><p>修饰指针，分为指向常量的指针和指针常量</p></li><li><p>常量引用，经常用于形参，既避免了拷贝，又避免了函数对值的修改</p></li><li><p>修饰成员函数，说明成员函数内不能修改成员变量</p></li></ol></li><li><p><strong><code>const</code>的引用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line">const int &amp;r1 = ci;// 正确，引用及其对象都是常量</span><br><span class="line">int &amp;r2 = ci;// 错误，试图让一个非常量引用指向一个常量对象</span><br><span class="line"></span><br><span class="line">int i = 42;</span><br><span class="line">const int &amp;r3 = i;// 正确，允许将const int&amp;绑定到一个普通int对象上</span><br></pre></td></tr></table></figure></li><li><p>**指针和<code>const</code>**：</p><ul><li><p><strong>指向常量的指针（<code>pointer to const</code>）</strong>: 不能用于改变其所指对象的值。要想存放常量对象地址，只能使用指向常量的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int *a;//指向常量的指针</span><br><span class="line">int const *a;//同上。cosnt位于*的左侧，则const用来修饰指针指向的变量</span><br><span class="line">*a = 10;//错误</span><br><span class="line"></span><br><span class="line">//允许把非const对象地址赋给指向const对象的指针</span><br><span class="line">const int *ptr;</span><br><span class="line">int val = 3;</span><br><span class="line">ptr = &amp;val;//正确，但是不能通过ptr指针修改val</span><br></pre></td></tr></table></figure></li><li><p><strong><code>const</code>指针（<code>const pointer</code>）</strong>：常量指针，必须初始化且初始化后值不能再改变。把*放在<code>const</code>之前说明指针是一个常量，意味着不变的是指针本身的值而非指向的那个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;</span><br><span class="line">int *const cur = &amp;num;//cur 将一直指向num</span><br><span class="line">//从右往左阅读，离cur最近的是const，意味着cur本身是一个常量对象，对象的类型为int*，</span><br><span class="line">//即cur是一个常量指针，该常量指针指向一个int对象</span><br><span class="line"></span><br><span class="line">const double pi = 3.14;</span><br><span class="line">const double *const pip = &amp;pi;//pip是一个指向常量对象的常量指针</span><br><span class="line">//pip本身是一个常量对象，对象类型是const double*，表示pip是一个指向常量的常量指针</span><br></pre></td></tr></table></figure></li></ul></li><li><p>**顶层<code>const</code>**：顶层<code>const</code>表示指针本身是常量，底层<code>const</code>表示指针所指对象是一个常量。更一般的，顶层<code>const</code>可以表示任意的对象是常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *const p1 = &amp;i;//不能改变p1的值，顶层const</span><br><span class="line">const int ci = 42;//不能改变ci的值，顶层const</span><br><span class="line">const int *p2 = &amp;ci;//允许改变p2的值，底层const</span><br><span class="line">const int *const p3 = p2;//靠右的const的顶层，靠左的是底层</span><br><span class="line">const int &amp;r = ci;//声明引用的const都是底层</span><br></pre></td></tr></table></figure><p>拷贝操作时，顶层<code>const</code>不受影响，底层<code>const</code>必须具有相同的底层<code>const</code>资格，一般来说非常量可以转换成常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = ci;//正确</span><br><span class="line">p2 = p3;//正确，p2和p3指向对象类型相同，p3顶层const部分不影响</span><br><span class="line"></span><br><span class="line">int *p = p3;//错误，p3包含底层const定义而p没有</span><br><span class="line">p2 = &amp;i;//正确，int*能转换成const int*</span><br><span class="line">int &amp;r = ci;//错误，普通的int不能绑定到int常量上</span><br><span class="line">const int &amp;r2 = i;//正确，const int&amp;可以绑定到普通的int上</span><br></pre></td></tr></table></figure></li><li><p><strong>static</strong>：</p><ul><li><p>静态变量：变量声明为static时，空间将在程序的生命周期内分配，只分配一次。类中的静态变量由对象共享，不能使用构造函数初始化，应使用类外的类名和范围解析运算符显式初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Apple&#123;</span><br><span class="line">public:</span><br><span class="line">static int i;</span><br><span class="line">&#125;</span><br><span class="line">int Apple::i = 0;</span><br></pre></td></tr></table></figure></li><li><p>静态成员：</p><ul><li>类对象为静态：对象的生命周期直到程序结束。</li><li>类中的静态函数：允许静态成员函数仅访问静态数据成员和其他静态成员函数，无法访问非静态成员和函数。</li></ul></li></ul></li><li><p><strong>重载和<code>const</code>形参</strong>：</p><ul><li><p>顶层<code>const</code>不影响传入函数的对象。一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(Phone);</span><br><span class="line">Record lookup(cosnt Phone);//重复声明</span><br><span class="line"></span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(Phone* const);//重复声明</span><br></pre></td></tr></table></figure></li><li><p>如果形参是指针或引用，则区分其指向常量对象还是非常量对象可以实现函数重载，此时<code>const</code>是底层的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(Phone&amp;);</span><br><span class="line">Record lookup(cosnt Phone&amp;);//新函数，作用于常量引用</span><br><span class="line"></span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(const Phone*);//新函数，作用于指向常量的指针</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>this</code>指针</strong>：作用在类内部，当类的非静态成员函数中访问类的非静态成员的时候，编译器自动将对象本身地址作为一个隐含参数传递给函数。</p><ul><li><p>在类的非静态成员函数中返回类对象本身的时候，直接使用<code>return *this</code>.</p></li><li><p>参数与变量名相同时，必须<code>this-&gt;n = n</code>。</p></li><li><p><code>this</code>指针会被编译器解析为<code>A *const</code>。</p></li><li><p><code>this</code>是右值</p></li></ul></li><li><p>**<code>inline</code>**：内联能提高函数效率，但是内联是以代码膨胀为代价的，仅仅省区函数调用的开销从而提高执行效率。不适合使用内联：函数体内代码比较长；函数体内出现循环。</p><ul><li><p>虚函数（virtual）和内联（inline）：</p><ul><li><p>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联。内联是编译期间，虚函数多态在运行期间，编译器无法知道运行期间用哪个代码，因此虚函数表现多态时不可以内联。</p></li><li><p><code>inline virtual</code>唯一可以内联时候：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p></li></ul></li></ul></li></ul><p>​      </p><ul><li><p>**<code>class</code>和<code>struct</code>**：唯一区别是默认访问权限不一样，<code>struct</code>默认<code>public</code>，<code>class</code>默认<code>private</code>。</p></li><li><p>**<code>union</code>**：一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。</p></li><li><p><strong><code>sizeof</code>类大小计算</strong>：</p><ul><li>空类大小为1字节</li><li>一个类中，成员函数、静态数据成员不占存储空间</li><li>不管多少个虚函数只有一个虚指针的大小</li><li>派生类继承了所有基类的函数和成员，按照字节对齐计算大小。虚函数都是继承基类的虚指针。</li></ul></li><li><p>**<code>extern &quot;C&quot;</code>**：告诉编译器按照C的方式编译。</p><ul><li><p>C++调用C函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern int add(...)</span><br><span class="line"></span><br><span class="line">//xx.c</span><br><span class="line">int add()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//xx.cpp</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    #include &quot;xx.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C调用C++函数：<code>extern &quot;C&quot;</code>在C中是语法错误，需要放在C++头文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">    int add();</span><br><span class="line">&#125;</span><br><span class="line">//xx.cpp</span><br><span class="line">int add()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//xx.c</span><br><span class="line">extern int add();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>lambda表达式</strong>：</p><p><strong>[ capture list ]   ( parameter list )  -&gt;  return type   { function body }</strong></p><p>capture list:捕获列表；parameter list：参数列表；return type：返回类型；function body：函数体</p><p>我们可以忽略参数列表和返回类型，但必须包含捕获列表和函数体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto f = [] &#123;return 42;&#125;//忽略括号和参数列表等价于指定一个空参数列表</span><br><span class="line">cout&lt;&lt;f()&lt;&lt;endl;//输出42</span><br><span class="line">[] (const string&amp; a,const string&amp; b) &#123;return a.size()&lt;b.size();&#125;</span><br></pre></td></tr></table></figure><p>lambda捕获列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]空捕获列表。lambda不能使用所在函数中的变量</span><br><span class="line">[names]names是一个逗号分隔的名字列表，都是所在函数的局部变量，默认情况下捕获列表中的变量都被拷贝。名字前加&amp;，则采用引用捕获方式。</span><br><span class="line">[&amp;]隐式捕获列表，采用引用捕获方式，使用所在函数的实体的引用</span><br><span class="line">[=]隐式，采用值捕获方式，拷贝所在函数的实体的值</span><br><span class="line">[&amp;,names]names采用值捕获方式，不能加&amp;</span><br><span class="line">[=,names]names采用引用方式捕获，必须加&amp;</span><br></pre></td></tr></table></figure></li><li><p><strong>智能指针</strong>：</p><ul><li><p><code>shared_ptr</code>：允许多个指针指向同一个对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; sp;//空指针，可以指向类型为T的对象</span><br><span class="line">p.get();//返回p中保存的指针</span><br><span class="line">make_shared&lt;T&gt; (args);//返回一个shared_ptr，指向一个动态分配类型为T的对象。使用args初始化对象。最安全的分配</span><br><span class="line">shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(42);</span><br><span class="line">shared_ptr&lt;T&gt; p(q);//p是shared_ptr的拷贝</span><br><span class="line">p = q;//此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0则将其管理的原内存释放</span><br><span class="line">p.use_count();//若p.use_count()为1，返回true</span><br><span class="line">p.unique();//返回p共享对象的智能指针数量</span><br></pre></td></tr></table></figure></li><li><p><code>unique_ptr</code>：独占所指向对象。不支持普通的拷贝或赋值操作，但是可以通过release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr。不能拷贝的规则有一个例外：可以拷贝或赋值一个将要被销毁的unique_ptr，如返回局部对象的拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; p(new int(42));</span><br><span class="line">unique_ptr&lt;int&gt; p1(p2);//错误，不支持拷贝</span><br><span class="line">p1 = p2;//错误，不支持赋值</span><br><span class="line">unique_ptr&lt;int&gt; p2(p1.release());//将所有权从p1转移给p2。release将p1置空</span><br><span class="line">p2.reset(p3.release());//将所有权从p3转移给p2。reset释放了p2原来指向内存</span><br></pre></td></tr></table></figure></li><li><p><code>weak_ptr</code>：弱引用，指向<code>shared_ptr</code>所管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto p = make_shared&lt;int&gt;(42);</span><br><span class="line">weak_ptr&lt;int&gt; wp(p);//wp弱共享p，p引用计数不变</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多态性</strong>：</p><ul><li>静态绑定：编译时把调用函数名与具体函数绑定到一起。通过函数重载和运算符重载实现。</li><li>动态绑定：运行时绑定。通过继承和虚函数实现。</li></ul></li><li><p><strong>运算符重载</strong>：</p><ul><li><p>类运算符重载形式（二元）</p><ul><li><p>非静态成员运算符重载：参数比实际参数少一个，第一个参数以this指针隐式传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex operator+(Complex b)&#123;……&#125;</span><br></pre></td></tr></table></figure></li><li><p>友元运算符重载：参数个数与实际运算的参数个数相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">friend Complex operator+(Complex a,Complex b);//声明</span><br><span class="line">Complex  operator+(Complex a,Complex b)&#123;……&#125;//定义</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一元运算符：作为类成员函数重载时不需要参数，通过this指针隐式传递</p><ul><li><p>前自增&#x2F;减 与 后自增&#x2F;减：通过在运算符函数参数表中是否插入关键字int 来区分这两种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//前缀</span><br><span class="line">operator -- ();</span><br><span class="line">operator -- (X &amp; x);</span><br><span class="line">//后缀</span><br><span class="line">operator -- (int);</span><br><span class="line">operator -- (X &amp; x, int);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重载赋值运算符”&#x3D;”：只能用成员函数重载</p></li><li><p>重载”[]”：</p><ul><li>是一个二元运算符，<code>X&amp; operator[](int n);</code></li><li>[]既可以出现在赋值符“&#x3D;”的左边，也可以出现在赋值符“&#x3D;”的右边，所以重载运算符[]时常返回引用。</li><li>[]只能被重载为类的非静态成员函数，不能被重载为友元和普通函数。</li></ul></li><li><p>重载”()”：只能被重载为类的成员函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X&amp; operator( )(参数表);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>模板</strong>：</p><ul><li><p>函数模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T1, class T2,…&gt;</span><br><span class="line">返回类型 函数名(参数表)&#123;</span><br><span class="line">   …… //函数模板定义体</span><br><span class="line">&#125;</span><br><span class="line">//T1,T1...是模板参数, class/typename表示其后参数可以是任意类型</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T min(T a, T b)&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>类模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1,class T2,…&gt;</span><br><span class="line">class 类名&#123;</span><br><span class="line">    ……// 类成员的声明与定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring6</title>
      <link href="/2023/06/23/spring6/"/>
      <url>/2023/06/23/spring6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://docs.spring.io/spring-framework/reference/index.html">Spring Framework</a></p><p><strong>Spring Framework特点</strong></p><ul><li>非侵入式</li><li>控制反转：IoC-Inversion of Control, 翻转资源获取方向，把自己创建资源，从环境获取资源变成环境把资源准备好，我们享受资源注入</li><li>面向切面编程：AOP-Aspact Oriented Programming, 在不修改资源代码基础上增加代码功能</li><li>容器：Spring IoC是一个容器，因为他包含并且管理组件对象的生命周期</li><li>组件化</li><li>一站式</li></ul><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="容器：IoC"><a href="#容器：IoC" class="headerlink" title="容器：IoC"></a>容器：IoC</h2><p>Spring <strong>通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系</strong>。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。</p><h3 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h3><p>IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p><ul><li><p>控制反转是一种思想。</p></li><li><p>控制反转是为了降低程序耦合度，提高程序扩展力。</p></li><li><p>控制反转，反转的是什么？</p><p>将对象的创建权利交出去，交给第三方容器负责。将对象和对象之间关系的维护权交出去，交给第三方容器负责。</p></li><li><p>控制反转这种思想如何实现呢？</p><p>DI（Dependency Injection）：依赖注入</p></li></ul><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p><p>依赖注入实现了控制反转的思想。</p><p>指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</p><h3 id="IoC容器在Spring中的实现"><a href="#IoC容器在Spring中的实现" class="headerlink" title="IoC容器在Spring中的实现"></a>IoC容器在Spring中的实现</h3><p><strong>SpringIoc容器接口</strong>： </p><p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！</p><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p><ul><li>更容易与 Spring 的 AOP 功能集成</li><li>消息资源处理（用于国际化）</li><li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></li></ul><p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集！</p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>AnnotationConfigApplicationContext</td><td>通过读取Java配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table><h3 id="Spring-IoC-x2F-DI-实现步骤"><a href="#Spring-IoC-x2F-DI-实现步骤" class="headerlink" title="Spring IoC &#x2F; DI 实现步骤"></a>Spring IoC &#x2F; DI 实现步骤</h3><ol><li><p><strong>配置元数据（配置）</strong></p><p> 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种：xml，注解，配置类。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">1</span>] <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">2</span>]&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>id</code> 属性是标识单个 Bean 定义的字符串。</li><li><code>class</code> 属性定义 Bean 的类型并使用完全限定的类名。</li></ul></li><li><p><strong>实例化IoC容器</strong></p><p> 提供给 <code>ApplicationContext</code> 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code> 等）加载配置元数据。</p><p> 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取Bean（组件）</strong></p><p> <code>ApplicationContext</code> 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> ，您可以检索 bean 的实例。</p><p> 允许读取 Bean 定义并访问它们，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取ioc容器的组件对象</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"><span class="comment">//使用组件对象</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure></li></ol><h3 id="基于XML管理Bean"><a href="#基于XML管理Bean" class="headerlink" title="基于XML管理Bean"></a>基于XML管理Bean</h3><ol><li>所有内容写到xml格式配置文件中</li><li>声明bean通过&lt;bean标签</li><li>&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref</li><li>引入外部的properties文件可以通过&lt;context:property-placeholder</li><li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li></ol><h4 id="组件信息声明配置（IoC）"><a href="#组件信息声明配置（IoC）" class="headerlink" title="组件信息声明配置（IoC）"></a>组件信息声明配置（IoC）</h4><p><strong>基于无参数构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;happyComponent&quot;</span> class=<span class="string">&quot;com.atguigu.ioc.HappyComponent&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><ul><li>bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息</li><li>id属性：bean的唯一标识,方便后期获取Bean！</li><li>class属性：组件类的全限定符！</li><li>注意：要求当前组件类必须包含无参数构造函数！</li></ul><p><strong>基于静态工厂方法实例化</strong></p><ol><li><p>准备组件类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientService</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ClientService</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title function_">createInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> clientService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml配置文件编写</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>class属性：指定工厂类的全限定符！</li><li>factory-method: 指定静态工厂方法，注意，该方法必须是static方法。</li></ul></li></ol><p><strong>基于实例工厂方法实例化</strong></p><ol><li><p>准备组建类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServiceLocator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">static</span> <span class="variable">ClientServiceImplclientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> clientService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml配置文件编写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将工厂类进行ioc配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>factory-bean属性：指定当前容器中工厂Bean 的名称。</li><li>factory-method:  指定实例工厂方法名。注意，实例方法必须是非static的！</li></ul></li></ol><h4 id="组件依赖注入配置（DI）"><a href="#组件依赖注入配置（DI）" class="headerlink" title="组件依赖注入配置（DI）"></a>组件依赖注入配置（DI）</h4><h5 id="基于setter方法完成"><a href="#基于setter方法完成" class="headerlink" title="基于setter方法完成"></a><strong>基于setter方法完成</strong></h5><ol><li><p>生成对应setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String movieName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieName</span><span class="params">(String movieName)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.movieName = movieName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleMovieLister&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.SimpleMovieLister&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- setter方法，注入movieFinder对象的标识id</span></span><br><span class="line"><span class="comment">       name = 属性名  ref = 引用bean的id值</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;movieFinder&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- setter方法，注入基本数据类型movieName</span></span><br><span class="line"><span class="comment">       name = 属性名 value= 基本类型值</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;消失的她&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.MovieFinder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>property标签： 可以给setter方法对应的属性赋值</li><li>property 标签： name属性代表<strong>set方法标识</strong>、ref代表引用bean的标识id、value属性代表基本属性值</li></ul></li></ol><h5 id="基于构造器完成"><a href="#基于构造器完成" class="headerlink" title="基于构造器完成"></a><strong>基于构造器完成</strong></h5><ol><li><p>生成构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(<span class="type">int</span> age , String name ,UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value直接注入基本类型值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">&quot;赵伟风&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用类bean声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value直接注入基本类型值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵伟风&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用类bean声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 </span></span><br><span class="line"><span class="comment">           index从0开始 构造函数(0,1,2....)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value直接注入基本类型值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵伟风&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 被引用类bean声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>constructor-arg标签：指定构造参数和对应的值</li><li>constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值</li></ul></li></ol><h4 id="IoC容器创建和使用"><a href="#IoC容器创建和使用" class="headerlink" title="IoC容器创建和使用"></a>IoC容器创建和使用</h4><ol><li><p>容器实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1:实例化并且指定配置文件</span></span><br><span class="line"><span class="comment">//参数：String...locations 传入一个或者多个配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line">           </span><br><span class="line"><span class="comment">//方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式]  </span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();   </span><br><span class="line"><span class="comment">//设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置</span></span><br><span class="line">iocContainer1.setConfigLocations(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"><span class="comment">//后配置的文件,需要调用refresh方法,触发刷新配置</span></span><br><span class="line">iocContainer1.refresh();   </span><br></pre></td></tr></table></figure></li><li><p>Bean对象读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1: 根据id获取</span></span><br><span class="line"><span class="comment">//没有指定类型,返回为Object,需要类型转化!</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent</span> <span class="operator">=</span> </span><br><span class="line">        (HappyComponent) iocContainer.getBean(<span class="string">&quot;bean的id标识&quot;</span>);</span><br><span class="line"><span class="comment">//使用组件对象        </span></span><br><span class="line">happyComponent.doWork();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2: 根据类型获取</span></span><br><span class="line"><span class="comment">//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理</span></span><br><span class="line"><span class="comment">//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent</span> <span class="operator">=</span> iocContainer.getBean(HappyComponent.class);</span><br><span class="line">happyComponent.doWork();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3: 根据id和类型获取</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent</span> <span class="operator">=</span> iocContainer.getBean(<span class="string">&quot;bean的id标识&quot;</span>, HappyComponent.class);</span><br><span class="line">happyComponent.doWork();</span><br></pre></td></tr></table></figure><p>根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，<br>只要返回的是true就可以认定为和类型匹配，能够获取到。</p></li></ol><h4 id="特殊值处理"><a href="#特殊值处理" class="headerlink" title="特殊值处理"></a>特殊值处理</h4><ul><li><p>字面量赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>null</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>xml实体</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 解决方案一：使用XML实体来代替 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a <span class="symbol">&amp;lt;</span> b&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CDATA节</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 解决方案二：使用CDATA节 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所以CDATA节中写什么符号都随意 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[a &lt; b]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="特殊类型属性注入"><a href="#特殊类型属性注入" class="headerlink" title="特殊类型属性注入"></a>特殊类型属性注入</h4><ul><li><p><strong>对象类型属性注入方式</strong></p><ol><li><p>引用外部bean（1. 创建对象 2.在emp的bean标签里使用property引入dept的bean）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Emp&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;smith&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 对象属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内部bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Emp&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;smith&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;deptInner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>级联属性赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Emp&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;smith&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 级联赋值，可以改变dept2中的属性值 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保安部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>为数组类型属性赋值</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>抽烟<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>喝酒<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>烫头<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>为集合类型属性赋值</strong></p><ul><li><p>为List集合类型属性赋值(若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;seny&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;empOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;empTwo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;empThree&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>为Map集合类型属性赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacherone&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teancherid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teachername&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wang&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Student&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;smith&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>10010<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacherOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用集合类型的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--list集合类型的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;lessionList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;lessionOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;lessionTwo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;lessionThree&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--map集合类型的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">&quot;teacherMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>10010<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacherOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>10086<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacherTwo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4444&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lessionList&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;lessionList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherMap&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacherMap&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="引入外部属性文件"><a href="#引入外部属性文件" class="headerlink" title="引入外部属性文件"></a>引入外部属性文件</h4><ol><li><p>创建外部属性文件，properties格式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/database_name?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>引入属性文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入外部属性文件 在使用 context:property-placeholder 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h4><p>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围</p><table><thead><tr><th>取值</th><th>含义</th><th>创建对象的时机</th><th>默认值</th></tr></thead><tbody><tr><td>singleton</td><td>在 IOC 容器中，这个 bean 的对象始终为单实例</td><td>IOC 容器初始化时</td><td>是</td></tr><tr><td>prototype</td><td>这个 bean 在 IOC 容器中有多个实例</td><td>获取 bean 时</td><td>否</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 推荐 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring6.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，<strong>在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值</strong>。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p><p><code>FactoryBean&lt;T&gt;</code> 接口提供三种方法：</p><ul><li><p><code>T getObject()</code>: </p><p>  返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！</p></li><li><p><code>boolean isSingleton()</code>: </p><p>  如果此 <code>FactoryBean</code> 返回单例，则返回 <code>true</code> ，否则返回 <code>false</code> 。此方法的默认实现返回 <code>true</code> （注意，lombok插件使用，可能影响效果）。</p></li><li><p><code>Class&lt;?&gt; getObjectType()</code>: 返回 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回 <code>null</code> 。</p></li></ul><ol><li>准备FactoryBean实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现FactoryBean接口时需要指定泛型</span></span><br><span class="line"><span class="comment">// 泛型类型就是当前工厂要生产的对象的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HappyFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;HappyMachine&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String machineName;<span class="comment">//间接传参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMachineName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> machineName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMachineName</span><span class="params">(String machineName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.machineName = machineName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HappyMachine <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 方法内部模拟创建、设置一个对象的复杂过程</span></span><br><span class="line">        <span class="type">HappyMachine</span> <span class="variable">happyMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HappyMachine</span>();</span><br><span class="line">    </span><br><span class="line">        happyMachine.setMachineName(<span class="built_in">this</span>.machineName);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> happyMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回要生产的对象的类型</span></span><br><span class="line">        <span class="keyword">return</span> HappyMachine.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置FactoryBean实现类</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- FactoryBean机制 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;happyMachine7&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.ioc.HappyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 这个值是给HappyFactoryBean类的，再通过1中方法给工厂生产对象传值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;machineName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;iceCreamMachine&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试读取FactoryBean和FactoryBean.getObject对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExperiment07</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">iocContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-bean-07.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象</span></span><br><span class="line">    <span class="type">HappyMachine</span> <span class="variable">happyMachine</span> <span class="operator">=</span> iocContainer.getBean(<span class="string">&quot;happyMachine7&quot;</span>,HappyMachine.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;happyMachine = &quot;</span> + happyMachine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可!  &amp;happyMachine7 这是一种固定的约束</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> iocContainer.getBean(<span class="string">&quot;&amp;happyMachine7&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;bean = &quot;</span> + bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FactoryBean和BeanFactory区别</strong>：</p><ul><li><p>**FactoryBean **是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！</p></li><li><p><strong>BeanFactory</strong> 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。</p></li></ul><p>总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。</p><h3 id="基于注解管理Bean"><a href="#基于注解管理Bean" class="headerlink" title="基于注解管理Bean"></a>基于注解管理Bean</h3><ol><li>注解负责标记IoC的类和进行属性装配</li><li>xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围</li><li>标记IoC注解：@Component,@Service,@Controller,@Repository </li><li>标记DI注解：@Autowired @Qualifier @Resource @Value</li><li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li></ol><h4 id="注解标记"><a href="#注解标记" class="headerlink" title="注解标记"></a>注解标记</h4><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td></tr><tr><td>@Repository</td><td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Service</td><td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Controller</td><td>该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr></tbody></table><p>在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id 属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。</p><p>默认情况：</p><p>类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。</p><p>也可用使用value属性指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller(value = &quot;tianDog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoldierController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当注解中只设置一个属性时，value属性的属性名可以省略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;smallDog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoldierService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开启组件扫描"><a href="#开启组件扫描" class="headerlink" title="开启组件扫描"></a>开启组件扫描</h4><p>Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 <code>context:component-scan</code> 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。</p><ul><li><p>最基本的扫描方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring6&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>指定要排除的组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring6&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- context:exclude-filter标签：指定排除规则 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> type：设置排除或包含的依据</span></span><br><span class="line"><span class="comment">type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名</span></span><br><span class="line"><span class="comment">type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>仅扫描指定组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- use-default-filters属性：取值false表示该包不生效 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> type：设置排除或包含的依据</span></span><br><span class="line"><span class="comment">type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名</span></span><br><span class="line"><span class="comment">type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="组件作用域和周期方法注解"><a href="#组件作用域和周期方法注解" class="headerlink" title="组件作用域和周期方法注解"></a>组件作用域和周期方法注解</h4><p><strong>组件周期方法配置</strong></p><p>我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！</p><p>类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span></span><br><span class="line">  <span class="meta">@PostConstruct</span>  <span class="comment">//注解制指定初始化方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTwo</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PreDestroy</span> <span class="comment">//注解指定销毁方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 释放资源逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组件作用域配置</strong></p><table><thead><tr><th>取值</th><th>含义</th><th>创建对象的时机</th><th>默认值</th></tr></thead><tbody><tr><td>singleton</td><td>在 IOC 容器中，这个 bean 的对象始终为单实例</td><td>IOC 容器初始化时</td><td>是</td></tr><tr><td>prototype</td><td>这个 bean 在 IOC 容器中有多个实例</td><td>获取 bean 时</td><td>否</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span> <span class="comment">//单例,默认值</span></span><br><span class="line"><span class="comment">//@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例  二选一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span></span><br><span class="line">  <span class="meta">@PostConstruct</span>  <span class="comment">//注解制指定初始化方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p><strong>引用数据类型</strong></p><ul><li><p><strong>@Autowired</strong>：单独使用@Autowired注解，<strong>默认根据类型装配</strong>。【默认是byType】</p><ol><li><p>属性注入：属性上加上@Autowired注解完成注入，不需要生成setter()方法</p></li><li><p>set注入：生成setter()方法，之上加上@Autowired注解</p></li><li><p>构造方法注入：生成构造方法，之上加上@Autowired注解</p></li><li><p>形参注入：<code>public UserServiceImpl(@Autowired UserDao userDao) &#123;this.userDao = userDao;&#125;</code></p></li><li><p>只有一个构造器，无注解：当有参数的构造方法只有一个时，@Autowired注解可以省略。</p></li><li><p>@Autowired和@Qualifier注入联合：@Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDaoImpl&quot;)</span> <span class="comment">// 指定bean的名字</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>@Resource</strong></p><p>和@Autowired注解有什么区别？</p><ol><li><p>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。@Autowired注解是Spring框架自己的。</p></li><li><p>@Resource注解<strong>默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。</strong>@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。</p></li><li><p>@Resource注解<strong>用在属性上、setter方法上</strong>。@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。<br>@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><strong>基本数据类型</strong></p><p><code>@Value</code> 通常用于注入外部化属性</p><ol><li><p>声明外部配置：application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">catalog.name</span>=<span class="string">MovieCatalog</span></span><br></pre></td></tr></table></figure></li><li><p>xml引入外部配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入外部配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;application.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>@Value注解读取配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 情况1: $&#123;key&#125; 取外部配置key对应的值!</span></span><br><span class="line"><span class="comment">     * 情况2: $&#123;key:defaultValue&#125; 没有key,可以给与默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;catalog.name:hahaha&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置类和完全注解开发"><a href="#配置类和完全注解开发" class="headerlink" title="配置类和完全注解开发"></a>配置类和完全注解开发</h3><ol><li>完全注解方式指的是去掉xml文件，使用配置类 + 注解实现</li><li>xml文件替换成使用@Configuration注解标记的类</li><li>标记IoC注解：@Component,@Service,@Controller,@Repository </li><li>标记DI注解：@Autowired @Qualifier @Resource @Value</li><li>&lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“com.atguigu.components”})替代</li><li>&lt;context:property-placeholder引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代</li><li>&lt;bean 标签标记的第三方库使用@Bean注解和方法实现</li><li>IoC具体容器实现选择AnnotationConfigApplicationContext对象</li></ol><h4 id="配置类和扫描注解"><a href="#配置类和扫描注解" class="headerlink" title="配置类和扫描注解"></a>配置类和扫描注解</h4><p>@Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件</p><p>@ComponentScan(basePackages &#x3D; {“包”,”包”}) 替代&lt;context:component-scan标签实现注解扫描</p><p>@PropertySource(“classpath:配置文件地址”) 替代 &lt;context:property-placeholder标签</p><p>全注解开发就是不再使用spring的xml配置文件了，写一个<strong>配置类来代替配置文件</strong>。使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//使用注解读取外部配置，替代 &lt;context:property-placeholder标签</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="comment">//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试创建IoC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">iocContainerAnnotation</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfiguration.class);</span><br></pre></td></tr></table></figure><p>可以使用 no-arg 构造函数实例化 <code>AnnotationConfigApplicationContext</code> ，然后使用 <code>register()</code> 方法对其进行配置。此方法在以编程方式生成 <code>AnnotationConfigApplicationContext</code> 时特别有用。以下示例演示如何执行此操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext-IOC容器对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">iocContainerAnnotation</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line"><span class="comment">//外部设置配置类</span></span><br><span class="line">iocContainerAnnotation.register(MyConfiguration.class);</span><br><span class="line"><span class="comment">//刷新后方可生效！！</span></span><br><span class="line">iocContainerAnnotation.refresh();</span><br></pre></td></tr></table></figure><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p><code>@Bean</code> 注解用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 <code>&lt;bean/&gt;</code>  XML 配置的人来说， <code>@Bean</code> 注解与 <code>&lt;bean/&gt;</code>元素起着相同的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//引入jdbc.properties文件</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果第三方类进行IoC管理,无法直接使用@Component相关注解</span></span><br><span class="line">    <span class="comment">//解决方案: xml方式可以使用&lt;bean标签</span></span><br><span class="line">    <span class="comment">//解决方案: 配置类方式,可以使用方法返回值+@Bean注解</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.user&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driverClassName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用Java代码实例化</span></span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        <span class="comment">//返回结果即可</span></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Bean注解源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="comment">//前两个注解可以指定Bean的标识</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。</span></span><br><span class="line">    <span class="comment">//autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标，</span></span><br><span class="line">    <span class="comment">//可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定初始化方法</span></span><br><span class="line">    String <span class="title function_">initMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//指定销毁方法</span></span><br><span class="line">    String <span class="title function_">destroyMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;(inferred)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指定@Bean的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(&quot;myThing&quot;)</span> <span class="comment">//指定名称</span></span><br><span class="line">  <span class="keyword">public</span> Thing <span class="title function_">thing</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thing</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Bean 注解方法。使用此方法在指定为方法返回值的类型的 ApplicationContext 中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。</p><p><strong>@Bean 初始化和销毁方法指定</strong></p><p><code>@Bean</code> 注解支持指定任意初始化和销毁回调方法，非常类似于 Spring XML 在 <code>bean</code> 元素上的 <code>init-method</code> 和 <code>destroy-method</code> 属性，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanOne</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// initialization logic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTwo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// destruction logic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> BeanOne <span class="title function_">beanOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanOne</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> BeanTwo <span class="title function_">beanTwo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanTwo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Bean Scope作用域</strong></p><p>可以指定使用 <code>@Bean</code> 注释定义的 bean 应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。</p><p>默认作用域为 <code>singleton</code> ，但您可以使用 <code>@Scope</code> 注释覆盖此范围，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Encryptor <span class="title function_">encryptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Bean方法之间依赖</strong></p><p>例如，JdbcTemplate使用DruidDataSource</p><ul><li><p>直接调用方法返回 Bean 实例：在一个 <code>@Bean</code> 方法中直接调用其他 <code>@Bean</code> 方法来获取 Bean 实例，虽然是方法调用，也是通过IoC容器获取对应的Bean</p></li><li><p>参数引用法：通过方法参数传递 Bean 实例的引用来解决 Bean 实例之间的依赖关系。如果有多个bean, 形参名称等于要指定的bean名称!</p></li></ul><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p><code>@Import</code> 注释允许从另一个配置类加载 <code>@Bean</code> 定义，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> B <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向切面：AOP"><a href="#面向切面：AOP" class="headerlink" title="面向切面：AOP"></a>面向切面：AOP</h2><h3 id="概念和相关术语"><a href="#概念和相关术语" class="headerlink" title="概念和相关术语"></a>概念和相关术语</h3><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过<strong>预编译方式和运行期动态代理方式</strong>实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p><p>AOP应用场景：</p><ol><li>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</li><li>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</li><li>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</li><li>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</li><li>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</li><li>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</li><li>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。</li></ol><p>AOP术语：</p><ul><li><p>横切关注点：从每个方法中抽取出来的同一类非核心业务。AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p></li><li><p>通知（增强）：通知就是你想要增强的功能，比如 安全，事务，日志等。</p><ul><li>前置通知：在被代理的目标方法前执行</li></ul><ul><li>返回通知：在被代理的目标方法成功结束后执行（<strong>寿终正寝</strong>）</li><li>异常通知：在被代理的目标方法异常结束后执行（<strong>死于非命</strong>）</li><li>后置通知：在被代理的目标方法最终结束后执行（<strong>盖棺定论</strong>）</li><li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li></ul></li><li><p>切面：切入点和通知的结合。是一个类。优先级高的切面在外面，使用 <code>@Order(数字)</code> 控制切面优先级，数字越小优先级越高</p></li><li><p>目标：目标就是被代理的目标对象</p></li><li><p>代理：代理就是向目标对象应用通知之后创建的代理对象</p></li><li><p>连接点：表示在程序执行过程中能够插入一个切面的点。连接点就是在程序执行中可以被拦截的地方</p></li><li><p>切入点：定位连接点的方式，或者可以理解成被选中的连接点</p></li></ul><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/8578fde55d6dd885a62f6c213c677d93.png"></p><p><strong>重用（提取）切入点表达式</strong></p><p>出现了冗余，如果需要切换也不方便统一维护。我们可以将切点提取，在增强上进行引用即可。</p><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>同一切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同切面：加上定义切入点表达式的类的全类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h3><h4 id="AOP底层技术组成"><a href="#AOP底层技术组成" class="headerlink" title="AOP底层技术组成"></a>AOP底层技术组成</h4><p><img src="https://api.wolai.com/v1/proxy/image?src=http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img006.84eb95b7.png&spaceId=fqkGyHKKxSnzkhVZnoSxhC&userId=&image_process=resize,w_630"></p><ul><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口。</li><li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口。</li><li>AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。</li></ul><h4 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h4><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--spring aop依赖 Spring Context会传递该依赖，一般不用导 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring aspects依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建接口以及实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类，此实现类，也需要添加@Component注解，便于Spring容器进行管理</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Aspect表示这个类是一个切面类</span></span><br><span class="line"><span class="comment">// @Component注解保证这个切面类能够放入IOC容器</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// @Before注解：声明当前方法是前置通知方法</span></span><br><span class="line">    <span class="comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP前置通知] 方法开始了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterException</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogFinallyEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启aspectj注解支持</p><ul><li><p>xml方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 进行包扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启aspectj框架注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置类方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu&quot;)</span></span><br><span class="line"><span class="comment">//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="获取通知细节信息"><a href="#获取通知细节信息" class="headerlink" title="获取通知细节信息"></a>获取通知细节信息</h4><p><strong>JointPoint接口</strong></p><p>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</p><ul><li>要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息）</li><li>要点2：通过目标方法签名对象获取方法名</li><li>要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Before注解标记前置通知方法</span></span><br><span class="line"><span class="comment">// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上</span></span><br><span class="line"><span class="comment">// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入</span></span><br><span class="line"><span class="comment">// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.通过JoinPoint对象获取目标方法签名对象</span></span><br><span class="line">    <span class="comment">// 方法的签名：一个方法的全部声明信息</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.通过方法的签名对象获取目标方法的详细信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;methodName = &quot;</span> + methodName);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> signature.getModifiers();</span><br><span class="line">    System.out.println(<span class="string">&quot;modifiers = &quot;</span> + modifiers);</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">declaringTypeName</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">    System.out.println(<span class="string">&quot;declaringTypeName = &quot;</span> + declaringTypeName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.由于数组直接打印看不到具体数据，所以转换为List集合</span></span><br><span class="line">    List&lt;Object&gt; argList = Arrays.asList(args);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP前置通知] &quot;</span> + methodName + <span class="string">&quot;方法开始了，参数列表：&quot;</span> + argList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法返回值</strong></p><p>在返回通知中，通过**@AfterReturning**注解的returning属性获取目标方法的返回值！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @AfterReturning注解标记返回通知方法</span></span><br><span class="line"><span class="comment">// 在返回通知中获取目标方法返回值分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterReturning注解中通过returning属性设置一个名称</span></span><br><span class="line"><span class="comment">// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参</span></span><br><span class="line"><span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        returning = &quot;targetMethodReturnValue&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreSuccess</span><span class="params">(JoinPoint joinPoint, Object targetMethodReturnValue)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP返回通知] &quot;</span>+methodName+<span class="string">&quot;方法成功结束了，返回值是：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异常对象捕捉</strong></p><p>在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @AfterThrowing注解标记异常通知方法</span></span><br><span class="line"><span class="comment">// 在异常通知中获取目标方法抛出的异常分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称</span></span><br><span class="line"><span class="comment">// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们</span></span><br><span class="line"><span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        throwing = &quot;targetMethodException&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreException</span><span class="params">(JoinPoint joinPoint, Throwable targetMethodException)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] &quot;</span>+methodName+<span class="string">&quot;方法抛异常了，异常类型是：&quot;</span> + targetMethodException.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>环绕通知 <code>@Around()</code>：使用<code>try…catch…finally</code>结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用@Around注解标明环绕通知方法</span></span><br><span class="line"><span class="meta">@Around(value = &quot;com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">manageTransaction</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，</span></span><br><span class="line"><span class="params">        // Spring会将这个类型的对象传给我们</span></span><br><span class="line"><span class="params">        ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取目标方法的签名对象</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过签名对象获取目标方法的方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明变量用来存储目标方法的返回值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">targetMethodReturnValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法执行前：开启事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 开启事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，参数列表：&quot;</span> + Arrays.asList(args));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 过ProceedingJoinPoint对象调用目标方法</span></span><br><span class="line">        <span class="comment">// 目标方法的返回值一定要返回给外界调用者</span></span><br><span class="line">        targetMethodReturnValue = joinPoint.proceed(args);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法成功返回后：提交事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 提交事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，方法返回值：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法抛异常后：回滚事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 回滚事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，异常：&quot;</span> + e.getClass().getName());</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法最终结束后：释放数据库连接</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot;</span> + methodName);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> targetMethodReturnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面优先级"><a href="#切面优先级" class="headerlink" title="切面优先级"></a>切面优先级</h4><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。</p><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用 @Order 注解可以控制切面的优先级：</p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul><h2 id="声明式事务：tx"><a href="#声明式事务：tx" class="headerlink" title="声明式事务：tx"></a>声明式事务：tx</h2><p>编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。</p><p><strong>事务特性</strong></p><ul><li>原子性（Atomicity）：事务是一个不可分割的工作单元，要么全部成功，要么全部失败，不允许出现部分成功部分失败的情况。</li><li>一致性（Consistency）：事务执行前后，数据库的状态应该保持一致，如果一个事务执行失败，那么数据库应该恢复到执行前的状态。</li><li>隔离性（Isolation）：多个事务之间应该互相隔离，事务之间不能互相干扰，避免脏读、不可重复读、幻读等问题。</li><li>持久性（Durability）：事务完成后，对数据库的修改应该持久化保存，即使系统故障或崩溃，数据也不应该丢失。</li></ul><h3 id="Spring-事务管理器"><a href="#Spring-事务管理器" class="headerlink" title="Spring 事务管理器"></a>Spring 事务管理器</h3><p>Spring声明式事务对应依赖</p><ul><li>spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li><li>spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager</li><li>spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等</li></ul><p>DataSourceTransactionManager类中的主要方法：</p><ul><li>doBegin()：开启事务</li><li>doSuspend()：挂起事务</li><li>doResume()：恢复挂起的事务</li><li>doCommit()：提交事务</li><li>doRollback()：回滚事务</li></ul><h3 id="基于注解的声明式事务"><a href="#基于注解的声明式事务" class="headerlink" title="基于注解的声明式事务"></a>基于注解的声明式事务</h3><p><strong>配置事务管理器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 表示该类为配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu&quot;)</span> <span class="comment">// 开启组件扫描，扫描com.atguigu.spring6包下的组件</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 开启注解式事务管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化dataSource加入到ioc容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;atguigu.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;atguigu.driver&#125;&quot;)</span>String driver,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;atguigu.username&#125;&quot;)</span>String username,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;atguigu.password&#125;&quot;)</span>String password)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化JdbcTemplate对象,需要使用ioc中的DataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装配事务管理实现对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用声明事务注解@Transactional</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Transactional注解标识在方法上，只会影响此方法被事务管理利器进行管理。@Transactional注解标识在类上，则会影响该类中的所有方法被事务管理利器进行管理</p><h3 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h3><h4 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h4><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readOnly = true把当前事务设置为只读 默认是false!</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure><p>如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。</p><p>对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。</p><p>在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了便于核对数据库操作结果，不要修改同一条记录</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateTwice</span><span class="params">(……)</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// readOnly = true把当前事务设置为只读</span></span><br><span class="line">    <span class="comment">// @Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmpName</span><span class="params">(Integer empId)</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//休眠4秒,等待方法超时!</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务异常"><a href="#事务异常" class="headerlink" title="事务异常"></a>事务异常</h4><p>默认只针对运行时异常回滚，编译时异常不回滚。</p><ol><li><p>rollbackFor属性：当事务方法抛出指定类型的异常时，事务会回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(rollbackFor = &#123;SQLException.class, IOException.class&#125;)</span><br></pre></td></tr></table></figure></li><li><p>rollbackForClassName属性：与rollbackFor属性相似，但是指定异常类型时使用字符串的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(rollbackForClassName = &#123;&quot;java.sql.SQLException&quot;, &quot;java.io.IOException&quot;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>noRollbackFor属性：指定当事务方法抛出指定类型的异常时，事务不回滚。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(noRollbackFor = &#123;NullPointerException.class, IllegalArgumentException.class&#125;)</span><br></pre></td></tr></table></figure></li><li><p>noRollbackForClassName属性：与noRollbackFor属性相似，但是指定异常类型时使用字符串的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(noRollbackForClassName = &#123;&quot;java.lang.NullPointerException&quot;, &quot;java.lang.IllegalArgumentException&quot;&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>隔离级别：为了保证事务之间的数据一致性，数据库采用的一种隔离机制</p><table><thead><tr><th>隔离级别</th><th>脏读（读取未提交数据）</th><th>不可重复读（读取提交的修改的数据）</th><th>幻读（读取提交的插入数据）</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（读未提交）</td><td>有</td><td>有</td><td>有</td></tr><tr><td>READ COMMITTED（读已提交）</td><td>无</td><td>有</td><td>有</td></tr><tr><td>REPEATABLE READ（可重复读）</td><td>无</td><td>无</td><td>有</td></tr><tr><td>SERIALIZABLE（串行化）</td><td>无</td><td>无</td><td>无</td></tr></tbody></table><ol><li>读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</li><li>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</li><li>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</li><li>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</li></ol><p>基本用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别</span><br><span class="line">@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交</span><br><span class="line">@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交</span><br><span class="line">@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读，mysql默认</span><br><span class="line">@Transactional(isolation = Isolation.SERIALIZABLE)//串行化</span><br></pre></td></tr></table></figure><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务的传播行为是指在多个事务方法相互调用时，控制事务如何传播和影响彼此的行为的规则</p><ol><li><p>REQUIRED（默认）：如果当前存在一个事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<strong>没有就新建，有就加入</strong></p></li><li><p>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则将当前事务挂起。<strong>不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起</strong></p></li><li><p>SUPPORTS：如果当前存在一个事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<strong>有就加入，没有就不管了</strong></p></li><li><p>MANDATORY：如果当前存在一个事务，则加入该事务；如果当前没有事务，则抛出异常。<strong>有就加入，没有就抛异常</strong></p></li><li><p>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则将当前事务挂起。<strong>不支持事务，存在就挂起</strong></p></li><li><p>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。<strong>不支持事务，存在就抛异常</strong></p></li><li><p>NESTED：如果当前存在一个事务，则在嵌套事务内执行；如果当前没有事务，则按照 PROPAGATION_REQUIRED 执行。<strong>有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot3</title>
      <link href="/2023/06/23/springboot3/"/>
      <url>/2023/06/23/springboot3/</url>
      
        <content type="html"><![CDATA[<h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><p>Spring Initializr脚手架的web地址： <a href="https://start.spring.io/">https://start.spring.io/</a></p><p>阿里云脚手架：<a href="https://start.aliyun.com/">https://start.aliyun.com/</a></p><h3 id="SpringBoot概述"><a href="#SpringBoot概述" class="headerlink" title="SpringBoot概述"></a>SpringBoot概述</h3><ul><li><p>starter：定义了当前项目所使用的所有依赖坐标，以达到<strong>减少依赖配置</strong>的目的</p></li><li><p>parent：定义了坐标版本号，以达到<strong>减少依赖冲突</strong>的目的</p><p>实际开发</p><ul><li>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非未提供对应版本V</li><li>如发生坐标错误，再指定V（要小心版本冲突）</li></ul></li><li><p>引导类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Demo01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内嵌tomcat</p></li></ul><h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties</a></p><p><strong>三种配置文件格式</strong></p><ul><li>properties（传统&#x2F;默认格式）</li><li>yml（主流格式）</li><li>yaml</li><li>加载顺序：prperties &gt; yml &gt; yaml</li><li>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置全部保留</li></ul><p><strong>ymal数据读取</strong></p><ul><li><p>读取单一数据</p><p>yaml中保存的单个数据，可以使用Spring中的注解<code>@Value</code>读取单个数据，属性名引用方式：<code>$&#123;一级属性名.二级属性名……&#125;</code></p></li><li><p>读取全部数据</p><p>SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中</p></li><li><p>读取对象数据：</p><p>一组数据封装成一个对象</p><p>使用<code>@ConfigurationProperties</code>注解可以绑定配置信息到封装类中</p><p>封装类需要定义为Spring管理的bean（使用<code>@Component</code>），否则无法进行属性注入</p></li></ul><h3 id="底层注解"><a href="#底层注解" class="headerlink" title="底层注解"></a>底层注解</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">//proxyBeanMethods：代理bean的方法</span></span><br><span class="line"><span class="comment">//Full(proxyBeanMethods = true)（保证每个@Bean方法被调用多少次返回的组件都是单实例的）（默认）</span></span><br><span class="line"><span class="comment">//Lite(proxyBeanMethods = false)（每个@Bean方法被调用多少次返回的组件都是新创建的）</span></span><br></pre></td></tr></table></figure><p>最佳实战</p><ul><li>配置 类组件之间<strong>无依赖关系</strong>用Lite模式加速容器启动过程，减少判断</li><li>配置 类组件之间<strong>有依赖关系</strong>，方法会被调用得到之前单实例组件，用Full模式（默认）</li></ul><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p><code>@Import(&#123;User.class, DBHelper.class&#125;)</code>给容器中<strong>自动创建出这两个类型的组件</strong>、默认组件的名字就是全类名</p><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>条件装配：满足Conditional指定的条件，则进行组件注入</p><h4 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h4><p>比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。</p><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/06/23/mybatis/"/>
      <url>/2023/06/23/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="mybatis-–-MyBatis3"><a href="#mybatis-–-MyBatis3" class="headerlink" title="mybatis – MyBatis3"></a><a href="https://mybatis.org/mybatis-3/zh/index.html">mybatis – MyBatis3</a></h2><h2 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h2><p><strong>1. 引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 创建MyBatis的核心配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。</span><br><span class="line">核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</span><br><span class="line">核心配置文件存放的位置是resources目录下</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：</p><p>mybatis配置文件设计标签和顶层结构如下：</p><ul><li>configuration（配置）<ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a><ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">    default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment">1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下(recource下mapper.xml文件具有和mapper接口相同路径)</span></span><br><span class="line"><span class="comment">2. mapper接口要和mapper映射文件的名字一致</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. 创建mapper接口</strong></p><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p><p><img src="https://secure2.wostatic.cn/static/bkCL19U4AA9SGMm4kuRXT3/image.png?auth_key=1701136591-wMKDjQSFjXSL2uXSBSMZG9-0-db99ad9d17deb3205494832f9eed629e&image_process=resize,w_842&file_size=39238"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 添加用户信息  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4 .创建MyBatis的映射文件</strong>: UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;package com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">        insert into user values(1,&#x27;wang&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>映射文件的命名规则</strong></p><ul><li>表所对应的实体类的类名+Mapper.xml</li><li>一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</li></ul><p><strong>MyBatis中可以面向接口操作数据，要保证两个一致</strong></p><ul><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ul><h2 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h2><ul><li><p>添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">    delete from t_user where id = 6</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">    update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查询一个实体类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where id = 2  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查询集合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系</p><ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况</li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ul><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>MyBatis获取参数值的两种方式：**${}<strong>和</strong>#{}**</p><ul><li><strong>${}的本质就是字符串拼接，#{}的本质就是占位符赋值</strong></li><li>${}使用字符串拼接的方式拼接sql，不推荐使用，一般使用#{}</li></ul><h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h3><p><strong>单个基本类型的参数</strong></p><p>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称获取参数的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>多个基本类型的参数</strong></p><ul><li><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p><ol><li><p>以<strong>参数名</strong>键，以参数为值；</p></li><li><p>以<strong>param1,param2</strong>…为键，以参数为值；</p></li><li><p>以**arg0,arg1…**为键，</p></li></ol></li><li><p>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。</p></li><li><p>param是从param1开始的</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>map集合类型的参数</strong></p><p>若mapper接口中的方法需要的参数为多个时，此时可以<strong>手动创建map集合</strong>，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>实体类类型的参数</strong></p><p>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的<strong>属性名获取属性值</strong>，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用@Param标识参数</strong></p><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中</p><p>以@Param注解的value属性值为键，以参数为值；</p><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;CheckLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h3><p><strong>单个基本类型</strong></p><p>select标签，通过resultType指定查询返回值类型！</p><p>resultType &#x3D; “全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可”。 可用通过<code>&lt;typeAliases&gt;</code>设置别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">  select count(*) from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>返回实体类对象</strong></p><p><code>&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</code>表示开启自动映射驼峰式命名规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;id&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>返回map类型</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 返回工资最高的员工的姓名和他的工资 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpNameAndMaxSalary&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  SELECT</span><br><span class="line">    emp_name 员工姓名,</span><br><span class="line">    emp_salary 员工工资,</span><br><span class="line">    (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资</span><br><span class="line">  FROM t_emp WHERE emp_salary=(</span><br><span class="line">    SELECT MAX(emp_salary) FROM t_emp</span><br><span class="line">  )</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>返回List类型</strong></p><p>查询结果返回多个实体类对象，希望把多个实体类对象放在List集合中返回。此时不需要任何特殊处理，在resultType属性中还是设置实体类类型即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectAll(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  select emp_id empId,emp_name empName,emp_salary empSalary</span><br><span class="line">  from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>返回主键值</strong></p><ol><li><p>自增长主键</p><p>Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int insertEmployee(Employee employee); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 keyColumn设置生成键值在表中的列名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmployee&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;empId&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;emp_id&quot;</span>&gt;</span></span><br><span class="line">  insert into t_emp(emp_name,emp_salary)</span><br><span class="line">  values(#&#123;empName&#125;,#&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>非自增长主键</p><p>而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">        SELECT UUID() as id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT INTO user (id, username, password) </span><br><span class="line">    VALUES (</span><br><span class="line">        #&#123;id&#125;,</span><br><span class="line">        #&#123;username&#125;,</span><br><span class="line">        #&#123;password&#125;</span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="特殊SQL查询"><a href="#特殊SQL查询" class="headerlink" title="特殊SQL查询"></a>特殊SQL查询</h2><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span>  </span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>是最常用</p><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>**只能使用${}，如果使用#{}**，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将1,2,3看做是一个整体，只有id为1,2,3的数据会被删除。正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h3><p><strong>只能使用${}，因为表名不能加单引号</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h3><p>useGeneratedKeys：设置使用自增的主键</p><p>keyProperty： 指定主键在实体类对象中对应的属性名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--void insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="resultMap-多表映射"><a href="#resultMap-多表映射" class="headerlink" title="resultMap 多表映射"></a>resultMap 多表映射</h2><h3 id="字段名和实体类中的属性名不一致"><a href="#字段名和实体类中的属性名不一致" class="headerlink" title="字段名和实体类中的属性名不一致"></a>字段名和实体类中的属性名不一致</h3><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系</p><ol><li><p>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;</span></span><br><span class="line">  select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;id&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>全局配置自动识别驼峰式命名规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empSalary&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRM&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="多表映射"><a href="#多表映射" class="headerlink" title="多表映射"></a>多表映射</h3><p>对一，属性中包含对方对象</p><p>对多，属性中包含对方对象集合</p><table><thead><tr><th>关联关系</th><th>配置项关键词</th><th>所在配置文件和具体位置</th></tr></thead><tbody><tr><td>对一</td><td>association标签&#x2F;javaType属性&#x2F;property属性</td><td>Mapper配置文件中的resultMap标签内</td></tr><tr><td>对多</td><td>collection标签&#x2F;ofType属性&#x2F;property属性</td><td>Mapper配置文件中的resultMap标签内</td></tr></tbody></table><h4 id="对一映射"><a href="#对一映射" class="headerlink" title="对一映射"></a>对一映射</h4><p>对一映射，属性中包含对方对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Integer orderId;</span><br><span class="line">  <span class="keyword">private</span> String orderName;</span><br><span class="line">  <span class="keyword">private</span> Customer customer;<span class="comment">// 体现的是对一的关系</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderWithCustomerResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 先设置Order自身属性和字段的对应关系 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 使用association标签配置“对一”关联关系 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- javaType属性：一的一端类的全类名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderWithCustomer&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectOrderWithCustomerResultMap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  SELECT order_id,order_name,c.customer_id,customer_name</span><br><span class="line">  FROM t_order o</span><br><span class="line">  LEFT JOIN t_customer c</span><br><span class="line">  ON o.customer_id=c.customer_id</span><br><span class="line">  WHERE o.order_id=#&#123;orderId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="对多映射"><a href="#对多映射" class="headerlink" title="对多映射"></a>对多映射</h4><p>对多映射，属性中包含对方对象集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer customerId;</span><br><span class="line">  <span class="keyword">private</span> String customerName;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Order&gt; orderList;<span class="comment">// 体现的是对多的关系  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectCustomerWithOrderListResultMap&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 映射Customer本身的属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- collection标签：映射“对多”的关联关系 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ofType属性：集合属性中元素的类型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 映射Order的属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Customer selectCustomerWithOrderList(Integer customerId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectCustomerWithOrderList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectCustomerWithOrderListResultMap&quot;</span>&gt;</span></span><br><span class="line">  SELECT c.customer_id,c.customer_name,o.order_id,o.order_name</span><br><span class="line">  FROM t_customer c</span><br><span class="line">  LEFT JOIN t_order o</span><br><span class="line">  ON c.customer_id=o.customer_id</span><br><span class="line">  WHERE c.customer_id=#&#123;customerId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多表映射优化"><a href="#多表映射优化" class="headerlink" title="多表映射优化"></a>多表映射优化</h4><table><thead><tr><th>setting属性</th><th>属性含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>autoMappingBehavior</td><td>指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr></tbody></table><p>我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！</p><p>  修改mybati-sconfig.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启resultMap自动映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FULL&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>  修改teacherMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;teacherMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;tId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;student&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;sId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul><li>if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li><li>在where后面添加一个恒成立条件1&#x3D;1<ul><li>这个恒成立条件并不会影响查询的结果</li><li>这个1&#x3D;1可以用来拼接and语句，例如：当empName为null时<ul><li>如果不加上恒成立条件，则SQL语句为<code>select * from t_emp where and age = ? and sex = ? and email = ?</code>，此时where会与and连用，SQL语句会报错</li><li>如果加上一个恒成立条件，则SQL语句为<code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code>，此时不报错</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where和if一般结合使用：</p><ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</li><li>若where标签中的if条件满足，则where标签会<strong>自动添加where关键字，并将条件最前方多余的and&#x2F;or去掉</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span></span><br><span class="line">    update t_emp</span><br><span class="line">    <span class="comment">&lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">            emp_name=#&#123;empName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">            emp_salary=#&#123;empSalary&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>trim用于去掉或添加标签中的内容<br>常用属性</p><ul><li>prefix：指定要动态添加的前缀</li><li>suffix：指定要动态添加的后缀</li><li>prefixOverrides：指定要动态去掉的前缀，使用“|”分隔有可能的多个值</li><li>suffixOverrides：指定要动态去掉的后缀，使用“|”分隔有可能的多个值</li></ul><p>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125; or</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><ul><li><code>choose、when、otherwise</code>相当于<code>if...else if..else</code>, 只会执行其中一个</li><li>如果所有的when分支都不满足，那么就执行otherwise分支</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">did = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>属性：</p><ul><li>collection：设置要循环的数组或集合</li><li>item：表示集合或数组中的每一个数据</li><li>separator：设置循环体之间的分隔符，如<code>,</code> </li><li>open：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串</li><li>close：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串</li></ul><p>批量删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">delete from t_emp where eid in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>批量添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreByList&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql:///mybatis-example?allowMultiQueries=true</span><br></pre></td></tr></table></figure><p>对应的foreach标签如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeBatch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span></span><br><span class="line">        update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</p><ul><li><p>声明sql片段：<code>&lt;sql&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用sql片段：<code>&lt;include&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><h3 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h3><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p><p>使一级缓存失效的四种情况：</p><ol><li><p>不同的SqlSession对应不同的一级缓存</p></li><li><p>同一个SqlSession但是查询条件不同</p></li><li><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p></li><li><p>同一个SqlSession两次查询期间手动清空了缓存</p></li></ol><h3 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h3><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><p>二级缓存开启的条件: </p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;“true”，默认为true，不需要设置</li><li>在映射文件中设置标签</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol><p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p><p><strong>二级缓存的相关配置</strong></p><p>在mapper配置文件中添加的cache标签可以设置一些属性</p><ul><li><p>eviction属性：缓存回收策略</p><p>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。</p><p>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p><p>默认的是 LRU</p></li><li><p>flushInterval属性：刷新间隔，单位毫秒</p><p>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</p></li><li><p>size属性：引用数目，正整数</p><p>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p></li><li><p>readOnly属性：只读，true&#x2F;false</p><p>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。</p><p>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false</p></li></ul><h3 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h3><ul><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用</li><li>如果二级缓存没有命中，再查询一级缓存</li><li>如果一级缓存也没有命中，则查询数据库</li><li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li></ul><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pageNum：当前页的页码</span><br><span class="line">pageSize：每页显示的条数</span><br><span class="line">size：当前页显示的真实条数</span><br><span class="line">total：总记录数</span><br><span class="line">pages：总页数</span><br><span class="line">prePage：上一页的页码</span><br><span class="line">nextPage：下一页的页码</span><br><span class="line">isFirstPage/isLastPage：是否为第一页/最后一页</span><br><span class="line">hasPreviousPage/hasNextPage：是否存在上一页/下一页</span><br><span class="line">navigatePages：导航分页的页码数</span><br><span class="line">navigatepageNums：导航分页的页码，[1,2,3,4,5]</span><br></pre></td></tr></table></figure><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置分页插件：MyBatis的核心配置文件（mybatis-config.xml）中配置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;helperDialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p><p>在查询功能之前使用 <code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能</p><ul><li>pageNum：当前页的页码</li><li>pageSize：每页显示的条数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTeacherRelationshipToMulti</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">TeacherMapper</span> <span class="variable">teacherMapper</span> <span class="operator">=</span> session.getMapper(TeacherMapper.class);</span><br><span class="line"></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 查询Customer对象同时将关联的Order集合查询出来</span></span><br><span class="line">    List&lt;Teacher&gt; allTeachers = teacherMapper.findAllTeachers();</span><br><span class="line"></span><br><span class="line">    PageInfo&lt;Teacher&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(allTeachers);</span><br><span class="line">    System.out.println(<span class="string">&quot;pageInfo = &quot;</span> + pageInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> pageInfo.getTotal(); <span class="comment">// 获取总记录数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + total);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">pages</span> <span class="operator">=</span> pageInfo.getPages();  <span class="comment">// 获取总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + pages);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNum</span> <span class="operator">=</span> pageInfo.getPageNum(); <span class="comment">// 获取当前页码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pageNum = &quot;</span> + pageNum);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageInfo.getPageSize(); <span class="comment">// 获取每页显示记录数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pageSize = &quot;</span> + pageSize);</span><br><span class="line">    </span><br><span class="line">    List&lt;Teacher&gt; teachers = pageInfo.getList(); <span class="comment">//获取查询页的数据集合</span></span><br><span class="line">    System.out.println(<span class="string">&quot;teachers = &quot;</span> + teachers);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><p><a href="https://www.wolai.com/oLP8DUTzo2JRX1DfZNZn6c">MyBatis</a></p><ul><li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</li><li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：<ul><li>Java实体类</li><li>Mapper接口</li><li>Mapper映射文件</li></ul></li></ul><p>逆向工程只能生成单表crud的操作，多表查询依然需要我们自己编写！</p><p><strong>创建逆向工程的步骤</strong></p><ol><li>安装MyBatisX 插件</li><li>使用 IntelliJ IDEA连接数据库</li><li>对相关表进行逆向生成 <code>MyBatisX-Generator</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/06/23/springmvc/"/>
      <url>/2023/06/23/springmvc/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html?spm=wolai.workspace.0.0.78d5767bUcXVsM">SpringMVC </a></p><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p><p>SpringMVC负责表述层（控制层）实现简化！</p><ol><li><p>简化前端参数接收( 形参列表 )</p></li><li><p>简化后端数据响应(返回值)</p></li></ol><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.api</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">servlet.api</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springioc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- web相关依赖  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用</span></span><br><span class="line"><span class="comment">         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’</span></span><br><span class="line"><span class="comment">         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的</span></span><br><span class="line"><span class="comment">         Servlet API，没有更新到 Jakarta EE 规范。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet.api&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- springwebmvc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Controller声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler就是controller内部的具体方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestMapping</span>(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ResponseBody</span> 代表向浏览器直接返回数据!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/springmvc/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloController.hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello springmvc!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明springmvc涉及组件信息的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"> <span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"> <span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"> <span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>     </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerMapping <span class="title function_">handlerMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerAdapter <span class="title function_">handlerAdapter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环境搭建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> getServletMappings 返回的地址 设置DispatherServlet对应处理的地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定service / mapper层的配置类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定springmvc的配置类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置dispatcherServlet的处理路径!</span></span><br><span class="line"><span class="comment">   * 一般情况下为 / 代表处理所有请求!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><h3 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="@RequestMapping注解"></a>@RequestMapping注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Mapping</span><br><span class="line">public @interface RequestMapping &#123; &#125;</span><br></pre></td></tr></table></figure><p>@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h5><p>@RequestMapping注解的value属性通过<strong>请求的请求地址</strong>匹配请求映射</p><p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p><p>@RequestMapping注解的value属性<strong>必须设置</strong>，至少通过请求地址匹配请求映射</p><h5 id="method属性"><a href="#method属性" class="headerlink" title="method属性"></a>method属性</h5><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestMapping注解的method属性通过<strong>请求的请求方式</strong>（get或post）匹配请求映射。默认任何请求方式都可以访问</p><p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p><p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><p>处理get请求的映射–&gt;@GetMapping</p><p>处理post请求的映射–&gt;@PostMapping</p><p>处理put请求的映射–&gt;@PutMapping</p><p>处理delete请求的映射–&gt;@DeleteMapping</p><p>2、常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter</p><h5 id="param属性"><a href="#param属性" class="headerlink" title="param属性"></a>param属性</h5><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p><p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系：</p><ol><li><p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p></li><li><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p></li><li><p>“param&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数且param&#x3D;value</p></li><li><p>“param!&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数但是param!&#x3D;value</p></li></ol><h5 id="headers属性"><a href="#headers属性" class="headerlink" title="headers属性"></a>headers属性</h5><p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p><p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p><ol><li><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p></li><li><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p></li><li><p>“header&#x3D;value”：要求请求映射所匹配的请求必须携带header请求头信息且header&#x3D;value</p></li><li><p>“header!&#x3D;value”：要求请求映射所匹配的请求必须携带header请求头信息且header!&#x3D;value</p></li></ol><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><h4 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h4><h5 id="param-和-json参数比较"><a href="#param-和-json参数比较" class="headerlink" title="param 和 json参数比较"></a><strong>param 和 json参数比较</strong></h5><p>  在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p><ol><li><p>参数编码：  </p><p> param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。</p></li><li><p>参数顺序：  </p><p> param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p></li><li><p>数据类型：  </p><p> param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p></li><li><p>嵌套性：  </p><p> param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p></li><li><p>可读性：  </p><p> param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p></li></ol><p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p><h5 id="param参数接收"><a href="#param参数接收" class="headerlink" title="param参数接收"></a>param参数接收</h5><ol><li><p><strong>直接接收</strong></p><p>只要形参数名和类型与传递参数相同，即可自动接收!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以利用形参列表,直接接收前端传递的param参数!</span></span><br><span class="line"><span class="comment">     *    要求: 参数名 = 形参名</span></span><br><span class="line"><span class="comment">     *          类型相同</span></span><br><span class="line"><span class="comment">     * 出现乱码正常，json接收具体解决！！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回前端数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value=&quot;/value&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> name + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@RequestParam注解</strong></p><ul><li>指定绑定的请求参数名</li><li>要求请求参数必须传递</li><li>为请求参数提供默认值</li></ul><p>默认情况下，使用此注解的方法参数是必需的，但可以通过将 @RequestParam 注解的 required 标志设置为 false！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  使用<span class="doctag">@RequestParam</span>注解标记handler方法的形参</span></span><br><span class="line"><span class="comment"> *  指定形参对应的请求参数<span class="doctag">@RequestParam</span>(请求参数名称)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>特殊值</strong></p><ul><li><p>一名多值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  一名多值,可以使用集合接收即可!但是需要使用<span class="doctag">@RequestParam</span>注解指定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/mul&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">mulForm</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hbs = &quot;</span> + hbs);</span><br><span class="line">    <span class="keyword">return</span> hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实体接收</p><p>可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。</p><p>将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名，有对应get&#x2F;set方法！否则无法映射！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以使用 user 对象的属性来接收请求参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="路径参数接收"><a href="#路径参数接收" class="headerlink" title="路径参数接收"></a>路径参数接收</h5><p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p><p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span></span><br><span class="line"><span class="comment"> * 形参列表取值: <span class="doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span></span><br><span class="line"><span class="comment"> *              <span class="doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, </span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, uname = &quot;</span> + uname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="json参数接收"><a href="#json参数接收" class="headerlink" title="json参数接收"></a>json参数接收</h5><p>@RequestBody 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestBody 注解将请求体中的 JSON 数据映射到 Person 类型的 person 参数上，并将其作为一个对象来传递给 addPerson() 方法进行处理。</p><p>问题：<code>org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type &#39;application/json;charset=UTF-8&#39; is not supported]</code>, <code>415 - 不支持的媒体类型</code></p><p>原因：不支持json数据类型处理</p><p>解决：</p><ol><li><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>springmvc handlerAdpater配置json转化器<code>@EnableWebMvc</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="接收Cookie数据"><a href="#接收Cookie数据" class="headerlink" title="接收Cookie数据"></a>接收Cookie数据</h4><p>可以使用 <code>@CookieValue</code> 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</p><p>考虑使用以下 cookie 的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure><p>下面的示例演示如何获取 cookie 值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收请求头数据"><a href="#接收请求头数据" class="headerlink" title="接收请求头数据"></a>接收请求头数据</h4><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p><p>请考虑以下带有标头的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure><p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原生API对象"><a href="#原生API对象" class="headerlink" title="原生API对象"></a>原生API对象</h4><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><p>获取原生对象示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span></span><br><span class="line"><span class="comment"> * 注意: 接收原生对象,并不影响参数接收!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpSession session , HttpServletRequest request,</span></span><br><span class="line"><span class="params">                  HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><h4 id="页面跳转控制"><a href="#页面跳转控制" class="headerlink" title="页面跳转控制"></a>页面跳转控制</h4><p><strong>返回模板视图</strong></p><ol><li><p>准备jsp页面和依赖</p><p> pom.xml依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jsp需要依赖! jstl--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>jsp页面创建</p><p> 建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;</span><br><span class="line">        $&#123;msg&#125;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置jsp视图解析器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>handler返回视图</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  跳转到提交文件页面  /save/jump</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  如果要返回jsp页面!</span></span><br><span class="line"><span class="comment"> *     1.方法返回值改成字符串类型</span></span><br><span class="line"><span class="comment"> *     2.返回逻辑视图名即可    </span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;</span></span><br><span class="line"><span class="comment"> *            + 逻辑视图名 +</span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;jump&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jumpJsp</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;FileController.jumpJsp&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;request data!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>转发和重定向</strong></p><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重定向到 /demo 路径 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 转发到 /demo 路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>将方法的返回值，设置String类型</li><li>转发使用forward关键字，重定向使用redirect关键字</li><li>关键字: &#x2F;路径</li><li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li></ul><h4 id="返回json数据"><a href="#返回json数据" class="headerlink" title="返回json数据"></a>返回json数据</h4><p>导入jackson依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加json数据转化器</p><p>@EnableWebMvc </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ResponseBody</strong></p><p><code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User userParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;userParam = &quot;</span> + userParam);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="comment">//返回的对象,会使用jackson的序列化工具,转成json返回给前端!</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RestController</strong> </p><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。</p><p>RestController源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">   * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回静态资源处理"><a href="#返回静态资源处理" class="headerlink" title="返回静态资源处理"></a>返回静态资源处理</h4><p>资源本身已经是可以直接拿到浏览器上使用的程度了，不需要在服务器端做任何运算、处理</p><p>开启静态资源处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringMVC获取请求参数"><a href="#SpringMVC获取请求参数" class="headerlink" title="SpringMVC获取请求参数"></a>SpringMVC获取请求参数</h3><h4 id="1-通过ServletAPI获取"><a href="#1-通过ServletAPI获取" class="headerlink" title="1. 通过ServletAPI获取"></a>1. 通过ServletAPI获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-通过控制器方法的形参获取请求参数"><a href="#2-通过控制器方法的形参获取请求参数" class="headerlink" title="2. 通过控制器方法的形参获取请求参数"></a>2. 通过控制器方法的形参获取请求参数</h4><p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a th:href=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p><h4 id="3-RequestParam注解"><a href="#3-RequestParam注解" class="headerlink" title="3. @RequestParam注解"></a>3. @RequestParam注解</h4><p>@RequestParam是将<strong>请求参数</strong>和控制器方法的形参创建映射关系</p><p>@RequestParam注解一共有三个属性：</p><p>value：指定为形参赋值的请求参数的参数名</p><p>required：设置是否必须传输此请求参数，默认值为true</p><p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p><p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p><h4 id="4-RequestHeader注解"><a href="#4-RequestHeader注解" class="headerlink" title="4. @RequestHeader注解"></a>4. @RequestHeader注解</h4><p>@RequestHeader是将<strong>请求头信息</strong>和控制器方法的形参创建映射关系</p><p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h4 id="5-CookieValue"><a href="#5-CookieValue" class="headerlink" title="5. @CookieValue"></a>5. @CookieValue</h4><p>@CookieValue是将<strong>cookie数据</strong>和控制器方法的形参创建映射关系</p><p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h4 id="6-通过POJO获取请求参数"><a href="#6-通过POJO获取请求参数" class="headerlink" title="6. 通过POJO获取请求参数"></a>6. 通过POJO获取请求参数</h4><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的<strong>请求参数的参数名和实体类中的属性名一致</strong>，那么请求参数就会为此属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;form th:action=<span class="string">&quot;@&#123;/testpojo&#125;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    性别：&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;sex&quot;</span> value=<span class="string">&quot;男&quot;</span>&gt;男&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;sex&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;女&lt;br&gt;</span><br><span class="line">    年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    邮箱：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;email&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPOJO</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="共享域对象"><a href="#共享域对象" class="headerlink" title="共享域对象"></a>共享域对象</h3><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p><ol><li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li><li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li><li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li><li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li></ol><p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p><h4 id="Request级别属性（共享）域"><a href="#Request级别属性（共享）域" class="headerlink" title="Request级别属性（共享）域"></a>Request级别属性（共享）域</h4><ol><li>使用 Model 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModel</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Model类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Model model)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;requestScopeMessageModel&quot;</span>,<span class="string">&quot;i am very happy[model]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 ModelMap 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModelMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明ModelMap类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        ModelMap modelMap)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="string">&quot;i am very happy[model map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Map 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Map类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    map.put(<span class="string">&quot;requestScopeMessageMap&quot;</span>, <span class="string">&quot;i am very happy[map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用原生 request 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/original&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrOriginalRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 拿到原生对象，就可以调用原生方法执行各种操作</span></span><br><span class="line"><span class="params">        HttpServletRequest request)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    request.setAttribute(<span class="string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="string">&quot;i am very happy[original]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用 ModelAndView 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testAttrByModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建ModelAndView对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">// 2.存入模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;requestScopeMessageMAV&quot;</span>, <span class="string">&quot;i am very happy[mav]&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;target&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Session级别属性（共享）域"><a href="#Session级别属性（共享）域" class="headerlink" title="Session级别属性（共享）域"></a>Session级别属性（共享）域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/session&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//直接对session对象操作,即对会话范围操作!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Application级别属性（共享）域"><a href="#Application级别属性（共享）域" class="headerlink" title="Application级别属性（共享）域"></a>Application级别属性（共享）域</h4><p>  解释：springmvc会在初始化容器的时候，将servletContext对象存储到ioc容器中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/attr/application&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">attrApplication</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    servletContext.setAttribute(<span class="string">&quot;appScopeMsg&quot;</span>, <span class="string">&quot;i am hungry...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringMVC的视图"><a href="#SpringMVC的视图" class="headerlink" title="SpringMVC的视图"></a>SpringMVC的视图</h3><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p><p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p><p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p><h4 id="1-ThymeleafView"><a href="#1-ThymeleafView" class="headerlink" title="1. ThymeleafView"></a>1. ThymeleafView</h4><p>当控制器方法中所设置的视图名称<strong>没有任何前缀时</strong>，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过<strong>转发</strong>的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-转发视图"><a href="#2-转发视图" class="headerlink" title="2. 转发视图"></a>2. 转发视图</h4><p>SpringMVC中默认的转发视图是InternalResourceView</p><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称<strong>以”forward:”为前缀时</strong>，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过<strong>转发</strong>的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-重定向视图"><a href="#3-重定向视图" class="headerlink" title="3. 重定向视图"></a>3. 重定向视图</h4><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称<strong>以”redirect:”为前缀时</strong>，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过<strong>重定向</strong>的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRedirect</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-视图控制器view-controller"><a href="#4-视图控制器view-controller" class="headerlink" title="4. 视图控制器view-controller"></a>4. 视图控制器view-controller</h4><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">    view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br><span class="line">12345Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p><p>&lt;mvc:annotation-driven &#x2F;&gt;</p></blockquote><h3 id="RESTFul"><a href="#RESTFul" class="headerlink" title="RESTFul"></a>RESTFul</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现形式状态转换。</p><p>RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！</p><p><strong>HTTP协议请求方式要求</strong></p><p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table><p><strong>URL路径风格要求</strong></p><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p><p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：GET</td></tr></tbody></table><p><strong>总结</strong></p><p>根据接口的具体动作，选择具体的HTTP协议请求方式</p><p>路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！</p><p>GET和DELETE没有请求体，使用路径参数和param参数，一般参数是id使用路径参数，其他使用param参数</p><p>PUT和POST有请求体，使用请求体（json）</p><h3 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h3><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p><p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，</p><p>ResponseEntity</p><h4 id="1-RequestBody"><a href="#1-RequestBody" class="headerlink" title="1. @RequestBody"></a>1. @RequestBody</h4><p>@RequestBody可以<strong>获取请求体</strong>，需要在控制器方法设置一个<strong>形参</strong>，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/testRequestBody&quot;)</span><br><span class="line">public String testRequestBody(@RequestBody String requestBody)&#123;</span><br><span class="line">    System.out.println(&quot;requestBody:&quot;+requestBody);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>requestBody:username&#x3D;admin&amp;password&#x3D;123456</p><h4 id="2-RequestEntity"><a href="#2-RequestEntity" class="headerlink" title="2. @RequestEntity"></a>2. @RequestEntity</h4><p>RequestEntity<strong>封装请求报文</strong>的一种类型，需要在控制器方法的形参中设置该类型的<strong>形参</strong>，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果： requestHeader:[host:“localhost:8080”, connection:“keep-alive”, content-length:“27”, cache-control:“max-age&#x3D;0”, sec-ch-ua:”” Not A;Brand”;v&#x3D;“99”, “Chromium”;v&#x3D;“90”, “Google Chrome”;v&#x3D;“90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:“1”, origin:“<a href="http://localhost:8080”/">http://localhost:8080”</a>, user-agent:“Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.93 Safari&#x2F;537.36”] </p><p>requestBody:username&#x3D;admin&amp;password&#x3D;123</p><h4 id="3-ResponseBody"><a href="#3-ResponseBody" class="headerlink" title="3. @ResponseBody"></a>3. @ResponseBody</h4><p>@ResponseBody用于标识一个控制器方法，可以将该方法的<strong>返回值直接作为响应报文的响应体响应到浏览器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testResponseBody</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：浏览器页面显示success</p><h4 id="4-RestController注解"><a href="#4-RestController注解" class="headerlink" title="4. @RestController注解"></a>4. @RestController注解</h4><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><h4 id="5-ResponseEntity"><a href="#5-ResponseEntity" class="headerlink" title="5. ResponseEntity"></a>5. ResponseEntity</h4><p>ResponseEntity用于控制器方法的<strong>返回值类型</strong>，该控制器方法的返回值就是响应到浏览器的响应报文</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li>相似点<ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li>不同点<ul><li>工作平台不同<ul><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li>拦截的范围<ul><li>过滤器：能够拦截到的最大范围是整个 Web 应用</li><li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li></ul></li><li>IOC 容器支持<ul><li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li><li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li></ul></li></ul></li></ul><p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器</p><h4 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h4><ol><li><p>创建拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process01Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在处理请求的目标 handler 方法前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.preHandle&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 返回true：放行</span></span><br><span class="line">        <span class="comment">// 返回false：不放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在目标 handler 方法之后，handler报错不执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, modelAndView = &quot;</span> + modelAndView);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 渲染视图之后执行(最后),一定执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, ex = &quot;</span> + ex);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置类添加拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line">        <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置详解</p><ul><li><p>默认拦截全部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>精准配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    <span class="comment">//也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>排除配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排除匹配,排除应该在匹配的范围内排除</span></span><br><span class="line">    <span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">    <span class="comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>())</span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>)</span><br><span class="line">            .excludePathPatterns(<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="拦截器的三个抽象方法"><a href="#拦截器的三个抽象方法" class="headerlink" title="拦截器的三个抽象方法"></a>拦截器的三个抽象方法</h4><p>SpringMVC中的拦截器有三个抽象方法：</p><p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p><p>postHandle：控制器方法执行之后执行postHandle()</p><p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p><h4 id="多个拦截器的执行顺序"><a href="#多个拦截器的执行顺序" class="headerlink" title="多个拦截器的执行顺序"></a>多个拦截器的执行顺序</h4><p>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照<strong>配置顺序</strong>调用各个 preHandle() 方法。</p><p>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照<strong>配置相反的顺序</strong>调用各个 postHandle() 方法。</p><p>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照<strong>配置相反的顺序</strong>调用各个 afterCompletion() 方法。</p><h3 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h3><p>对于异常的处理，一般分为两种方式：</p><ul><li>编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li><li>声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li></ul><p><strong>基于注解异常声明异常处理</strong></p><ol><li><p>声明异常处理控制器类</p><p> 异常处理控制类，统一定义异常处理handler方法！</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RestControllerAdvice</span> = <span class="doctag">@ControllerAdvice</span> + <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明异常处理hander方法</p><p> 异常处理handler方法和普通的handler方法参数接收和响应都一致！</p><p> 只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p><p> 普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理handler </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span></span><br><span class="line"><span class="comment"> * 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 获取异常对象!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回handler处理结果!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerJsonDateException</span><span class="params">(HttpMessageNotReadableException e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当发生空指针异常会触发此方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerNullException</span><span class="params">(NullPointerException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span></span><br><span class="line"><span class="comment"> * 具体异常处理Handler优先级更高!</span></span><br><span class="line"><span class="comment"> * 例如: 发生NullPointerException异常!</span></span><br><span class="line"><span class="comment"> *       会触发handlerNullException方法,不会触发handlerException方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置类扫描控制器类配置，确保异常处理控制类被扫描</p></li></ol><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr></tbody></table><p>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr></tbody></table><p>在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。</p><p>配置 <code>@EnableWebMvc</code>后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 <code>@Validated </code>注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</p><p><strong>使用</strong></p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应用校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.pojo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line">    <span class="meta">@Min(10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line">    <span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//email 邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handler标记和绑定错误收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">                       BindingResult result)</span>&#123;</span><br><span class="line">       <span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p><ul><li><p>@NotNull  (包装类型不为null)</p><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p></li><li><p>@NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p></li><li><p>@NotBlank （字符串，不为null，且不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。</p></li></ul><h3 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h3><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code>  <code>DispatcherServlet</code> 做整体请求处理调度！</p><p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p><p><img src="https://secure2.wostatic.cn/static/no1PDXU3JX5K4cecSAx5oL/image.png?auth_key=1701182665-Yew6dWXqreLS4w5g1EYM4-0-5999817c216ac439566b2b0b3c29996c&file_size=110526"></p><ol><li>DispatcherServlet :  SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！</li><li>HandlerMapping :  SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！</li><li>HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]</li><li><strong>Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！</strong></li><li>ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Cloud-Alibaba</title>
      <link href="/2023/06/23/spring-cloud-alibaba/"/>
      <url>/2023/06/23/spring-cloud-alibaba/</url>
      
        <content type="html"><![CDATA[<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p>一个更易于构建云原生应用的动态<strong>服务发现(<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery">Nacos Discovery</a>)、配置管理(<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">Nacos Config</a>)和服务管理</strong>平台。集<strong>注册中心+配置中心+服务管理</strong> 平台</p><p>Nacos 的关键特性包括: </p><ul><li>服务发现和服务健康监测 </li><li>动态配置服务 </li><li>动态 DNS 服务 </li><li>服务及其元数据管理</li></ul><h3 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h3><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery">Nacos Discovery</a></p><p>管理所有微服务、解决微服务之间调用关系错综复杂、难以维护的问题</p><p>核心功能：</p><ul><li>服务注册</li><li>服务心跳</li><li>服务同步</li><li>服务发现</li><li>服务健康检查</li></ul><h3 id="Nacos-Server部署"><a href="#Nacos-Server部署" class="headerlink" title="Nacos Server部署"></a>Nacos Server部署</h3><p><a href="https://nacos.io/zh-cn/docs/quick-start.html">https://nacos.io/zh-cn/docs/quick-start.html</a></p><ol><li><p>从github下载发行包 <code>https://github.com/alibaba/nacos/releases</code></p></li><li><p>修改配置文件 <code>application.properties</code></p></li><li><p>启动，NACOS2默认启动是集群模式，应将其换为单体模式。</p><p><a href="https://nacos.io/zh-cn/docs/deployment.html">Nacos支持三种部署模式</a></p></li><li><p>访问nocas的管理端，默认的用户名密码是 nocas&#x2F;nocas</p></li></ol><h3 id="Spring-Cloud-Alibaba-Nacos快速开始"><a href="#Spring-Cloud-Alibaba-Nacos快速开始" class="headerlink" title="Spring Cloud Alibaba Nacos快速开始"></a>Spring Cloud Alibaba Nacos快速开始</h3><ol><li><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">版本选型</a></p></li><li><p>搭建client服务</p><ul><li><p>引入依赖</p><p>父Pom中支持spring cloud&amp;spring cloud alibaba, 引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&lt;!‐‐引入springcloud的版本‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐alibaba‐dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当前项目中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐starter‐alibaba‐nacos‐discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties中配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8002</span></span><br><span class="line"><span class="comment">#微服务名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">service‐user</span></span><br><span class="line"><span class="comment">#配置 Nacos server 的地址</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.discovery.server‐addr</span>=<span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><p>更多配置: <a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery</a></p></li></ul></li><li><p>启动springboot应用，nacos管理端界面查看是否成功注册</p></li><li><p>测试</p></li></ol><h3 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h3><p>Nacos 提供用于存储配置和其他元数据的 key&#x2F;value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使 用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置。 </p><p>1.维护性 2.时效性 3.安全性</p><h4 id="搭建nacos-config服务"><a href="#搭建nacos-config服务" class="headerlink" title="搭建nacos-config服务"></a>搭建nacos-config服务</h4><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a></p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐starter‐alibaba‐nacos‐config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加 <code>bootstrap.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">nacos‐config</span></span><br><span class="line"><span class="comment"># 配置中心地址</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server‐addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure><p>spring-cloud-starter-alibaba-nacos-config 对于 yaml 格式也是完美支持的。这个时候只需要完成以下两步：</p><ol><li><p>在应用的 bootstrap.properties 配置文件中显示的声明 dataId 文件扩展名。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.file-extension</span>=<span class="string">yaml</span></span><br></pre></td></tr></table></figure></li><li><p>在 Nacos 的控制台新增一个dataId为yaml为扩展名的配置</p></li></ol></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> applicationContext.getEnvironment().getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userAge</span> <span class="operator">=</span> applicationContext.getEnvironment().getProperty(<span class="string">&quot;user.age&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;user name :&quot;</span>+userName+<span class="string">&quot;; age: &quot;</span>+userAge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="支持自定义-namespace-的配置"><a href="#支持自定义-namespace-的配置" class="headerlink" title="支持自定义 namespace 的配置"></a>支持自定义 namespace 的配置</h4><p>在没有明确指定 <code>$&#123;spring.cloud.nacos.config.namespace&#125;</code> 配置的情况下， 默认使用的是 Nacos 上 Public 这个namespace。如果需要使用自定义的命名空间，可以通过以下配置来实现：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><p>该配置<strong>必须放在 bootstrap.properties 文件中</strong>。此外 <code>spring.cloud.nacos.config.namespace</code> 的值是 namespace 对应的 id，id 值可以在 Nacos 的控制台获取。</p><h4 id="支持自定义-Group-的配置"><a href="#支持自定义-Group-的配置" class="headerlink" title="支持自定义 Group 的配置"></a>支持自定义 Group 的配置</h4><p>在没有明确指定 <code>$&#123;spring.cloud.nacos.config.group&#125;</code> 配置的情况下， 默认使用的是 DEFAULT_GROUP 。如果需要自定义自己的 Group，可以通过以下配置来实现：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">DEVELOP_GROUP</span></span><br></pre></td></tr></table></figure><p>该配置必须放在 bootstrap.properties 文件中。并且在添加配置时 Group 的值一定要和 <code>spring.cloud.nacos.config.group</code> 的配置值一致。</p><h4 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h4><p>@Value注解可以获取到配置中心的值，但是无法动态感知修改后的值，需要利用@RefreshScope注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;common.age&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h2><p>文档：<a href="https://sentinelguard.io/zh-cn/docs/introduction.html">https://sentinelguard.io/zh-cn/docs/introduction.html</a></p><p>Wiki：<a href="https://github.com/alibaba/Sentinel/wiki/">https://github.com/alibaba/Sentinel/wiki/</a></p><p>定义的Sentinel进行资源保护的几个步骤：</p><ol><li>定义资源 </li><li>定义规则 </li><li>检验规则是否生效</li></ol><h3 id="SentinelResource"><a href="#SentinelResource" class="headerlink" title="@SentinelResource"></a>@SentinelResource</h3><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81">注解支持 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p><p>@SentinelResource 注解用来标识资源是否被限流、降级。</p><ul><li><p>value: 定义资源</p></li><li><p>blockHandler: 设置流量降级后的处理方法</p><p>默认该方法必须声明在同一个类中，如果不在一个类中，需要设置blockHandlerClass进行指定</p><p>一定是public，返回值一定要和源方法一致，包含源方法的参数</p><p>可以在参数最后添加 BlockException ，可以区分什么规则的处理方法</p></li><li><p>fallback: 定义的是资源内部发生了异常应该进入的方法 </p></li><li><p>exceptionsToIgnore：配置fallback可以忽略的异常</p></li></ul><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel‐annotation‐aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置切面支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelAspectConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SentinelResourceAspect <span class="title function_">sentinelResourceAspect</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SentinelResourceAspect</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>.UserController中编写测试逻辑，添加@SentinelResource，并配置blockHandler和fallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;hello&quot;, blockHandler = &quot;exceptionHandler&quot;, fallback = &quot;helloFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="type">long</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Hello at %d&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloFallback</span><span class="params">(<span class="type">long</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Halooooo %d&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">exceptionHandler</span><span class="params">(<span class="type">long</span> s, BlockException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// Do some log here.</span></span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Oops, error occurred at &quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里单独演示 blockHandlerClass 的配置.</span></span><br><span class="line">    <span class="comment">// 对应的 `handleException` 函数需要位于 `ExceptionUtil` 类中，并且必须为 public static 函数.</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;test&quot;, blockHandler = &quot;handleException&quot;, blockHandlerClass = &#123;ExceptionUtil.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#2-%E5%90%AF%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8F%B0">控制台 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p><ol><li>获取控制台：您可以从 <a href="https://github.com/alibaba/Sentinel/releases">release 页面</a> 下载最新版本的控制台 jar 包。</li><li>启动 <code>java -jar sentinel-dashboard-1.8.6.jar</code></li></ol><p><strong>Spring Cloud Alibaba整合Sentine</strong></p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐starter‐alibaba‐sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置参数</p><p>添加yml配置，为微服务设置sentinel控制台地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8050</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-sentienl</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8858</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p><a href="https://sentinelguard.io/zh-cn/docs/flow-control.html">https://sentinelguard.io/zh-cn/docs/flow-control.html</a></p><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制， 以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性</p><p><strong>阈值类型</strong></p><ul><li><p>QPS（Query Per Second）：每秒请求数，就是说服务器在一秒的时间内处理了多少个请求。</p></li><li><p>并发线程数 </p><p>Sentinel 并发控制不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目 （正在执行的调用数目），如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离。并发数控制通常在调用端 进行配置。</p></li></ul><p><strong>流控模式</strong></p><ul><li><p>直接： 资源调用达到设置的阈值后直接被流控抛出异常 </p></li><li><p>关联</p><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写 操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本 身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，read_db 和 write_db 这两个资源分别代表数据库读写，我们可以给 read_db 设置限流规则来达到写优先的目的：设置 strategy 为 RuleConstant.STRATEGY_RELATE 同时设置 refResource 为 write_db。这样当写库操作过于频繁时，读数据的请求会被限流。</p></li><li><p>链路：根据调用链路入口限流。</p></li></ul><p><strong>流控效果</strong></p><ul><li><p>快速失败：当QPS超过任意规则的阈值后，新的请求就会被 立即拒绝，拒绝方式为抛出FlowException</p></li><li><p>Warm Up（激增流量）：当系统长期处于低水位的情况下，当流量 突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐 增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p><p>冷加载因子: codeFactor 默认是3，即请求 QPS 从 threshold &#x2F; 3 开始，经预热时长逐渐升至设定的 QPS 阈值。</p></li><li><p>排队等待（脉冲流量）：严格控制请求通过的间隔时间，也即是让请 求以均匀的速度通过，对应的是漏桶算法。</p></li></ul><h4 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h4><p><a href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">https://sentinelguard.io/zh-cn/docs/circuit-breaking.html</a></p><h4 id="热点参数流控"><a href="#热点参数流控" class="headerlink" title="热点参数流控"></a>热点参数流控</h4><p><a href="https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html">https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html</a></p><p>注意： </p><ol><li>热点规则需要使用@SentinelResource(“resourceName”)注解，否则不生效 </li><li>参数必须是7种基本数据类型才会生效</li></ol><h4 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h4><p><a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html</a></p><h4 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h4><p><a href="https://sentinelguard.io/zh-cn/docs/origin-authority-control.html">https://sentinelguard.io/zh-cn/docs/origin-authority-control.html</a></p><h3 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h3><h4 id="原始模式"><a href="#原始模式" class="headerlink" title="原始模式"></a>原始模式</h4><p>如果不做任何修改，Dashboard 的推送规则方式是通过 API 将规则推送至客户端并直接更 新到内存中</p><p>这种做法的好处是简单，无依赖；坏处是应用重启规则就会消失，仅用于简单测试，不能 用于生产环境。</p><h4 id="pull模式"><a href="#pull模式" class="headerlink" title="pull模式"></a>pull模式</h4><p>pull 模式的数据源（如本地文件、RDBMS 等）一般是可写入的。使用时需要在客户端注册 数据源：将对应的读数据源注册至对应的 RuleManager，将写数据源注册至 transport 的 WritableDataSourceRegistry 中。</p><h4 id="push模式"><a href="#push模式" class="headerlink" title="push模式"></a>push模式</h4><p>生产环境下一般更常用的是 push 模式的数据源。对于 push 模式的数据源,如远程配置中心 （ZooKeeper, Nacos, Apollo等等），推送的操作不应由 Sentinel 客户端进行，而应该经控 制台统一进行管理，直接进行推送，数据源仅负责获取配置中心推送的配置并更新到本 地。因此推送规则正确做法应该是 <strong>配置中心控制台&#x2F;Sentinel 控制台 → 配置中心 → Sentinel 数据源 → Sentinel</strong>，而不是经 Sentinel 数据源推送至配置中心。这样的流程就非 常清晰了：</p><p><strong>基于Nacos配置中心控制台实现推送</strong></p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel‐datasource‐nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Nacos配置中心配置流控规则</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TestResource&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">10.0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li><li><p>配置application.yml配置文件 <code>spring.cloud.datasource</code>中参数</p></li></ol><h2 id="微服务负载均衡器Ribbon"><a href="#微服务负载均衡器Ribbon" class="headerlink" title="微服务负载均衡器Ribbon"></a>微服务负载均衡器Ribbon</h2><p><strong>客户端负载均衡</strong></p><p>例如spring cloud中的ribbon，客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择一个服务器，然后进行访问，这是 客户端负载均衡；即在客户端就进行负载均衡算法分配。</p><p><strong>服务端负载均衡</strong></p><p>例如Nginx，通过Nginx进行负载均衡，先发送请求，然后通过负载均衡算法，在多个服务器之间选择一个进行访问；即在服务器端再进 行负载均衡算法分配。</p><p><strong>常见负载均衡算法</strong></p><ul><li>随机，通过随机选择服务进行执行，一般这种方式使用较少; </li><li>轮训，负载均衡默认实现方式，请求来之后排队处理; </li><li>加权轮训，通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力; </li><li>地址Hash，通过客户端请求的地址的HASH值取模映射进行服务器调度。 ip —&gt;hash </li><li>最小链接数，即使请求均衡了，压力不一定会均衡，最小连接数法就是根据服务器的情况，比如请求积压数等参数，将请求分 配到当前压力最小的服务器上。 最小活跃数</li></ul><p><strong>Ribbon负载均衡策略</strong></p><ul><li>RandomRule, 随机选择一个服务器</li><li>RoundRobinRule, 轮询</li><li>RetryRule, 轮询基础上进行重试</li><li>WeightedResponseTimeRule, 权重越大，服务器被选中执行任务概率越大</li><li>ClientConfigEnabledRoundRobinRule, 轮询</li><li>BestAvailableRule, 过滤生效的服务实例的功能，顺便找出并发请求最小的服务实例来使用</li><li>ZoneAvoidanceRule, 默认规则，复合判断server所在区域的性能和server的可用性选择服务器</li><li>AvailabilityFilteringRule，先过滤掉故障实例，再选择并发较小的实例</li></ul><h3 id="Spring-Cloud-LoadBalancer"><a href="#Spring-Cloud-LoadBalancer" class="headerlink" title="Spring Cloud LoadBalancer"></a>Spring Cloud LoadBalancer</h3><p>Spring Cloud LoadBalancer是Spring Cloud官方自己提供的客户端负载均衡器, 用来替代 Ribbon。</p><p>Spring官方提供了两种负载均衡的客户端：</p><p><strong>RestTemplate</strong></p><p>RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。默认情况下，RestTemplate默认依赖 jdk的HTTP连接工具。 </p><p><strong>WebClient</strong></p><p>WebClient是从Spring WebFlux 5.0版本开始提供的一个非阻塞的基于响应式编程的进行Http请求的客户端工具。它的响应式编程的基于Reactor的。WebClient中提供了标准Http请求方式对 应的get、post、put、delete等方法，可以用来发起相应的请求。</p><h4 id="RestTemplate整合LoadBalancer"><a href="#RestTemplate整合LoadBalancer" class="headerlink" title="RestTemplate整合LoadBalancer"></a><strong>RestTemplate整合LoadBalancer</strong></h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!‐‐ LoadBalancer ‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐starter‐loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 提供了RestTemplate支持 ‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ nacos服务注册与发现 移除ribbon支持‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐starter‐alibaba‐nacos‐discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐starter‐netflix‐ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>nacos-discovery中引入了ribbon，需要移除ribbon的包，也可以在yml中设置spring.cloud.loadbalancer.ribbon.enabled属性为false。</p></li><li><p>用@LoadBalanced注解配置RestTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/findOrderByUserId/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://mall‐order/order/findOrderByUserId/&quot;</span>+id;</span><br><span class="line"><span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(url,R.class);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是Netflix开发的声明式、模板化的HTTP客户端，其灵感来自Retrofit、JAXRS-2.0以及 WebSocket。Feign可帮助我们更加便捷、优雅地调用HTTP API。</p><p>Spring Cloud openfeign对Feign进行了增强，使其支持Spring MVC注解，另外还整合了 Ribbon和Nacos，从而使得Feign的使用更加方便</p><p><strong>Spring Cloud Alibaba快速整合OpenFeign</strong></p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!‐‐ openfeign 远程调用 ‐‐&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐cloud‐starter‐openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写调用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;mall‐order&quot;,path = &quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderFeignService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用端在启动类上添加@EnableFeignClients注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallUserFeignDemoApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(MallUserFeignDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发起调用，像调用本地方式一样调用远程服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">OrderFeignService orderFeignService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/findOrderByUserId/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">findOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line"><span class="comment">//feign调用</span></span><br><span class="line"><span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> orderFeignService.findOrderByUserId(id);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Spring-Cloud-Feign的自定义配置及使用"><a href="#Spring-Cloud-Feign的自定义配置及使用" class="headerlink" title="Spring Cloud Feign的自定义配置及使用"></a>Spring Cloud Feign的自定义配置及使用</h3><h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><ol><li><p>定义一个配置类，指定日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意： 此处配置@Configuration注解就会全局生效，如果想指定对应微服务生效，就不能配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志级别：</p><ul><li>NONE【性能最佳，适用于生产】：不记录任何日志（默认值）。 </li><li>BASIC【适用于生产环境追踪问题】：仅记录请求方法、URL、响应状态代码以及 执行时间。 </li><li>HEADERS：记录BASIC级别的基础上，记录请求和响应的header。 </li><li>FULL【比较适用于开发及测试环境定位问题】：记录请求和响应的header、body 和元数据。</li></ul></li><li><p>局部配置，让调用的微服务生效，在@FeignClient 注解中指定使用的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定configuration, 注意FeignConfig不能添加@Configuration</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;mall-order&quot;, path = &quot;/order&quot;, configuration = FeignConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderFeignService</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在yml配置文件中执行 Client 的日志级别才能正常输出日志，格式是”logging.level.feign接口包路径 &#x3D;debug”</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">  <span class="attr">com.tuling.mall.feigndemo.feign:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring-Cloud-Alibaba </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring-Cloud-Alibaba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2023/06/21/markdown/"/>
      <url>/2023/06/21/markdown/</url>
      
        <content type="html"><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><ul><li>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</li></ul><hr><h4 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h4><ul><li><p><strong>换行</strong>：段落换行使用两个以上空格加上回车</p></li><li><p><strong>字体</strong>：</p></li></ul><p>​*斜体*</p><p>​_斜体_</p><p>​**粗体**</p><p>​**粗体**</p><p>​***粗斜体***</p><p>​___粗斜体___</p><ul><li><strong>分割线</strong>：</li></ul><p>​你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西</p><ul><li><strong>删除线</strong>：</li></ul><p>​如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可。</p><ul><li><strong>下划线</strong>：</li></ul><p>​下划线可以通过 HTML 的 <strong><u></strong> 标签来实现。例如：&lt;u&gt;文本&lt;&#x2F;u&gt;</p><hr><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li><strong>无序表</strong>：无序列表使用星号(<em>****)、加号(<strong>+</strong>)或是减号(</em>*-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</li><li><strong>有序表</strong>：使用数字并加上 <strong>.</strong> 号来表示</li><li><strong>列表嵌套</strong>：子列表中的选项前面添加两个或四个空格即可</li></ul><hr><h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><ul><li>区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号。另外区块是可以嵌套的，一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推。</li></ul><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><p>用 <strong>&#96;&#96;&#96;</strong> 包裹一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><ul><li>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><ul><li><strong>我们可以设置表格的对齐方式：</strong><ul><li><p><strong>-:</strong> 设置内容和标题栏居右对齐。</p></li><li><p><strong>:-</strong> 设置内容和标题栏居左对齐。</p></li><li><p><strong>:-:</strong> 设置内容和标题栏居中对齐。</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><hr><h4 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h4><ul><li><p><strong>转义</strong>：使用反斜杠转义特殊字符</p></li><li><p><strong>公式</strong>：使用 <a href="https://github.com/Khan/KaTeX">KaTeX</a> 或者 <a href="https://github.com/mathjax/MathJax">MathJax</a> 来渲染数学表达式。</p><ul><li><code>$...$</code> 或者 <code>\(...\)</code> 中的数学表达式将会在行内显示。</li><li><code>$$...$$</code> 或者 <code>\[...\]</code> 或者 &#96;&#96;&#96;&#96;math&#96; 中的数学表达式将会在块内显示。</li></ul></li><li><p><strong><a href="https://www.runoob.com/markdown/md-advance.html">流程图、时序图、甘特图</a></strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
