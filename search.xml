<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java</title>
      <link href="/2023/09/14/java/"/>
      <url>/2023/09/14/java/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><ul><li><p>删除行(delete line)：<code>ctrl</code>+<code>d</code></p></li><li><p>复制行(duplicate)：<code>ctrl</code>+<code>alt</code>+向下箭头</p></li><li><p>补全：<code>alt</code>+<code>/</code></p></li><li><p>注释：<code>ctrl</code>+<code>/</code></p></li><li><p>导入该行需要的类：先配置<code>Auto import</code>, <code>alt</code>+<code>enter</code></p></li><li><p>快速格式化代码：<code>ctrl</code>+<code>alt</code>+<code>L</code></p></li><li><p>快速运行代码(run)：<code>ctrl</code>+<code>R</code></p></li><li><p>生成代码：<code>alt</code>+<code>insert</code></p></li><li><p>查看类的层级关系：<code>ctrl</code>+<code>H</code></p></li><li><p>定位方法：<code>ctrl</code>+<code>B</code></p></li><li><p>自动创建变量名：通过在后面加<code>.var</code></p></li><li><p>模板：file-&gt;settings-&gt;editor-&gt;Live templates-&gt;查看模板快捷键和增加自己的模板</p></li></ul><h3 id="JAVA开发注意事项和细节"><a href="#JAVA开发注意事项和细节" class="headerlink" title="JAVA开发注意事项和细节"></a>JAVA开发注意事项和细节</h3><ul><li><p>执行入口是<code>main()</code>方法</p><p><code>public static void main(String[] args)&#123;...&#125;</code></p></li><li><p>一个源文件中最多只能有一个public类，其他类个数不限。也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。</p></li><li><p>如果源文件包含一个public类，则文件名必须按该类命名</p></li></ul><h3 id="JAVA常用转义字符"><a href="#JAVA常用转义字符" class="headerlink" title="JAVA常用转义字符"></a>JAVA常用转义字符</h3><ul><li>\t：制表位，实现对齐</li><li>\n：换行</li><li>\\：一个\</li><li>\“：”</li><li>\‘：’</li><li>\r：一个回车</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>单行注释：&#x2F;&#x2F;</p></li><li><p>多行注释：&#x2F;*    *&#x2F;，不允许多行注释嵌套</p></li><li><p>文档注释：<code>javadoc -d 文件夹名 -xx -yy file.java</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @author xx</span><br><span class="line">  * @version yy</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>标签</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">@author</td><td align="center">标识一个类的作者</td><td align="center">@author description</td></tr><tr><td align="left">@deprecated</td><td align="center">指名一个过期的类或成员</td><td align="center">@deprecated description</td></tr><tr><td align="left">{@docRoot}</td><td align="center">指明当前文档根目录的路径</td><td align="center">Directory Path</td></tr><tr><td align="left">@exception</td><td align="center">标志一个类抛出的异常</td><td align="center">@exception exception-name explanation</td></tr><tr><td align="left">{@inheritDoc}</td><td align="center">从直接父类继承的注释</td><td align="center">Inherits a comment from the immediate surperclass.</td></tr><tr><td align="left">{@link}</td><td align="center">插入一个到另一个主题的链接</td><td align="center">{@link name text}</td></tr><tr><td align="left">{@linkplain}</td><td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td align="center">Inserts an in-line link to another topic.</td></tr><tr><td align="left">@param</td><td align="center">说明一个方法的参数</td><td align="center">@param parameter-name explanation</td></tr><tr><td align="left">@return</td><td align="center">说明返回值类型</td><td align="center">@return explanation</td></tr><tr><td align="left">@see</td><td align="center">指定一个到另一个主题的链接</td><td align="center">@see anchor</td></tr><tr><td align="left">@serial</td><td align="center">说明一个序列化属性</td><td align="center">@serial description</td></tr><tr><td align="left">@serialData</td><td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td align="center">@serialData description</td></tr><tr><td align="left">@serialField</td><td align="center">说明一个ObjectStreamField组件</td><td align="center">@serialField name type description</td></tr><tr><td align="left">@since</td><td align="center">标记当引入一个特定的变化时</td><td align="center">@since release</td></tr><tr><td align="left">@throws</td><td align="center">和 @exception标签一样.</td><td align="center">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td align="left">{@value}</td><td align="center">显示常量的值，该常量必须是static属性。</td><td align="center">Displays the value of a constant, which must be a static field.</td></tr><tr><td align="left">@version</td><td align="center">指定类的版本</td><td align="center">@version info</td></tr></tbody></table></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li><p>整数类型：byte[1], short[2], int[4], long[8]。long类型后面要声明<code>l</code>或<code>L</code> </p></li><li><p>浮点类型：float[4], double[8]。默认double，float要加声明<code>l</code>或<code>L</code></p></li><li><p>字符类型：char[2]</p></li><li><p>布尔类型：boolean[1]</p></li></ul><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul><li><p>类(class)</p></li><li><p>接口(interface)</p></li><li><p>数组([])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义：数据类型[] 数组名 = new 数据类型[大小]</span><br><span class="line"> 数据类型 数组名[] = new 数据类型[大小]</span><br><span class="line"> 数据类型[][] 数组名 = new 数据类型[大小][大小]</span><br><span class="line"> </span><br><span class="line">数组默认情况下是引用传递，赋的值是地址</span><br><span class="line">数组拷贝：先开辟新空间，然后逐一拷贝元素</span><br><span class="line">数组扩容：定义一个更大的数组，然后使用引用传递（数组直接赋值）</span><br><span class="line"></span><br><span class="line">二维数组:多个一维数组组成，一维数组大小不要求相同</span><br><span class="line">int[][] arr = new int[3][]</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">arr[i] = new int[i+1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li><p>自动类型转换</p><ul><li><p>精度小的类型自动转换为精度大的类型</p></li><li><p>byte、short不能与char相互自动转换</p></li><li><p>byte, short, char三者之间可以计算，在计算时首先转换为int类型</p></li><li><p>boolean类型不参与自动转换</p></li></ul></li><li><p>强制类型转换: 使用强制转换符<code>()</code></p><ul><li>强制符号只针对最近的操作数有效，可以使用小括号提升优先级</li></ul></li><li><p>基本数据类型和字符串之间转换</p><ul><li><p>基本数据类型-&gt;字符串：基本数据类型 + “”</p></li><li><p>字符串-&gt;基本数据类型：通过基本数据类型的包装类调用parseXXX方法即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = Integer.parseInt(s);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p>取模：本质：a%b &#x3D; a - a &#x2F; b * b</p><p>a为小数，则：a%b &#x3D; a - (int)a &#x2F; b * b</p></li><li><p>短路与(&amp;&amp;)和逻辑与(&amp;)：短路与第一个为false，第二个不判断；逻辑与不管第一个如何都要判断第二个条件</p></li><li><p>短路或(||)和逻辑或(|)：短路或第一个为true，第二个不判断；逻辑或不管第一个如何都要判断第二个条件</p></li><li><p>符合赋值运算会进行类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 2;</span><br><span class="line">b+=2; //等价于b = (byte)(b + 2);</span><br></pre></td></tr></table></figure></li></ul><h3 id="键盘键入"><a href="#键盘键入" class="headerlink" title="键盘键入"></a>键盘键入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//引入Scanner类所在的包</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">//创建对象</span><br><span class="line">Scanner myScaner = new Scanner(System.in);</span><br><span class="line">//使用相关方法接收输入</span><br><span class="line">String name = myScanner.next();</span><br><span class="line">int age = myScanner.nextInt();</span><br></pre></td></tr></table></figure><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><ul><li>二进制：以<code>0b</code>或<code>0B</code>开头</li><li>八进制：以<code>0</code>开头</li><li>十六进制：以<code>0x</code>或<code>0X</code>开头</li></ul><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><ul><li>break可以通过标签指明要终止的是哪一层语句块，实际开发中尽量不用</li></ul><h3 id="JAVA内存结构分析"><a href="#JAVA内存结构分析" class="headerlink" title="JAVA内存结构分析"></a>JAVA内存结构分析</h3><p>创建对象过程：</p><ol><li>加载类信息（属性和方法，只会加载一次）</li><li>堆中分配空间，进行默认初始化，返回地址</li><li>指定初始化</li></ol><ul><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象（对象、数组等）</li><li>方法区：常量池（常量，比如字符串）、类加载信息</li></ul><h3 id="方法使用细节"><a href="#方法使用细节" class="headerlink" title="方法使用细节"></a>方法使用细节</h3><ul><li>同一个类中的方法直接调用，不需要创建对象；跨类的方法使用对象调用</li><li>基本数据类型传参机制：传递值；引用数据类型传参机制：传递地址</li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li><p>java中允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。通过可变参数实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回类型 方法名（数据类型... 形参名）&#123;&#125;</span><br><span class="line">public int sum(int... nums)&#123;&#125;//nums当作数组使用</span><br></pre></td></tr></table></figure></li><li><p>可变参数实参可以是数组，可变参数的本质就是数组</p></li><li><p>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</p></li><li><p>一个形参列表只能出现一个可变参数</p></li></ul><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 方法名（形参列表）&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器没有返回值</li><li>方法名和类名一样</li><li>构造器的调用系统自动完成</li><li>没有定义构造器，系统自动给类生成一个默认无参构造器；一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显示的定义一下。</li></ul><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ul><li>调用本类构造器：<code>this(参数列表)</code>，只能在构造器中使用且必须放在第一条语句</li><li>只能在类定义的方法中用来访问类属性</li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li><p>作用：区分相同名字的类；管理类；控制访问范围</p></li><li><p>基本语法：<code>package 包名;</code></p></li><li><p>命名规范：一般小写。一般<code>com.公司名.项目名.业务模块</code></p></li></ul><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><table><thead><tr><th>访问级别</th><th>修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>公开</td><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>受保护</td><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>默认</td><td></td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>私有</td><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>修饰符可以用来修饰属性，成员方法和类</li><li>只有默认和<code>public</code>才能修饰类</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>隐藏细节，对数据进行验证以保证合理合法性</p><p>封装实现步骤：1.属性私有化；2.提供一个公共的set方法对属性进行判断和赋值；3.提供一个公共的get方法获取属性</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>子类继承了所有属性和方法，但是私有属性和方法不能在子类直接访问，要通过父类公共的方法</p></li><li><p>子类必须调用父类的构造器完成父类的初始化</p></li><li><p>当创建子类的对象时，默认总会区调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super(参数列表);</code>去指定使用父类的哪个构造器完成父类的初始化工作，否则编译不会通过。</p></li><li><p><code>super()</code>使用时必须放在构造器第一行</p></li><li><p><code>super()</code>和<code>this()</code>都只能放在构造器第一行，因此不能共存在一个构造器</p></li><li><p>所有类都是<code>Object</code>类的子类</p></li><li><p>子类只能继承一个父类，即单继承机制</p></li></ul><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super代表父类的引用，用于访问父类的属性、方法、构造器。</p><p>就近原则，如果父类没有则往上查找。</p><ul><li>访问父类的属性，但不能访问父类的私有属性 <code>super.name</code></li><li>访问父类的方法，但不能访问父类的私有方法</li><li>访问父类的构造器，只能放在构造器第一句 <code>super(参数列表)</code></li></ul><table><thead><tr><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>访问属性</td><td>访问本类中属性，如果没有从父类中继续查找</td><td>从父类开始查找属性</td></tr><tr><td>调用方法</td><td>访问本类中方法，如果没有从父类中继续查找</td><td>从父类开始查找方法</td></tr><tr><td>调用构造器</td><td>调用本类构造器，必须放在首行</td><td>调用父类构造器，必须放在首行</td></tr><tr><td>特殊</td><td>表示当前对象</td><td>子类中访问父类对象</td></tr></tbody></table><h3 id="方法重写-x2F-覆盖"><a href="#方法重写-x2F-覆盖" class="headerlink" title="方法重写&#x2F;覆盖"></a>方法重写&#x2F;覆盖</h3><ul><li>子类的方法的参数，方法名称必须和父类一样</li><li>子类方法的返回类型和父类一样，或者是父类返回类型的子类，例如<code>public Object getInfo()&#123;&#125;</code>和<code>public String getInfo()&#123;&#125;</code></li><li>子类方法不能缩小父类方法的访问权限</li></ul><table><thead><tr><th>名称</th><th>发生范围</th><th>方法名</th><th>参数列表</th><th>返回类型</th><th>修饰符</th></tr></thead><tbody><tr><td>重载(overload)</td><td>本类</td><td>相同</td><td>不同</td><td>无要求</td><td>无要求</td></tr><tr><td>重写(override)</td><td>父子类</td><td>相同</td><td>相同</td><td>返回类型和父类一致，或者是其子类</td><td>不能缩小父类方法的访问范围</td></tr></tbody></table><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>重载和重写</li><li>对象的多态<ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时就确定了，不能改变</li><li>运行类型是可以变化的</li><li>编译类型看定义时<code>=</code>左边，运行类型看<code>=</code>右边</li></ul></li><li>多态的前提是：两个对象存在继承关系</li><li>多态的向上转型<ul><li>本质：父类的引用指向子类对象</li><li>语法：<code>父类 引用名 = new 子类();</code></li><li>可以调用父类的所有成员（需要遵守访问权限）；不能调用子类中的特有成员；最终运行效果看子类的具体实现</li></ul></li><li>向下转型<ul><li>语法：<code>子类 引用名 = (子类类型) 父类引用</code></li><li>只能强转父类的引用，不能强转父类的对象</li><li>要求父类对象的引用必须指向当前目标类型的对象</li><li>可以调用子类类型中的所有成员</li></ul></li></ul><h3 id="属性重写问题"><a href="#属性重写问题" class="headerlink" title="属性重写问题"></a>属性重写问题</h3><ul><li><p>属性没有重写之说，属性的值看编译类型</p></li><li><p><code>instanceof</code>比较操作符，用于判断对象的<strong>运行类型</strong>是否属于XX类型或XX类型的子类型</p></li></ul><h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><ul><li>当调用对象方法时，该方法会和该对象的<strong>内存地址&#x2F;运行类型</strong>绑定</li><li>当调用对象属性时，<strong>没有动态绑定机制</strong>，哪里声明哪里使用</li></ul><h3 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h3><ul><li><p>数组的定义类型为父类，保存的实际类型是子类</p></li><li><p>调用子类特有的方法时，先用<code>instanceof</code>判断，再向下转型</p></li></ul><h3 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h3><ul><li>方法定义的形参为父类类型，实参允许为子类类型</li></ul><h3 id="x3D-x3D-运算符"><a href="#x3D-x3D-运算符" class="headerlink" title="&#x3D;&#x3D;运算符"></a>&#x3D;&#x3D;运算符</h3><ul><li>既可以判断基本类型，又可以判断引用类型</li><li>判断基本类型，判断的是值是否相等；判断引用类型，判断的是地址是否相等</li><li>只要有基本数据类型，则判断的是值是否相等</li></ul><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><ul><li>equals是Object类中的方法，只能判断引用类型</li></ul><h3 id="类变量-x2F-静态变量"><a href="#类变量-x2F-静态变量" class="headerlink" title="类变量&#x2F;静态变量"></a>类变量&#x2F;静态变量</h3><ul><li><p>定义：<code>修饰符 static 数据类型 变量名;</code>或<code>static 修饰符 数据类型 变量名;</code></p></li><li><p>访问：<code>类名.变量名;</code>或<code>对象名.变量名</code></p></li><li><p><code>static</code>变量被对象所共享，在类加载的时候就生成</p></li><li><p>静态变量保存再class实例的尾部，而class对象保存在堆中</p></li><li><p>生命周期为类加载到类消亡</p></li></ul><h3 id="类方法-x2F-静态方法"><a href="#类方法-x2F-静态方法" class="headerlink" title="类方法&#x2F;静态方法"></a>类方法&#x2F;静态方法</h3><p>当方法中不涉及任何对象相关的成员或一些通用的方法，可以设计成静态方法提高开发效率</p><ul><li><p>定义：<code>修饰符 static 返回类型 方法名()&#123;&#125;</code></p></li><li><p>访问：<code>类名.方法名;</code></p></li><li><p>类方法和普通方法都随着类加载而加载，将结构信息存储到方法区</p></li><li><p>类方法中<strong>不允许使用和对象有关的关键字</strong>，如<code>this</code>和<code>super</code></p></li><li><p><strong>静态方法只能访问静态变量或静态方法</strong></p></li></ul><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><ul><li>main方法是虚拟机调用，访问权限必须是public</li><li>执行main方法时不必创建对象，所以必须是static</li><li>接收String类型的数组形参，保存运行时传递的参数</li><li>main方法中可以直接使用所在类的静态属性和静态方法；访问非静态成员，必须创建对象去调用</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块又叫初始化块，在加载类或创建对象时隐式调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">代码</span><br><span class="line">&#125;; //;可以省略</span><br></pre></td></tr></table></figure><ul><li><p>修饰符只能选<code>static</code>，分别称为静态代码块和普通代码块。静态代码块随<strong>类的加载</strong>而执行，只执行一次，而普通代码块每<strong>创建对象</strong>都会执行</p></li><li><p>静态代码块只能调用静态成员，普通代码块可以调用任意成员</p></li><li><p>好处：</p><ul><li>相当于另一种形式的构造器，可以做初始化操作，代码块的调用优先于构造器</li><li>如果多个构造器中都有重复语句，可以抽取到代码块中，提高复用性</li></ul></li></ul><p><strong>类什么时候加载？</strong></p><ul><li>创建对象实例（new)</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时</li></ul><p><strong>创建一个对象时，在一个类调用顺序</strong></p><ol><li>调用静态代码块和静态属性初始化（多个则按照定义顺序）</li><li>普通代码块和普通属性初始化</li><li>调用构造方法。构造器的最前面其实隐藏了<code>super()</code>和调用普通代码块</li></ol><p><strong>创建一个子类对象时，调用顺序</strong></p><ol><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性初始化</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性初始化</li><li>子类的构造方法</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>对某一个类只能存在一个对象实例，并且对该类只提供一个取得对象实例的方法</p><ul><li><p>饿汉式</p><ol><li>构造器私有化</li><li>类的内部创建私有静态对象</li><li>向外提供一个静态的公有方法</li></ol></li><li><p>懒汉式</p><ol><li>构造器私有化</li><li>类的内部定义一个私有静态对象属性</li><li>向外提供一个静态的共有方法，返回对象</li></ol></li><li><p>区别</p><ul><li>最主要区别在于创建对象的时机不同：饿汉式在类加载时就创建对象实例，懒汉式在使用时才创建</li><li>饿汉式不存在线程安全问题，懒汉式存在</li><li>饿汉式存在资源浪费的可能</li></ul></li></ul><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul><li><p>使用场景</p><ul><li>不希望类被继承 <code>final class 类名</code></li><li>不希望父类的某个方法被子类覆盖&#x2F;重写时 <code>修饰符 final 返回类型 方法名</code></li><li>不希望类的某个属性被修改 <code>修饰符 final 类型 变量名</code> </li><li>不希望某个局部变量被修改 <code>final 变量名</code></li></ul></li><li><p>final修饰的属性一般为常量，一般用<code>XX_XX</code>来命名</p></li><li><p>修饰的属性必须赋初值，以后不能修改，初始化位置：</p><ol><li>定义时</li><li>在构造器中</li><li>在代码块中</li></ol></li><li><p>修饰静态属性时，初始化位置：</p><ol><li>定义时</li><li>静态代码块</li></ol></li><li><p>类不是final类，但含有final方法，则该方法不能重写，但是可以被继承</p></li><li><p>final不能修饰构造器</p></li><li><p>final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理</p></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>某些方法不确定实现时可以声明为抽象方法让子类来实现，含抽象方法的类称为抽象类</p><p>声明为抽象方法：<code>public abstract void eat();</code> <strong>没有方法体</strong>，此时类也必须声明为<code>abstract</code>类</p><ul><li><p>抽象类不能被实例化</p></li><li><p>抽象类不一定要包含<code>abstract</code>方法，一旦包含<code>abstract</code>方法就必须声明为抽象类</p></li><li><p><code>abstract</code>只能用于声明类和方法</p></li><li><p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类</p></li><li><p>抽象方法不能用<code>private</code>, <code>final</code>, <code>static</code>来修饰，因为这些关键字于重写相违背。静态方法可以被子类继承，但不能被重写</p></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法实现出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">//属性</span><br><span class="line">//方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">//自己属性</span><br><span class="line">//自己方法</span><br><span class="line">//必须实现的接口的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>JDK7.0</code>之前 接口里的所有方法都没有方法体，即都是抽象方法；<code>JDK8.0</code>后接口可以有静态方法（加<code>static</code>），默认方法（加<code>default</code>关键字修饰），也就是说接口中可以有方法的具体实现</li><li>接口不能被实例化</li><li>接口中所有方法都是public方法，接口中抽象方法可以不用abstract修饰</li><li>一个普通类实现接口就必须将该接口的所有方法都实现</li><li>抽象类实现接口可以不用实现接口的方法</li><li>一个类可以同时实现多个接口</li><li>接口中的属性只能是final的，而且是<code>public static final</code>修饰，通过<code>接口名.属性</code>访问</li><li>接口不能继承类，但可以继承别的接口</li><li>接口的修饰符只能是public和默认，和类一样</li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类。内部类最大的特点是可以直接访问私有属性，并且可以直接体现类之间的包含关系。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>定义在外部类局部位置上，比如方法内：<ul><li>局部内部类（有类名）</li><li>匿名内部类（没有类名）<strong>重点！！！</strong></li></ul></li><li>定义在外部类的成员位置上：<ul><li>成员内部类</li><li>静态内部类（用static修饰）</li></ul></li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul><li>内部类可以直接访问外部类的所有成员，包括私有的；外部类先创建内部类的对象再进行调用，必须在作用域中</li><li>不能添加访问修饰符，因为它的地位是一个局部变量，局部变量是不能使用修饰符的。但可以使用final修饰</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.this.成员</code>访问</li></ul><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>一个接口&#x2F;类的方法的某个实现方式在程序中<strong>只会执行一次</strong>，但为了使用它，我们需要创建它的实现类&#x2F;子类去实现重写。此时可以使用匿名内部类的方式，可以<strong>无需创建新的类，减少代码冗余</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new A()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;.cry();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = new A()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">a.cry();</span><br></pre></td></tr></table></figure><ul><li><p>匿名内部类既是一个类的定义，同时也是一个对象</p></li><li><p>可以访问外部类的所有成员，包括私有的</p></li><li><p>不能添加修饰符，因为它的地位就是一个局部变量</p></li><li><p>作用域：仅仅是在定义它的方法或代码块中</p></li><li><p>外部其他类不能访问匿名类</p></li><li><p>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.this.成员</code>访问</p></li><li><p>可以当作实参直接传递，简洁高效</p></li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul><li><p>定义在外部类的成员位置，并且<strong>没有static修饰</strong></p></li><li><p>可以直接使用外部类的所有成员，包括私有成员</p></li><li><p>可以添加任意的访问修饰符，因为它的地位是一个成员</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>外部其他类访问内部类</p><ul><li><code>外部类名.内部类名 对象名 = 外部类名.new 内部类名();</code></li><li>方法返回</li><li><code>new 外部类名().new 内部类();</code></li></ul></li><li></li></ul><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul><li><p>定义在外部类的成员位置，<strong>有static修饰</strong></p></li><li><p>可以访问外部类所有静态成员，不能访问非静态成员</p></li><li><p>可以添加任意修饰符</p></li><li><p>作用域：整个类体</p></li><li><p>外部其他类访问内部类</p><ul><li>通过类名直接访问，但要满足访问权限</li><li>方法</li></ul></li><li><p>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.成员</code>访问</p></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li><p>使用<code>enum</code>代替<code>class</code>声明枚举类，就不能继承其他类了（因为隐式继承<code>Enum</code>类，<code>java</code>是单继承机制），但是可以继承接口</p></li><li><p>使用<code>enum</code>关键字开发一个枚举类时，默认会继承<code>Enum</code>类, 而且是一个final类</p></li><li><p>枚举简化为<code>枚举对象(参数列表)</code></p></li><li><p>使用无参构造器创建枚举对象，则实参和小括号都可以省略</p></li><li><p>当有多个枚举对象时，使用<code>,</code>分隔，最后一个<code>;</code>结尾</p></li><li><p>枚举对象必须放在枚举类首行</p></li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解用来修饰解释包、类、方法、属性、构造器、局部变量等。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</p><ul><li><p><strong>@Override</strong>：限定某个方法，是重写某个父类方法，该注解只能用于方法</p></li><li><p><strong>@Deprecated</strong>：用于表示某个程序元素（类、方法等）已过时，即不推荐使用，但是仍然能使用</p></li><li><p><strong>@SuppressWarnings</strong>：抑制编译器警告</p></li></ul><p><strong>元注解</strong>：注解的注解</p><ul><li>Retention：指定注解的作用范围，三种SOURCE, CLASS, RUNTIME</li><li>Target：指定注解可以在哪些地方使用</li><li>Documented：指定注解是否会在javadoc体现</li><li>Inherited：子类会继承父类注解</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p>执行过程中发生的异常分为两大类</p><ol><li>Error(错误)：Java虚拟机无法解决的严重问题，如<code>JVM</code>系统内部错误、资源耗尽等。比如<code>StackOverflowError</code>和<code>OOM（out of memory)</code></li><li>Exception：其他因编程或偶然的外在因素导致的一般问题，可以使用针对性的代码处理，分为两大类：运行时异常和编译时异常。编译异常程序中必须处理，运行时异常程序中没有处理默认是<code>throws</code></li></ol></li><li><p>异常处理方式: <code>ctrl</code>+<code>alt</code>+<code>t</code>选择</p><ol><li><p><code>try-catch-finally</code>：捕获异常，自行处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">代码</span><br><span class="line">&#125;catch(EXception e)&#123;</span><br><span class="line">//当异常发生时异常后面的代码不执行，直接进入catch，系统将异常封装成Exception对象e传递给catch，得到异常后程序员自己处理</span><br><span class="line">//异常没有发生，catch不执行</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">//不管代码是否有异常，finally都要执行</span><br><span class="line">//通常将释放资源的代码放在finally，保证关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以有多个<code>catch</code>语句，捕获不同的异常，要求父类异常在后，子类异常在前，比如<code>Exception</code>在后，<code>NullPointException</code>在前，如果发生异常，只会匹配一个<code>catch</code></p><p>可以进行<code>try-finally</code>配合使用，相当于没有捕获异常，因此程序会直接奔溃。应用场景：执行一段代码不管是否发生异常都必须执行某个业务逻辑</p></li><li><p><code>throws</code>：将异常抛出，交给调用者处理，最顶级的处理者是<code>JVM</code></p><p>编译异常程序中必须处理，运行时异常程序中没有处理默认是<code>throws</code></p><p>子类重写父类的方法时，对抛出异常的规定：子类重写的方法抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类型</p><p>在<code>throws</code>过程中，如果有<code>try-catch</code>，相当于处理异常，就可以不必<code>throws</code></p></li></ol></li><li><p>自定义异常：<code>异常类名 extends Exception/RuntimeException</code>如果继承<code>Exception</code>，属于编译异常；如果继承<code>RuntimeException</code>，属于运行异常，一般继承<code>RuntimeException</code></p><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table></li></ul><h3 id="包装类（Wrapper类）"><a href="#包装类（Wrapper类）" class="headerlink" title="包装类（Wrapper类）"></a>包装类（Wrapper类）</h3><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><ul><li><p>jdk5之后自动装箱和拆箱，自动装箱底层调用的是<code>valueOf()</code>方法，</p><p>如果是在基本数据类型对应范围内就直接返回，否则返回 <code>new 包装类(xx)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">装箱: int -&gt; Integer</span><br><span class="line"> int m;</span><br><span class="line"> Interger n = m;</span><br><span class="line">拆箱: Integer -&gt; int</span><br><span class="line"> Integer n = new Integer(2);</span><br><span class="line"> int m = n;</span><br></pre></td></tr></table></figure></li><li><p>包装类和String</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">包装类 -&gt; String</span><br><span class="line">Integer i = 100;</span><br><span class="line">String s1 = i + &quot;&quot;;//方法一</span><br><span class="line">String s2 = i.toString();//方法二</span><br><span class="line">String s3 = String.valueOf(i);//方法三</span><br><span class="line"></span><br><span class="line">String -&gt; 包装类</span><br><span class="line">String s = &quot;123&quot;;</span><br><span class="line">Integer i1 = Integer.parseInt(s); //方法一，用到自动装箱</span><br><span class="line">Integer i2 = new Integer(s);//方法二，用到构造器</span><br></pre></td></tr></table></figure></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><p>String类是一个<strong>final类</strong>，实现了接口Serializable（可串行化：可以在网络传输）和Comparable（对象可以比较大小）</p></li><li><p>有属性<code>private final char value[]</code>, value赋值后<strong>不可以修改，指不能指向新的地址，但单个字符内容可以改变</strong></p></li><li><p>字符串使用Unicode编码，一个字符占两个字节</p></li><li><p>常见构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String();</span><br><span class="line">String s2 = new String(String s);</span><br><span class="line">String s3 = new String(char[] a);</span><br><span class="line">String s4 = new String(char[] a, int startindex, int count);</span><br></pre></td></tr></table></figure></li><li><p><strong>创建对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">String s1 = &quot;str&quot;;</span><br><span class="line">先从常量池查看是否有&quot;str&quot;数据空间，如果有直接指向；如果没有则重新创建然后指向。s1最终指向的是常量池的空间地址</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">String s2 = new String(&quot;str&quot;);</span><br><span class="line">先从堆中创建空间，里面维护了value属性，指向常量池的str空间。如果常量池没有&quot;str&quot;重新创建，如果有直接通过value指向。s2最终指向的是堆中的空间地址</span><br></pre></td></tr></table></figure></li><li><pre><code>String s1 = &quot;ab&quot; + &quot;cd&quot;;//常量相加: 编译器会优化，常量池中只有&quot;abcd&quot;, s1指向常量池中的&quot;abcd&quot;String a = &quot;ab&quot;;String b = &quot;cd&quot;;String s2 = a+b;//变量相加: s2指向堆再通过堆中value指向常量池中的&quot;abcd&quot;, 常量池中有”ab&quot;, &quot;cd&quot;, &quot;abcd&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 常用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>equals//区分大小写判断内容是否相等equalsIgnoreCase//忽略大小写判断内容是否相等length//字符串长度indexOf//获取字符串第一次出现的索引lastInedxOf//获取字符串最后一次出现的索引substring//截取指定范围子串trim//去前后空格charAt//获取某索引处的字符，注意不能用Str[idx]方式toUpperCase//转换为大写toLowerCase//小写concat//拼接replace//替换, 原串不影响, 返回结果才是替换过的split//分割字符串toCharArray//转换为字符数组compareTo//比较字符串大小format//格式转换<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### StringBuffer</span><br><span class="line"></span><br><span class="line">可变的字符序列，可以对字符串内容进行增删。很多方法和String相同，但是StringBuffer是可变长度的。StringBuffer是一个容器。</span><br><span class="line"></span><br><span class="line">* 对比String：</span><br><span class="line">  * String保存的是字符串常量，里面的值不能修改，每次String类更新实际上是修改地址，效率低。`//private final char value[];`</span><br><span class="line">  * StringBuffer保存的是字符串变量，里面的值可以修改，每次更新实际上更新的是内容，不用每次更新地址，效率高。`//char[] value; //放在堆中`</span><br><span class="line"></span><br><span class="line">* 转换</span><br><span class="line"></span><br></pre></td></tr></table></figure>Stirng -&gt; StringBuffer// 1. 使用构造器String str = &quot;hello&quot;;StringBuffer sb1 = new StringBuffer(str);// 2. 使用append方法StringBuffer sb = new StringBuffer();sb = sb.append(str);StringBuffer -&gt; String// 1. 使用StringBuffer提供的toString方法// 2. 使用构造器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 常用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>append//增delete(st,ed)//删除[st,ed)字符replace(st,ed,str)//替换indexOf//查找第一次出现的索引insert(idx,str)//插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### StringBuilder</span><br><span class="line"></span><br><span class="line">一个可变的字符序列，此类提供一个与StringBuffer兼容的API，但并不能保证同步（存在线程安全问题），用作StringBuffer的一个简易替换，**用在字符串缓冲区被单个线程使用的时候**，如果可能建议优先使用，因为**比StringBuffer快**。</span><br><span class="line"></span><br><span class="line">三者比较</span><br><span class="line"></span><br><span class="line">* StringBuffer和StringBuilder非常类似，均代表可变字符序列，而且方法也一样</span><br><span class="line">* String：不可变字符序列，效率低，但复用率高</span><br><span class="line">* StringBuffer：可变字符序列，效率较高（增删），线程安全</span><br><span class="line">* StringBuilder：可变字符序列，效率最高，线程不安全</span><br><span class="line">* 如果需要对String做大量的修改，不要使用String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Arrays</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>toString&#x2F;&#x2F;返回数组的字符串形式，显示数组<br>sort&#x2F;&#x2F;自然排序和定制排序<br>传入一个接口Comparator实现定制排序，要求实现匿名内部类Comparator的compare方法<br>Arrays.sort(arr, new Comparator<Integer>() {<br>    @Override<br>    public int compare(Integer o1, Integer o2) {<br>        return 0;&#x2F;&#x2F;自己实现<br>    }<br>});<br>binarySearch&#x2F;&#x2F;二分查找<br>copyOf&#x2F;&#x2F;数组元素的复制<br>fill&#x2F;&#x2F;元素填充<br>equals&#x2F;&#x2F;数组比较<br>asList&#x2F;&#x2F;将一组值转换为list集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### BigInteger 和 BigDecimal</span><br><span class="line"></span><br><span class="line">* BigInteger 适合保存比较大的整数；BigDecimal 适合保存精度更高的浮点数</span><br><span class="line">* 对其进行加减乘除运算时需要使用相应的方法，不能直接使用`+ - * /`</span><br><span class="line">* BigDecimal 进行`divide`运算时可能除不尽而抛出异常，指定精度即可，`BigDecimal.ROUND_CEILING`, 结果保留分子精度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 日期类</span><br><span class="line"></span><br><span class="line">#### 第一代日期类Date </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 获取当前时间，在java.util包，默认输出格式是国外格式，可以通过格式转换<br>&#x2F;&#x2F; 1. 创建SimpleDateFormat对象可以指定相应格式<br>&#x2F;&#x2F; 2. 格式是字母规定好的<br>Date d &#x3D; new Date();&#x2F;&#x2F;获取当前时间<br>SimpleDateFormat sdf &#x3D; new SimpleDateFormat(“yyyy年mm月dd日 hh:mm:ss E”);<br>String format &#x3D; sdf.format(d);<br>System.out.println(format);&#x2F;&#x2F;2023年43月21日 07:43:11 周四</p><p>&#x2F;&#x2F; 把字符串转换为对应时间<br>String s &#x3D; “2023年43月21日 07:43:11 周四”;<br>Date parse &#x3D; sdf.parse(s);&#x2F;&#x2F;Sat Jan 21 07:43:11 CST 2023</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 第二代日期类Calendar</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Calendar 是一个抽象类，构造器是私有的，通过getInstance()获取实例，提供大量的方法和字段<br>月份从0开始<br>24小时制: Calendar.HOUR -&gt; Calendar.HOUR_OF_DAY</p><p>Calendar c &#x3D; Calendar.getInstance();<br>System.out.println(c.get(Calendar.YEAR));&#x2F;&#x2F;2023</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 第三代日期类</span><br><span class="line"></span><br><span class="line">建议使用第三代日期类</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LocalDate(日期)<br>LocalTime(时间)<br>LocalDateTime(时间日期)</p><p>LocalDateTime localDateTime &#x3D; LocalDateTime.now();<br>System.out.println(localDateTime);&#x2F;&#x2F;2023-09-21T20:39:47.018543</p><p>使用DateTimeFormatter类格式化日期<br>LocalDateTime localDateTime &#x3D; LocalDateTime.now();<br>DateTimeFormatter dd &#x3D; DateTimeFormatter.ofPattern(“yyyy年MM月dd日 hh小时mm分钟ss秒”);<br>String s &#x3D; dd.format(localDateTime);<br>System.out.println(s);&#x2F;&#x2F;2023年09月21日 08小时47分钟35秒</p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统与时序数据库</title>
      <link href="/2023/08/20/fen-bu-shi-xi-tong-yu-shi-xu-shu-ju-ku/"/>
      <url>/2023/08/20/fen-bu-shi-xi-tong-yu-shi-xu-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2023/08/10/wang-luo-bian-cheng/"/>
      <url>/2023/08/10/wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><h4 id="周知端口（Well-Known-Ports）"><a href="#周知端口（Well-Known-Ports）" class="headerlink" title="周知端口（Well Known Ports）"></a>周知端口（Well Known Ports）</h4><ul><li><p>周知端口是众所周知的端口号，也叫知名端口、公认端口或者常用端口，<strong>范围从 0 到 1023</strong>，它们紧密绑定于一些特定的服务，例如 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务，23 端口分配给Telnet服务等等</p></li><li><p>我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下WWW 服务的端口是 “80”</p></li><li><p>网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏上指定端口号，方法是<strong>在地址后面加上冒号“:”（半角），再加上端口号</strong>。比如使用 “8080” 作为 WWW服务的端口，则需要在地址栏里输入<code>网址:8080</code></p></li><li><p>有些系统协议使用固定的端口号，它是不能被改变的，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信，不能手动改变</p></li></ul><h4 id="注册端口（Registered-Ports）"><a href="#注册端口（Registered-Ports）" class="headerlink" title="注册端口（Registered Ports）"></a>注册端口（Registered Ports）</h4><ul><li><strong>端口号从 1024 到 49151</strong>，它们松散地绑定于一些服务，分配给用户进程或应用程序，这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口</li></ul><h4 id="动态端口-x2F-私有端口（Dynamic-Ports-x2F-Private-Ports）"><a href="#动态端口-x2F-私有端口（Dynamic-Ports-x2F-Private-Ports）" class="headerlink" title="动态端口 &#x2F; 私有端口（Dynamic Ports &#x2F; Private Ports）"></a>动态端口 &#x2F; 私有端口（Dynamic Ports &#x2F; Private Ports）</h4><ul><li>动态端口的范围是从 <strong>49152 到 65535</strong>，之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配</li></ul><h1 id="socket通信"><a href="#socket通信" class="headerlink" title="socket通信"></a>socket通信</h1><h2 id="socket介绍"><a href="#socket介绍" class="headerlink" title="socket介绍"></a>socket介绍</h2><ul><li><p><code>socket（套接字）</code>，就是对网络中<strong>不同主机</strong>上的应用进程之间进行<strong>双向通信</strong>的端点的抽象</p><blockquote><p>一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口</p></blockquote></li><li><p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念</p><blockquote><p>它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制</p></blockquote></li><li><p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。<strong>本质为内核借助缓冲区形成的伪文件</strong></p><blockquote><p>既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递</p></blockquote></li><li><p>套接字通信分两部分</p><ul><li>服务器端：被动接受连接，一般不会主动发起连接 </li><li>客户端：主动向服务器发起连接</li></ul></li><li><p>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别</p></li></ul><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><code>字节序</code>，顾名思义字节的顺序，就是<strong>大于一个字节类型的数据在内存中的存放顺序</strong></li><li>字节序分为<code>大端字节序（Big-Endian）</code> 和<code>小端字节序（Little-Endian）</code><ul><li><strong>大端字节序</strong>：指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处</li><li><strong>小端字节序</strong>：指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</li></ul></li></ul><h3 id="查看机器字节序"><a href="#查看机器字节序" class="headerlink" title="查看机器字节序"></a>查看机器字节序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">short</span> value;                <span class="comment">// 两字节</span></span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];  <span class="comment">// 两字节</span></span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span> (test.bytes[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; test.bytes[<span class="number">1</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端机器\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (test.bytes[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; test.bytes[<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端机器\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h3><ul><li><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：<strong>发送端总是把要发送的数据转换成大端字节序数据后再发送</strong>，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）</p></li><li><p><strong>网络字节顺序</strong>是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式</p></li><li><p>BSD Socket提供了封装好的转换接口，方便程序员使用</p><ul><li>从主机字节序到网络字节序的转换函数：<code>htons</code>、<code>htonl</code></li><li>从网络字节序到主机字节序的转换函数：<code>ntohs</code>、<code>ntohl</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h  - host 主机，主机字节序 </span><br><span class="line">to - 转换成什么 </span><br><span class="line">n  - network 网络字节序 </span><br><span class="line">s  - <span class="type">short</span> <span class="type">unsigned</span> <span class="type">short</span> </span><br><span class="line">l  - <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="comment">// 转换端口 </span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 =&gt; 网络字节序 </span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序 =&gt; 主机字节序</span></span><br><span class="line"><span class="comment">// 转IP </span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 =&gt; 网络字节序 </span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 网络字节序 =&gt; 主机字节序</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>socket地址其实是一个<code>结构体</code>，<strong>封装端口号和IP等信息</strong></li><li>后面的socket相关的api中需要使用到这个 socket地址</li></ul><h3 id="通用-socket-地址"><a href="#通用-socket-地址" class="headerlink" title="通用 socket 地址"></a><strong>通用</strong> <strong>socket</strong> 地址</h3><ul><li><p>socket 网络编程接口中表示 socket 地址的是结构体 <code>sockaddr</code>，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span> </span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; </span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>sa_family</code></p><ul><li><code>sa_family</code> 成员是地址族类型（<code>sa_family_t</code>）的变量</li><li><code>地址族类型</code>通常与<code>协议族类型</code>对应</li><li>宏 <code>PF_*</code> 和 <code>AF_*</code> 都定义在 <code>bits/socket.h</code> 头文件中，且后者与前者有完全相同的值，所以二者通常混用</li></ul><table><thead><tr><th align="center">协议族</th><th align="center">地址族</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">PF_UNIX</td><td align="center">AF_UNIX</td><td align="center">UNIX本地域协议族</td></tr><tr><td align="center">PF_INET</td><td align="center">AF_INET</td><td align="center">TCP&#x2F;IPv4协议族</td></tr><tr><td align="center">PF_INET6</td><td align="center">AF_INET6</td><td align="center">TCP&#x2F;IPv6协议族</td></tr></tbody></table></li><li><p><code>sa_data</code></p><ul><li><code>sa_data</code> 成员用于存放 socket 地址值，不同的协议族的地址值具有不同的含义和长度</li></ul><table><thead><tr><th align="center">协议族</th><th align="center">地址值含义和长度</th></tr></thead><tbody><tr><td align="center">PF_UNIX</td><td align="center">文件的路径名，长度可达到108字节</td></tr><tr><td align="center">PF_INET</td><td align="center">16 bit 端口号和 32 bit IPv4 地址，共 6 字节</td></tr><tr><td align="center">PF_INET6</td><td align="center">16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID，共 26 字节</td></tr></tbody></table><ul><li><p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span> </span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align; </span><br><span class="line">    <span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h2><ul><li><p><code>点分十进制</code>IP地址与<code>网络字节序整数</code>IP地址相互转换</p></li><li><p>旧版（已弃用）：只适用于IPV4间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>; </span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure></li><li><p>新版：同时适用于IPV4和IPV6</p><ul><li>字母含义<ul><li><code>p</code>：点分十进制的IP字符串</li><li><code>n</code>：表示network，网络字节序的整数</li></ul></li><li><code>int inet_pton(int af, const char *src, void *dst); </code><ul><li>使用<code>man inet_pton</code>查看帮助</li><li>功能：将点分十进制的IP地址字符串，转换成网络字节序的整数</li><li>参数<ul><li><code>af</code>：地址族<ul><li>IPV4：<code>AF_INET</code></li><li>IPV6：<code>AF_INET6(IPV6)</code></li></ul></li><li><code>src</code>：需要转换的点分十进制的IP字符串 </li><li><code>dst</code>：转换后的结果保存在这个里面</li></ul></li><li>返回值<ul><li>1：成功</li><li>0：源IP地址有误</li><li>-1：地址族包含不可用的地址协议</li></ul></li></ul></li><li><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code><ul><li>使用<code>man inet_ntop</code>查看帮助</li><li>功能：将网络字节序的整数，转换成点分十进制的IP地址字符串</li><li>参数<ul><li><code>af</code>：地址族<ul><li>IPV4：<code>AF_INET</code></li><li>IPV6：<code>AF_INET6(IPV6)</code></li></ul></li><li><code>src</code>：要转换的ip的整数的地址 </li><li><code>dst</code>：转换成IP地址字符串保存的地方 </li><li><code>size</code>：第三个参数的大小（数组的大小）</li></ul></li><li>返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</li></ul></li></ul></li></ul><h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="E:\hexocode\source\img\socket.png" alt="image-20211121104748003"></p><h3 id="服务器端（被动接收连接）"><a href="#服务器端（被动接收连接）" class="headerlink" title="服务器端（被动接收连接）"></a>服务器端（被动接收连接）</h3><ol><li>创建一个用于监听的套接字<ul><li>监听：监听有客户端的连接</li><li>套接字：这个套接字其实就是一个文件描述符</li></ul></li><li>将这个<code>监听文件描述符</code>和<strong>本地的IP和端口绑定</strong>（IP和端口就是服务器的地址信息）<ul><li>客户端连接服务器的时候使用的就是这个IP和端口</li></ul></li><li>设置监听，<code>监听的fd</code>开始工作 </li><li>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个<code>和客户端通信的套接字(fd)</code></li><li>通信<ul><li>接收数据</li><li>发送数据</li></ul></li><li>通信结束，断开连接</li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>创建一个用于通信的套接字(fd)</li><li>连接服务器，需要指定连接的服务器的 IP 和 端口 </li><li>连接成功了，客户端可以直接和服务器通信 <ul><li>接收数据</li><li>发送数据</li></ul></li><li>通信结束，断开连接</li></ol><h2 id="套接字函数"><a href="#套接字函数" class="headerlink" title="套接字函数"></a>套接字函数</h2><ul><li><p>包含在下列头文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略(因为已经包含上面两个)</span></span></span><br></pre></td></tr></table></figure></li><li><p>函数一览</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>int socket(int domain, int type, int protocol);</code></p><ul><li>功能：创建一个套接字</li><li>参数：<ul><li><code>domain</code>：协议族(常用如下)<ul><li><code>AF_INET</code> ：<code>ipv4</code></li><li><code>AF_INET</code>6 ：<code>ipv6</code></li><li><code>AF_UNIX</code>, <code>AF_LOCAL</code>：本地套接字通信（进程间通信）</li></ul></li><li><code>type</code>：通信过程中使用的协议类型 <ul><li><code>SOCK_STREAM</code> : 流式协议</li><li><code>SOCK_DGRAM</code> : 报式协议</li></ul></li><li><code>protocol</code>：具体的一个协议，一般写0，用于指定type参数的默认协议类型<ul><li><code>SOCK_STREAM</code> : 流式协议默认使用 TCP </li><li><code>SOCK_DGRAM</code> : 报式协议默认使用 UDP</li></ul></li></ul></li><li>返回值<ul><li>成功：返回文件描述符，操作的就是内核缓冲区</li><li>失败：-1</li></ul></li></ul></li><li><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); </code></p><ul><li>功能：绑定，将fd 和本地的IP和端口进行绑定 </li><li>参数：<ul><li><code>sockfd</code>：通过socket函数得到的文件描述符 </li><li><code>addr</code>：需要绑定的socket地址，这个地址封装了<strong>本地的ip和端口号的信息</strong></li><li><code>addrlen</code>：第二个参数结构体占的内存大小</li></ul></li><li>返回值：成功：0，失败：-1</li></ul></li><li><p><code>int listen(int sockfd, int backlog);</code></p><ul><li><p>功能：监听这个socket上的连接</p></li><li><p>参数：</p><ul><li><p><code>sockfd</code>：通过socket()函数得到的文件描述符</p></li><li><p><code>backlog</code>：未连接的和已经连接的和的最大值，可用<code>cat /proc/sys/net/core/somaxconn</code>查看Linux设置值，&#x3D;&#x3D;一般指定5就可以（视频说的，是否正确待验证）&#x3D;&#x3D;</p><p><img src="C:/Users/wlbin/Desktop/linuxServer-master/linuxServer-master/doc/04Linux网络编程/image-20211121111847282.png" alt="image-20211121111847282"></p></li></ul></li><li><p>返回值：成功：0，失败：-1</p></li></ul></li><li><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); </code></p><ul><li>功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</li><li>参数：<ul><li><code>sockfd</code> : 用于监听的文件描述符 </li><li><code>addr</code> : 传出参数，记录了连接成功后<strong>客户端的地址信息</strong>（ip，port） </li><li><code>addrlen</code> : 指定第二个参数的对应的内存大小</li></ul></li><li>返回值：<ul><li>成功：用于通信的文件描述符 </li><li>失败：-1</li></ul></li></ul></li><li><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p><ul><li>功能： 客户端连接服务器 </li><li>参数：<ul><li><code>sockfd</code> : 用于**通信的文件描述符 **</li><li><code>addr</code> : 客户端要连接的服务器的地址信息</li><li><code>addrlen</code> : 指定第二个参数的对应的内存大小</li></ul></li><li>返回值：成功 0， 失败 -1</li></ul></li><li><p>其他读写函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据 </span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>防止服务器重启时之前绑定的端口还未释放</li><li>程序突然退出而系统没有释放端口</li></ul><h4 id="方法——setsockopt"><a href="#方法——setsockopt" class="headerlink" title="方法——setsockopt"></a>方法——<code>setsockopt</code></h4><ul><li><code>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); </code><ul><li>功能：设置套接字的属性（不仅仅能设置端口复用），以下说明仅针对端口复用，其他详细内容可查看<code>slide/04Linux网络编程/02 socket通信/UNP（Unix网络编程）.pdf</code>第七章相关内容 </li><li>参数<ul><li><code>sockfd</code>：要操作的文件描述符 </li><li><code>level</code>：级别，<code>SOL_SOCKET</code> (端口复用的级别)</li><li><code>optname</code>：选项的名称，使用<code>SO_REUSEADDR</code>或<code>SO_REUSEPORT</code></li><li><code>optval</code>：端口复用的值（整形） ，1表示可复用，0表示不可复用</li><li><code>optlen</code>：optval参数的大小</li></ul></li></ul></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>端口复用的设置时机是<strong>在服务器绑定端口之前</strong></li><li>如果不设置端口复用，那么在程序异常终止后，再次启动服务会出现<code>Bind error:Address already in use</code></li></ul><h3 id="查看看网络相关信息命令——netstat"><a href="#查看看网络相关信息命令——netstat" class="headerlink" title="查看看网络相关信息命令——netstat"></a>查看看网络相关信息命令——netstat</h3><ul><li>格式：<code>netstat -参数名</code></li><li>常用参数<ul><li><code>a</code>：所有的socket</li><li><code>p</code>：显示正在使用socket的程序的名称</li><li><code>n</code>：直接使用IP地址，而不通过域名服务器</li></ul></li></ul><h1 id="IO多路复用-IO多路转接"><a href="#IO多路复用-IO多路转接" class="headerlink" title="IO多路复用(IO多路转接)"></a>IO多路复用(IO多路转接)</h1><h2 id="阻塞等待-BIO模型"><a href="#阻塞等待-BIO模型" class="headerlink" title="阻塞等待(BIO模型)"></a>阻塞等待(BIO模型)</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>遇到<code>read</code>&#x2F;<code>recv</code>&#x2F;<code>accept</code>时，阻塞等待，直接有数据或者连接时才继续往下执行</li></ul><h3 id="单任务"><a href="#单任务" class="headerlink" title="单任务"></a>单任务</h3><ul><li>好处：不占用CPU宝贵的时间片</li><li>缺点：同一时刻只能处理一个操作, 效率低</li><li>克服缺点：多线程或者多进程解决，一个线程&#x2F;进程对应一个任务</li></ul><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><ul><li>优点：能够同时处理多个任务，一个线程&#x2F;进程对应一个任务</li><li>缺点：<ul><li>线程或者进程会消耗资源</li><li>线程或进程调度消耗CPU资源</li></ul></li><li>根本问题：阻塞(<code>blocking</code>)</li></ul><h2 id="非阻塞，忙轮询-NIO模型"><a href="#非阻塞，忙轮询-NIO模型" class="headerlink" title="非阻塞，忙轮询(NIO模型)"></a>非阻塞，忙轮询(NIO模型)</h2><ul><li>优点：提高了程序的执行效率</li><li>缺点：需要占用更多的CPU和系统资源，每循环都需要 O(n) 系统调用（用来查找哪个任务可执行）</li><li>克服缺点：使用IO多路转接技术select&#x2F;poll&#x2F;epoll</li></ul><h2 id="IO多路转接技术-简介"><a href="#IO多路转接技术-简介" class="headerlink" title="IO多路转接技术(简介)"></a>IO多路转接技术(简介)</h2><h3 id="select-x2F-poll"><a href="#select-x2F-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h3><ul><li>委托内核进行操作</li><li>只会通知有几个任务可用，但不知道具体哪几个任务，还需遍历（与NIO模型略有不同）</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul><li>委托内核进行操作</li><li>会通知具体有哪几个任务可用</li></ul><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="主旨思想"><a href="#主旨思想" class="headerlink" title="主旨思想"></a>主旨思想</h3><ol><li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中</li><li>调用一个系统函数(<code>select</code>)，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I&#x2F;O操作时，该函数才返回<ul><li>这个函数是阻塞</li><li>函数对文件描述符的检测的操作是由内核完成的</li></ul></li><li>在返回时，它会告诉进程有多少（哪些）描述符要进行I&#x2F;O操作</li></ol><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><ul><li><p>概览</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; </span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; </span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); </code></p><ul><li><p>通过<code>man select</code>查看帮助</p></li><li><p>参数</p><ul><li><code>nfds</code>：委托内核检测的最大文件描述符的值 + 1（+1是因为遍历是下标从0开始，for循环＜设定）</li><li><code>readfds</code>：要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性 <ul><li>一般检测读操作 </li><li>对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</li><li>是一个传入传出参数</li></ul></li><li><code>writefds</code>：要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性 <ul><li>委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</li></ul></li><li><code>exceptfds</code>：检测发生异常的文件描述符的集合，一般不用</li><li><code>timeout</code>：设置的超时时间，含义见**<code>select</code>参数列表说明**<ul><li><code>NULL</code>：永久阻塞，直到检测到了文件描述符有变化 </li><li><code>tv_sec = tv_usec = 0</code>， 不阻塞</li><li><code> tv_sec &gt; 0,tv_usec &gt; 0</code>：阻塞对应的时间</li></ul></li></ul></li><li><p>返回值</p><ul><li>-1：失败</li><li>&gt;0(n)：检测的集合中有n个文件描述符发生了变化</li></ul></li></ul></li><li><p><code>select</code>参数列表说明</p><ul><li><p><code>fd_set</code>：是一块固定大小的缓冲区(结构体)，<code>sizeof(fd_set)=128</code>，即对应1024个比特位</p></li><li><p><code>timeval </code>：结构体类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123; </span><br><span class="line">    <span class="type">long</span> tv_sec; <span class="comment">/* seconds */</span> </span><br><span class="line">    <span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><h3 id="主旨思想-1"><a href="#主旨思想-1" class="headerlink" title="主旨思想"></a>主旨思想</h3><ul><li>用一个结构体记录文件描述符集合，并记录用户态状态和内核态状态</li></ul><h3 id="函数说明-1"><a href="#函数说明-1" class="headerlink" title="函数说明"></a>函数说明</h3><ul><li><p>概览</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span> </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123; </span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span> </span><br><span class="line">    <span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span> </span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout); </code></p><ul><li>通过<code>man poll</code>查看帮助</li><li>参数<ul><li><code>fds</code>：是一个<code>struct pollfd</code> 结构体数组，这是一个需要检测的文件描述符的集合</li><li><code>nfds</code>：这个是第一个参数数组中最后一个有效元素的下标 + 1 </li><li><code>timeout</code>：阻塞时长 <ul><li>0：不阻塞</li><li>-1：阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</li><li>&gt;0：具体的阻塞时长(ms)</li></ul></li></ul></li><li>返回值<ul><li>-1：失败</li><li>&gt;0(n)：检测的集合中有n个文件描述符发生了变化</li></ul></li></ul></li><li><p><code>events</code>及<code>revents</code>取值，如果有多个事件需要检测，用<code>|</code>即可，如同时检测读和写：<code>POLLIN | POLLOUT</code></p><p><img src="E:\hexocode\source\img\poll.png" alt="image-20211126233707281"></p></li></ul><h2 id="epoll-1"><a href="#epoll-1" class="headerlink" title="epoll"></a>epoll</h2><h3 id="主旨思想-2"><a href="#主旨思想-2" class="headerlink" title="主旨思想"></a>主旨思想</h3><ul><li>直接在<strong>内核态</strong>创建<code> eventpoll实例</code>(结构体)，通过<code>epoll</code>提供的API操作该实例</li><li>结构体中有<code>红黑树</code>和<code>双链表</code>，分别用来<strong>存储需要检测的文件描述符</strong>和<strong>存储已经发生改变的文件描述符</strong></li></ul><h3 id="函数说明-2"><a href="#函数说明-2" class="headerlink" title="函数说明"></a>函数说明</h3><ul><li><p>概览</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例</span></span><br><span class="line"><span class="comment">// 在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span> </span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span> </span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span> </span><br><span class="line">    <span class="type">void</span> *ptr; </span><br><span class="line">    <span class="type">int</span> fd; </span><br><span class="line">    <span class="type">uint32_t</span> u32; </span><br><span class="line">    <span class="type">uint64_t</span> u64; </span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>int epoll_create(int size);</code></p><ul><li>功能：创建一个新的epoll实例</li><li>参数：<code>size</code>，目前没有意义了(之前底层实现是哈希表，现在是红黑树)，随便写一个数，必须大于0</li><li>返回值<ul><li>-1：失败</li><li>&gt;0：操作<code>epoll实例</code>的文件描述符</li></ul></li></ul></li><li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></p><ul><li>功能：对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</li><li>参数：<ul><li><code>epfd</code>：epoll实例对应的文件描述符</li><li><code>op</code>：要进行什么操作<ul><li>添加：<code>EPOLL_CTL_ADD</code></li><li>删除：<code>EPOLL_CTL_DEL</code></li><li>修改：<code>EPOLL_CTL_MOD</code></li></ul></li><li><code>fd</code>：要检测的文件描述符 </li><li><code>event</code>：检测文件描述符什么事情，通过设置<code>epoll_event.events</code>，常见操作<ul><li>读事件：<code>EPOLLIN</code></li><li>写事件：<code>EPOLLOUT </code></li><li>错误事件：<code>EPOLLERR</code></li><li>设置边沿触发：<code>EPOLLET</code>（默认水平触发）</li></ul></li></ul></li><li>返回值：成功0，失败-1</li></ul></li><li><p><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></p><ul><li>功能：检测哪些文件描述符发生了改变</li><li>参数：<ul><li><code>epfd</code>：epoll实例对应的文件描述符</li><li><code>events</code>：传出参数，保存了发生了变化的文件描述符的信息</li><li><code>maxevents</code>：第二个参数结构体数组的大小 </li><li><code>timeout</code>：阻塞时长 <ul><li>0：不阻塞</li><li>-1：阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</li><li>&gt;0：具体的阻塞时长(ms)</li></ul></li></ul></li><li>返回值：<ul><li>&gt; 0：成功，返回发送变化的文件描述符的个数</li><li>-1：失败</li></ul></li></ul></li></ul><h3 id="工作模式-LT与ET"><a href="#工作模式-LT与ET" class="headerlink" title="工作模式(LT与ET)"></a>工作模式(LT与ET)</h3><h4 id="水平触发-level-triggered-LT"><a href="#水平触发-level-triggered-LT" class="headerlink" title="水平触发(level triggered, LT)"></a>水平触发(level triggered, LT)</h4><ul><li>epoll的缺省的工作方式，并且同时支持 block 和 non-block socket</li><li>在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的</li></ul><h4 id="边沿触发-edge-triggered-ET"><a href="#边沿触发-edge-triggered-ET" class="headerlink" title="边沿触发(edge triggered, ET)"></a>边沿触发(edge triggered, ET)</h4><ul><li>是高速工作方式，只支持 non-block socket，需要对监听文件描述符设置才能实现</li><li>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）</li></ul><h4 id="区别与说明"><a href="#区别与说明" class="headerlink" title="区别与说明"></a>区别与说明</h4><ul><li><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高</p></li><li><p>epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死</p></li><li><p>所以如果使用ET且缓冲区内容不能一次性读完，<strong>需要写一个循环将内容全部读取，且需要将套接字设置为非阻塞</strong></p></li><li><p>说明：假设委托内核检测读事件，即检测fd的读缓冲区，那么如果读缓冲区有数据 ，epoll检测到了会给用户通知</p><ul><li>LT<ul><li>用户不读数据，数据一直在缓冲区，epoll 会一直通知</li><li>用户只读了一部分数据，epoll会通知</li><li>缓冲区的数据读完了，不通知</li></ul></li><li>ET<ul><li>用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了</li><li>用户只读了一部分数据，epoll不通知</li><li>缓冲区的数据读完了，不通知</li></ul></li></ul></li></ul><h1 id="UDP与本地套接字"><a href="#UDP与本地套接字" class="headerlink" title="UDP与本地套接字"></a>UDP与本地套接字</h1><h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p><img src="E:\hexocode\source\img\udp.png" alt="image-20211127210835952"></p><h3 id="消息收发函数"><a href="#消息收发函数" class="headerlink" title="消息收发函数"></a>消息收发函数</h3><ul><li><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</code><ul><li>功能：udp发送消息函数</li><li>参数<ul><li><code>sockfd</code>：通信的套接字(文件描述符)</li><li><code>buf</code>：要发送的数据 </li><li><code>len</code>：发送数据的长度 </li><li><code>flags</code>：设置为0即可</li><li><code>dest_addr</code>：通信的另外一端的地址信息 </li><li><code>addrlen</code>：地址的内存大小，即<code>sizeof(dest_addr)</code></li></ul></li><li>返回值：失败-1，否则返回发送数据大小</li></ul></li><li><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); </code><ul><li>功能：udp接收消息函数</li><li>参数<ul><li><code>sockfd</code>：通信的套接字(文件描述符)</li><li><code>buf</code>：接收的数据 </li><li><code>len</code>：接收数据的长度 </li><li><code>flags</code>：设置为0即可</li><li><code>dest_addr</code>：通信的另外一端的地址信息，不需要设置为NULL即可</li><li><code>addrlen</code>：地址的内存大小，即<code>sizeof(dest_addr)</code></li></ul></li><li>返回值：失败-1，否则返回发送数据大小</li></ul></li></ul><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul><li>只能在局域网中使用</li><li>客户端需要绑定服务器广播使用的端口，才可以接收到广播消息</li></ul><blockquote><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1</p></blockquote><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>通过设置<code>setsockopt</code>函数，服务端进行设置（发送广播端）</li><li><code>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); </code><ul><li><code>sockfd</code>：通信套接字</li><li><code>level</code>：设置为<code>SOL_SOCKET</code></li><li><code>optname</code>：设置为<code>SO_BROADCAST</code></li><li><code>optval</code>：int类型的值，为1表示允许广播 </li><li><code>optlen</code>：optval的大小</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>此时客户端和服务端界限模糊，按理来说，需要<code>bind</code>端为服务端，而在广播时，需要<code>bind</code>的一端为接收消息端</p></li><li><p><code>发送广播端</code>需要通过<code>setsockopt</code>设置相关信息，广播地址需要根据本地IP进行配置，即<code>xxx.xxx.xxx.255</code></p></li><li><p><code>接收广播端</code>需要绑定广播地址或设置为接收任意地址消息</p></li><li><p>接收端在连入时，已经过去的消息将不被接收</p></li></ul><h2 id="组播-多播）"><a href="#组播-多播）" class="headerlink" title="组播(多播）"></a>组播(多播）</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul><li>组播既可以用于局域网，也可以用于广域网</li><li>客户端需要加入多播组，才能接收到多播的数据</li></ul><blockquote><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口</p><p>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案</p><p>多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用</p></blockquote><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li>通过设置<code>setsockopt</code>函数，服务器和客户端都需要进行设置</li><li><code>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); </code></li><li>服务端：设置多播的信息，外出接口<ul><li><code>sockfd</code>：通信套接字</li><li><code>level</code>：设置为<code>IPPROTO_IP</code></li><li><code>optname</code>：设置为<code>IP_MULTICAST_IF</code></li><li><code>optval</code>：<code>struct in_addr</code>类型</li><li><code>optlen</code>：optval的大小</li></ul></li><li>客户端：加入多播组<ul><li><code>sockfd</code>：通信套接字</li><li><code>level</code>：设置为<code>IPPROTO_IP</code></li><li><code>optname</code>：设置为<code>IP_ADD_MEMBERSHIP</code></li><li><code>optval</code>：<code>struct ip_mreq</code>类型</li><li><code>optlen</code>：optval的大小</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span> </span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> &#123;</span> </span><br><span class="line">    <span class="comment">/* IP multicast address of group. */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">// 组播的IP地址 </span></span><br><span class="line">    <span class="comment">/* Local IP address of interface. */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">// 本地的IP地址 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>服务端通过<code>setsockopt</code>设置<code>optval</code>时，需要指定多播地址，即<code>239.0.0.0~239.255.255.255</code>其中一个即可</li></ul><h2 id="本地套接字通信"><a href="#本地套接字通信" class="headerlink" title="本地套接字通信"></a>本地套接字通信</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><ul><li>本地套接字的作用：本地的进程间通信，包括<code>有关系的进程通信(父子进程)</code>和<code>没有关系的进程间通信</code></li><li>本地套接字实现流程和网络套接字类似，一般采用<code>TCP的通信流程</code></li></ul><h3 id="通信流程-1"><a href="#通信流程-1" class="headerlink" title="通信流程"></a>通信流程</h3><ul><li>服务端<ol><li>创建监听的套接字：<code>int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);</code></li><li>监听的套接字绑定本地的套接字文件：<code>bind(lfd, addr, len); </code>，绑定成功之后，指定的<code>sun_path</code>中的套接字文件会自动生成</li><li>监听：<code>listen(lfd, 100);</code></li><li>等待并接受连接请求：<code>int cfd = accept(lfd, &amp;cliaddr, len);</code></li><li>通信<ul><li>接收数据：<code>read/recv</code></li><li>发送数据：<code>write/send</code></li></ul></li><li>关闭连接：<code>close()</code></li></ol></li><li>客户端<ol><li>创建通信的套接字：<code>int cfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0); </code></li><li>监听的套接字绑定本地的IP端口：<code>bind(cfd, &amp;addr, len); </code>，绑定成功之后，指定的sun_path中的套接字文件会自动生成</li><li>连接服务器：<code>connect(fd, &amp;serveraddr, sizeof(serveraddr));</code></li><li>通信<ul><li>接收数据：<code>read/recv</code></li><li>发送数据：<code>write/send</code></li></ul></li><li>关闭连接：<code>close()</code></li></ol></li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>地址结构体为：<code>struct sockaddr_un</code>类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件: sys/un.h </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span> </span><br><span class="line">    <span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local </span></span><br><span class="line">    <span class="type">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>unlink</code>解除占用：本地套接字通信通过文件，如果不用unlink解除占用，则会出现”bind: Address already in use”</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="/2023/08/09/jin-cheng-he-xian-cheng/"/>
      <url>/2023/08/09/jin-cheng-he-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li><code>并行(parallel)</code>：指在同一时刻，有多条指令在多个处理器上同时执行</li><li><code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</li></ul><h4 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h4><p>Linux 内核的进程控制块是 <code>task_struct</code> 结构体: </p><ul><li><p><strong>进程id</strong>：系统中每个进程有唯一的 id，用 <code>pid_t</code> 类型表示，其实就是一个非负整数</p></li><li><p><strong>进程的状态</strong>：有<code>就绪</code>、<code>运行</code>、<code>挂起</code>、<code>停止</code>等状态</p></li><li><p>进程切换时需要<strong>保存和恢复的一些CPU寄存器</strong></p></li><li><p>描述<strong>虚拟地址空间</strong>的信息</p></li><li><p>描述<strong>控制终端</strong>的信息</p></li></ul><h4 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h4><h5 id="查看进程-静态"><a href="#查看进程-静态" class="headerlink" title="查看进程-静态"></a>查看进程-静态</h5><ul><li><p><code>ps</code>命令用来查看进程（静态），可以使用<code>man ps</code>查看使用说明</p><ul><li><p>常用参数含义</p><ul><li>a：显示终端上的所有进程，包括其他用户的进程</li><li>u：显示进程的详细信息</li><li>x：显示没有控制终端的进程</li><li>j：列出与作业控制相关的信息</li></ul></li><li><p><code>ps -aux</code>或<code>ps aux</code></p><ul><li><p><code>TTY</code>：进程所属终端，在终端直接执行<code>tty</code>可查看当前<code>Terminal</code>所属终端</p></li><li><p><code>STAT</code>：进程状态</p><ul><li>D ：不可中断 Uninterruptible（usually IO）</li><li>R：正在运行，或在队列中的进程</li><li>S(大写) ：处于休眠状态</li><li>T：停止或被追踪</li><li>Z：僵尸进程</li><li>W：进入内存交换（从内核2.6开始无效）</li><li>X：死掉的进程</li><li>&lt;：高优先级</li><li>N：低优先级</li><li>s：包含子进程</li><li>+：位于前台的进程组</li></ul></li><li><p><code>COMMAND</code>：进程执行命令</p></li></ul></li><li><p><code>ps -ajx</code>或<code>ps ajx</code></p><ul><li><code>PPID</code>：该进程的父进程ID</li><li><code>PGID</code>：该进程所属组ID</li><li><code>SID</code>：该进程所属会话(session)ID，多个组构成会话</li></ul></li></ul></li></ul><h5 id="查看进程-动态"><a href="#查看进程-动态" class="headerlink" title="查看进程-动态"></a>查看进程-动态</h5><ul><li><p><code>top</code></p></li><li><p>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔</p></li><li><p>在 top 命令执行后，可以按以下按键对显示的结果进行排序</p><ul><li>M：根据内存使用量排序</li><li>P：根据 CPU 占有率排序</li><li>T：根据进程运行时间长短排序</li><li>U：根据用户名来筛选进程</li><li>K：输入指定的 PID 杀死进程</li></ul></li></ul><h5 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h5><ul><li><p><code>kill [-signal] pid</code></p></li><li><p><code>kill -l</code>：列出所有信号</p></li><li><p><code>kill -9 进程ID</code> 等价于<code>kill –SIGKILL 进程ID</code></p></li><li><p><code>killall name</code>：根据进程名杀死进程</p></li></ul><h4 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a>进程号和相关函数</h4><ul><li>每个进程都由进程号来标识，其类型为 <code>pid_t（整型）</code>，进程号的范围：<code>0～32767</code>。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用</li><li><strong>任何进程（除 init 进程）都是由另一个进程创建</strong>，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）</li><li><strong>进程组是一个或多个进程的集合</strong>。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号</li><li>进程号和进程组相关函数<ul><li><code>pid_t getpid(void);</code>：获取进程ID</li><li><code>pid_t getppid(void);</code>：获取进程的父进程ID</li><li><code>pid_t getpgid(pid_t pid);</code>：获取进程的组ID</li></ul></li></ul><h4 id="进程创建：fork"><a href="#进程创建：fork" class="headerlink" title="进程创建：fork"></a>进程创建：fork</h4><ul><li><p>可通过<code>man 2 fork</code>查看帮助</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">    pid_t fork(void);</span><br><span class="line">        函数的作用：用于创建子进程。</span><br><span class="line">        返回值：</span><br><span class="line">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span><br><span class="line">            在父进程中返回创建的子进程的ID,</span><br><span class="line">            在子进程中返回0</span><br><span class="line">            如何区分父进程和子进程：通过fork的返回值。</span><br><span class="line">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>Linux 的 <code>fork()</code> 使用是通过<strong>写时拷贝 (copy- on-write) 实现</strong>。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让<strong>父子进程共享同一个地址空间</strong>，只有在<strong>需要写入的时候</strong>才会复制地址空间，从而使各个进程拥有各自的地址空间。即<strong>资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享</strong></p></li><li><p><strong>fork之后父子进程共享文件</strong>。fork产生的子进程与父进程<strong>有相同的文件描述符，指向相同的文件表</strong>，引用计数增加，共享文件偏移指针</p></li></ul><h4 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h4><ol><li><p>打断点及查看 <code>b 行号</code>，<code>i b</code></p></li><li><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，<strong>默认跟踪父进程</strong></p></li><li><p>查看当前跟踪的进程：<code>show follow-fork-mode</code></p></li><li><p>设置调试父进程或者子进程：<code>set follow-fork-mode [parent（默认）| child]</code></p></li><li><p>查看调试模式：<code>show detach-on-fork</code></p></li><li><p>设置调试模式：<code>set detach-on-fork [on | off]</code></p><ul><li>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起</li></ul></li><li><p>查看调试的进程：<code>info inferiors</code></p></li><li><p>切换当前调试的进程：<code>inferior Num</code></p></li><li><p>使进程脱离 GDB 调试：<code>detach inferiors Num</code></p></li></ol><h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><ul><li><p>可通过<code>man 3 exec</code>查看帮助，作用：<strong>在调用进程内部执行一个可执行文件</strong></p></li><li><p>基本组件为<code>exec</code>，后面跟不同参数，代表不同含义</p><ul><li><p><code>l(list) </code>：参数地址列表，以<strong>空指针结尾</strong></p></li><li><p><code>v(vector) </code>：存有各参数地址的指针数组的地址</p></li><li><p><code>p(path) </code>：按 PATH 环境变量指定的目录搜索可执行文件，可用<code>env</code>查看现有的环境变量</p></li><li><p><code>e(environment)</code>：存有环境变量字符串地址的指针数组的地址，增加新的环境变量</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">path：需要指定的执行的文件的路径或者名称</span><br><span class="line">arg：是执行可执行文件所需要的参数列表。第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称，从第二个参数开始往后，就是程序执行所需要的的参数列表，参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line">//会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功</span><br><span class="line">file：只需要提供名称（不需要提供路径）</span><br><span class="line"></span><br><span class="line">int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);</span><br><span class="line">envp：添加路径至环境变量，注意以`NULL`结尾，否则报`execle: Bad address`</span><br><span class="line">char* envp[] = &#123;&quot;/home/u/Desktop/Linux/&quot;, NULL&#125;;</span><br><span class="line">    execle(&quot;/home/u/Desktop/Linux/hello&quot;, &quot;hello&quot;, NULL, envp);</span><br><span class="line"></span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">argv：将运行参数都写在数组中</span><br><span class="line"></span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line"></span><br><span class="line">int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line"></span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><ul><li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为<code>孤儿进程（Orphan Process）</code></li><li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。</li><li>孤儿进程并不会有什么危害</li></ul><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><ul><li><p>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放</p></li><li><p>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成<code>僵尸（Zombie）进程</code></p></li><li><p><strong>僵尸进程不能被 <code>kill -9</code> 杀死</strong>，这样就会导致一个问题，如果父进程不调用 <code>wait()</code> 或 <code>waitpid()</code> 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免</p></li></ul><h4 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h4><ul><li><p><code>wait()</code> 和 <code>waitpid()</code> 函数的功能一样，区别在于，<code>wait()</code> 函数会阻塞；<code>waitpid()</code> 可以设置是否阻塞，<code>waitpid()</code> 还可以指定等待哪个子进程结束</p></li><li><p>一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应使用循环</p></li><li><pre><code>pid_t wait(int *wstatus);//等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源pid_t waitpid(pid_t pid, int *wstatus, int options);//回收指定进程号的子进程，可以设置是否阻塞<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 进程通信</span><br><span class="line"></span><br><span class="line">##### 管道</span><br><span class="line"></span><br><span class="line">- 管道其实是一个在**内核内存中维护的缓冲器**，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同</span><br><span class="line">- 管道拥有文件的特质：读操作、写操作</span><br><span class="line">  - **匿名管道**没有文件实体</span><br><span class="line">  - **有名管道**有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作</span><br><span class="line">- **一个管道是一个字节流**，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少</span><br><span class="line">- 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的</span><br><span class="line">- 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是**半双工**的</span><br><span class="line">- 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，**在管道中无法使用 lseek() 来随机的访问数据**</span><br><span class="line">- `匿名管道`只能在**具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用**</span><br><span class="line"></span><br><span class="line">###### 匿名管道</span><br><span class="line"></span><br><span class="line">`管道`也叫`无名（匿名）管道`，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制</span><br><span class="line"></span><br><span class="line">* 创建匿名管道</span><br><span class="line">  * `int pipe(int pipefd[2])`</span><br><span class="line">    - 功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">    - 参数：`int pipefd[2]` 这个数组是一个传出参数。</span><br><span class="line">      - `pipefd[0]` 对应的是管道的读端</span><br><span class="line">      - `pipefd[1]` 对应的是管道的写端</span><br><span class="line">    - 返回值：成功 0，失败 -1</span><br><span class="line">  * 注意</span><br><span class="line"></span><br><span class="line">    - 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line">    - 匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line"></span><br><span class="line">* 读管道</span><br><span class="line">  - 管道中有数据，read返回实际读到的字节数</span><br><span class="line">  - 管道中无数据</span><br><span class="line">    - 写端被全部关闭，read返回0（相当于读到文件的末尾）</span><br><span class="line">    - 写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">* 写管道</span><br><span class="line">  - 管道读端全部被关闭，进程异常终止（进程收到`SIGPIPE`信号）</span><br><span class="line">  - 管道读端没有全部关闭：</span><br><span class="line">    - 管道已满，write阻塞</span><br><span class="line">    - 管道没有满，write将数据写入，并返回实际写入的字节数</span><br><span class="line"></span><br><span class="line">###### 有名管道</span><br><span class="line"></span><br><span class="line">- 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了`有名管道（FIFO）`，也叫`命名管道`、`FIFO文件`</span><br><span class="line">- `有名管道（FIFO）`不同于匿名管道之处在于它**提供了一个路径名与之关联**，以 **FIFO 的文件形式存在于文件系统中**，并且其打开方式与打开一个普通文件是一样的，这样即使与 `FIFO` 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 `FIFO` 相互通信，因此，通过 `FIFO` 不相关的进程也能交换数据</span><br><span class="line">- 一旦打开了 `FIFO`，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如`read()`、`write()`和`close()`）。与管道一样，`FIFO` 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出</span><br><span class="line">- `有名管道（FIFO)`和`匿名管道（pipe）`有一些特点是相同的，不一样的地方在于</span><br><span class="line">  - `FIFO` 在文件系统中作为一个特殊文件存在，但 `FIFO` 中的**内容却存放在内存中**</span><br><span class="line">  - 当使用 `FIFO` 的进程退出后，`FIFO` 文件将继续保存在文件系统中以便以后使用</span><br><span class="line">  - `FIFO` 有名字，不相关的进程可以通过打开有名管道进行通信</span><br><span class="line"></span><br><span class="line">- 可使用`man fifo`查看帮助</span><br><span class="line"></span><br><span class="line">* 创建有名管道</span><br><span class="line">  * shell命令创建：`mkfifo 文件名`，可通过`man 1 mkfifo`查看帮助</span><br><span class="line">  * 函数创建：`int mkfifo(const char *pathname, mode_t mode);`，可通过`man 3 mkfifo`查看帮助</span><br><span class="line"></span><br><span class="line">##### 共享内存</span><br><span class="line"></span><br><span class="line">**共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）**。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 `IPC` 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用</span><br><span class="line"></span><br><span class="line">* 共享内存使用步骤</span><br><span class="line"></span><br><span class="line">  1. 调用 `shmget()` 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符</span><br><span class="line">  2. 使用 `shmat()`来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分</span><br><span class="line">  3. 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 `shmat()` 调用返回的 `addr` 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针</span><br><span class="line">  4. 调用 `shmdt()` 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步</span><br><span class="line">  5. 调用 `shmctl()` 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步</span><br><span class="line"></span><br><span class="line">* 共享内存操作函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>int shmget(key_t key, size_t size, int shmflg);void *shmat(int shmid, const void *shmaddr, int shmflg);int shmdt(const void *shmaddr);int shmctl(int shmid, int cmd, struct shmid_ds *buf);key_t ftok(const char *pathname, int proj_id);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 共享内存操作命令</span><br><span class="line"></span><br><span class="line">  * ### ipcs </span><br><span class="line"></span><br><span class="line">    - `ipcs -a`：打印当前系统中**所有的**进程间通信方式的信息</span><br><span class="line">    - `ipcs -m`：打印出**使用共享内存**进行进程间通信的信息</span><br><span class="line">    - `ipcs -q`：打印出**使用消息队列**进行进程间通信的信息</span><br><span class="line">    - `ipcs -s`：打印出**使用信号**进行进程间通信的信息</span><br><span class="line"></span><br><span class="line">  * ### ipcrm</span><br><span class="line"></span><br><span class="line">    - `ipcrm -M shmkey`：移除用`shmkey`创建的**共享内存段**</span><br><span class="line">    - `ipcrm -m shmid`：移除用`shmid`标识的**共享内存段**</span><br><span class="line">    - `ipcrm -Q msgkey`：移除用`msqkey`创建的**消息队列**</span><br><span class="line">    - `ipcrm -q msqid`：移除用`msqid`标识的**消息队列**</span><br><span class="line">    - `ipcrm -S semkey`：移除用`semkey`创建的**信号**</span><br><span class="line">    - `ipcrm -s semid`：移除用`semid`标识的**信号**</span><br><span class="line"></span><br><span class="line">##### 信号</span><br><span class="line"></span><br><span class="line">- 可通过`man 7 signal`查看帮助</span><br><span class="line"></span><br><span class="line">- 信号的 5 中默认处理动作</span><br><span class="line"></span><br><span class="line">  - `Term`：终止进程</span><br><span class="line">  - `Ign`：当前进程忽略掉这个信号</span><br><span class="line">  - `Core`：终止进程，并生成一个Core文件</span><br><span class="line">  - `Stop`：暂停当前进程</span><br><span class="line">  - `Cont`：继续执行当前被暂停的进程</span><br><span class="line"></span><br><span class="line">- 信号的几种状态：`产生`、`未决`、`递达`</span><br><span class="line"></span><br><span class="line">- `SIGKILL` 和 `SIGSTOP` 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</span><br><span class="line"></span><br><span class="line">- 常用信号</span><br><span class="line"></span><br><span class="line">  | 编号 | 信号名称 | 对应事件                                       | 默认动作               |</span><br><span class="line">  | ---- | -------- | ---------------------------------------------- | ---------------------- |</span><br><span class="line">  | 2    | SIGINT   | 按下&lt;Ctrl +c&gt;组合键时用户终端向程序发出此信号  | 终止进程               |</span><br><span class="line">  | 3    | SIGQUIT  | 按下&lt;Ctrl +\\&gt;组合键时用户终端向程序发出此信号 | 终止进程               |</span><br><span class="line">  | 9    | SIGKILL  | 无条件终止进程。该信号不能被忽略、处理和阻塞   | 终止进程               |</span><br><span class="line">  | 11   | SIGSEGV  | 指示进程进行了无效内存访问（段错误）           | 终止进程并产生core文件 |</span><br><span class="line">  | 13   | SIGPIPE  | Broke pipe向一个没有读端的管道写数据           | 终止进程               |</span><br><span class="line">  | 17   | SIGCHLD  | 子进程结束时，父进程会收到这个信号             | 忽略这个信号           |</span><br><span class="line">  | 18   | SIGCONT  | 如果进程已停止，则使其继续运行                 | 继续/忽略              |</span><br><span class="line">  | 19   | SIGSTOP  | 停止进程的执行。不能被忽略、处理和阻塞         | 终止进程               |</span><br><span class="line"></span><br><span class="line">* 当进程异常终止时，会生成`core`文件（需要进行相应设置），可以通过`gdb`调试查看错误</span><br><span class="line"></span><br><span class="line">  * 生成调试`core`文件需要做以下几步</span><br><span class="line">    1. 使用`ulimit -a`查看资源上限</span><br><span class="line">    2. 修改`core size`：`ulimit -c core-size`</span><br><span class="line">    3. 在编译运行程序时加上`-g`选项使得能够被`gdb`调试，运行后生成`core`文件</span><br><span class="line">    4. 调试`core`程序：`gdb 可执行文件`进入`gdb`终端，使用`core-file core`可以查看`core`定位错误</span><br><span class="line"></span><br><span class="line">* 信号相关函数</span><br><span class="line"></span><br><span class="line">  * `int kill(pid_t pid, int sig);` 给**任何的进程或者进程组**`pid`，发送**任何的信号** `sig`</span><br><span class="line"></span><br><span class="line">  * `int raise(int sig);` 给**当前进程**发送信号</span><br><span class="line"></span><br><span class="line">  * `void abort(void);` 发送`SIGABRT`信号给当前的进程，**杀死当前进程**</span><br><span class="line"></span><br><span class="line">  * `unsigned int alarm(unsigned int seconds);` 设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：`SIGALARM`：默认终止**当前的进程**，每一个进程都有且只有唯一的一个定时器</span><br><span class="line"></span><br><span class="line">  * `int setitimer(int which, const struct itimerval *new_val, struct itimerval *old_value);`  设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line"></span><br><span class="line">  * `sighandler_t signal(int signum, sighandler_t handler);` 设置某个信号的捕捉行为</span><br><span class="line"></span><br><span class="line">  * `int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);` 检查或者改变信号的处理，即信号捕捉</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">* 信号集</span><br><span class="line"></span><br><span class="line">  * 使用`man 3 sigset`查看帮助</span><br><span class="line">  * 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 `sigset_t`</span><br><span class="line">  * 在 PCB 中有两个非常重要的信号集。一个称之为 `阻塞信号集` ，另一个称之为`未决信号集`。这两个信号集都是**内核使用位图机制来实现**的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改</span><br><span class="line">  * 信号的 `未决` 是一种状态，指的是**从信号的产生到信号被处理前的这一段时间**</span><br><span class="line">  * 信号的 `阻塞` 是一个开关动作，指的是**阻止信号被处理，但不是阻止信号产生**。信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作</span><br><span class="line">  * 操作自定义信号集函数</span><br><span class="line">    * 使用`man 3 sigemptyset`查看帮助</span><br><span class="line">    * `int sigemptyset(sigset_t *set);`功能：清空信号集中的数据，将信号集中的所有的标志位置为0</span><br><span class="line">    * `int sigfillset(sigset_t *set);`将信号集中的所有的标志位置为1</span><br><span class="line">    * `int sigaddset(sigset_t *set, int signum);`设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="line">    * `int sigdelset(sigset_t *set, int signum);`设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="line">    * `int sigismember(const sigset_t *set, int signum);`判断某个信号是否阻塞</span><br><span class="line"></span><br><span class="line">  * 操作内核信号集函数</span><br><span class="line">    * `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">    * `int sigpending(sigset_t *set);`获取内核中的未决信号集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 线程</span><br><span class="line"></span><br><span class="line">- 与`进程（process）`类似，`线程（thread）`是允许应用程序**并发执行多个任务**的一种机制</span><br><span class="line">- 一个进程可以包含多个线程</span><br><span class="line"></span><br><span class="line">* **进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位**</span><br><span class="line"></span><br><span class="line">#### 进程和线程区别</span><br><span class="line"></span><br><span class="line">- **进程间的信息难以共享**。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换</span><br><span class="line">- 调用 `fork()` 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 `fork()` 调用在时间上的开销依然不菲</span><br><span class="line">- 线程之间能够方便、快速地共享信息。只需**将数据复制到共享（全局或堆）变量**中即可</span><br><span class="line">- 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</span><br><span class="line"></span><br><span class="line">#### 线程之间共享和非共享资源</span><br><span class="line"></span><br><span class="line">##### 共享资源</span><br><span class="line"></span><br><span class="line">- 进程 ID 和父进程 ID</span><br><span class="line">- 进程组 ID 和会话 ID</span><br><span class="line">- 用户 ID 和 用户组 ID</span><br><span class="line">- 文件描述符表</span><br><span class="line">- 信号处置</span><br><span class="line">- 文件系统的相关信息：文件权限掩码（`umask`）、当前工作目录</span><br><span class="line">- 虚拟地址空间（**除栈、.text**）</span><br><span class="line"></span><br><span class="line">##### 非共享资源</span><br><span class="line"></span><br><span class="line">- 线程 ID</span><br><span class="line">- 信号掩码</span><br><span class="line">- 线程特有数据</span><br><span class="line">- error 变量</span><br><span class="line">- 实时调度策略和优先级</span><br><span class="line">- 栈，本地变量和函数的调用链接信息</span><br><span class="line"></span><br><span class="line">#### 线程操作函数</span><br><span class="line"></span><br><span class="line">由于`pthread`属于第三方库，所以在编译时需要加上参数`-pthread`或`-lpthread`即指定包路径，如果不加报以下错误</span><br><span class="line"></span><br><span class="line">- 获取当前的线程的线程ID：`pthread_t pthread_self(void);`</span><br><span class="line"></span><br><span class="line">- 比较两个线程ID是否相等：`int pthread_equal(pthread_t t1, pthread_t t2);`</span><br><span class="line"></span><br><span class="line">  &gt; 不同的操作系统，`pthread_t`类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的</span><br><span class="line"></span><br><span class="line">- 线程创建：``int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);``</span><br><span class="line"></span><br></pre></td></tr></table></figure>- `thread`：传出参数，线程创建成功后，子线程的线程ID被写到该变量中- `attr` : 设置线程的属性，一般使用默认值，NULL- `start_routine` : 函数指针，这个函数是子线程需要处理的逻辑代码- `arg` : 给第三个参数(`start_routine`)使用，传参</code></pre></li></ul><ul><li><p>线程终止：<code>void pthread_exit(void *retval);</code></p></li><li><p>线程连接：<code>int pthread_join(pthread_t thread, void **retval);</code>，和一个已经终止的线程进行连接。回收子线程的资源，这个函数是阻塞函数，调用一次只能回收一个子线程，一般在主线程中使用</p></li><li><p>线程分离：<code>int pthread_detach(pthread_t thread);</code>，分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统</p></li><li><p>线程取消：<code>int pthread_cancel(pthread_t thread);</code></p></li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul><li><code>临界区</code>是指访问某一共享资源的代码片段，并且这段代码的执行应为<code>原子操作</code>，也就是同时访问同一共享资源的其他线程不应终端该片段的执行</li><li><code>线程同步</code>：即<strong>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态</strong></li></ul><h5 id="互斥量-互斥锁"><a href="#互斥量-互斥锁" class="headerlink" title="互斥量(互斥锁)"></a>互斥量(互斥锁)</h5><p><strong>互斥量能保证对任意共享资源的原子访问</strong>。任何时候，<strong>至多只有一个线程可以锁定该互斥量</strong>。</p><h6 id="相关操作函数"><a href="#相关操作函数" class="headerlink" title="相关操作函数"></a>相关操作函数</h6><ul><li><p>互斥量的类型：<code>pthread_mutex_t</code></p></li><li><p>初始化互斥量：<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></p><ul><li>参数<ul><li><code>mutex</code> ： 需要初始化的互斥量变量</li><li><code>attr</code> ： 互斥量相关的属性，设置为NULL，由内核指定</li></ul></li><li><code>restrict</code> : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作</li></ul></li><li><p>释放互斥量的资源：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p></li><li><p>加锁：<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p></li><li><p>尝试加锁：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p></li><li><p>解锁：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p></li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><ul><li>产生死锁的几种场景：<ul><li>忘记释放锁</li><li>重复加锁</li><li>多线程多锁，抢占锁资源</li></ul></li></ul><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul><li><p>读写锁的特点</p><ul><li><p>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</p></li><li><p>如果有其它线程写数据，则其它线程都不允许读、写操作</p></li><li><p>写是独占的，写的优先级高</p></li></ul></li><li><p>相关操作函数</p><ul><li><p>读写锁的类型：<code>pthread_rwlock_t</code></p></li><li><p>初始化读写锁：<code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></p></li><li><p>释放互斥量的资源：<code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p></li><li><p>读操作加锁：<code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p></li><li><p>读操作尝试加锁：<code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></p></li><li><p>写操作加锁：<code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p></li><li><p>写操作尝试加锁：<code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p></li><li><p>解锁：<code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p></li></ul></li></ul><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><ul><li>相关操作函数<ul><li>条件变量的类型：<code>pthread_cond_t</code></li><li>初始化：<code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></li><li>回收：<code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li><li>等待，调用了该函数，线程会阻塞：<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></li><li>等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束：<code>int pthread_cond_timedwait(pthread_cond_t *restrict cond,  pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></li><li>唤醒一个或者多个等待的线程：<code>int pthread_cond_signal(pthread_cond_t *cond);</code></li><li>唤醒所有的等待的线程：<code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li></ul></li></ul><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><ul><li>相关操作函数<ul><li>信号量的类型：<code>sem_t</code></li><li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code><ul><li>功能：初始化信号量</li><li>参数<ul><li><code>sem</code>：信号量变量的地址</li><li><code>pshared</code>：0 用在线程间 ，非0 用在进程间</li><li><code>value </code>：信号量中的值，代表容器大小</li></ul></li></ul></li><li><code>int sem_destroy(sem_t *sem);</code><ul><li>功能：释放资源</li></ul></li><li><code>int sem_wait(sem_t *sem);</code><ul><li>功能：对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</li></ul></li><li><code>int sem_trywait(sem_t *sem);</code></li><li><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></li><li><code>int sem_post(sem_t *sem);</code><ul><li>功能：对信号量解锁，调用一次对信号量的值+1</li></ul></li><li><code>int sem_getvalue(sem_t *sem, int *sval);</code></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程入门</title>
      <link href="/2023/08/05/linux-xi-tong-bian-cheng-ru-men/"/>
      <url>/2023/08/05/linux-xi-tong-bian-cheng-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><ul><li><p>GCC工作流程：预处理(.i)-&gt;编译(.s)-&gt;汇编(.o)-&gt;链接(.exe&#x2F;.out)</p></li><li><p>GCC常用参数选项</p><table><thead><tr><th>编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>预处理指定源文件，不进行编译</td></tr><tr><td>-S</td><td>编译指定的源文件，但不进行汇编</td></tr><tr><td>-c</td><td>编译、汇编指定源文件，但不进行链接</td></tr><tr><td>[file2] -o [file1] <br >-o [file1] [file2]</td><td>将文件file2编译成可执行文件file1</td></tr><tr><td>-I dir</td><td>指定include包含文件的搜索目录</td></tr><tr><td>-g</td><td>在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td>-D</td><td>在程序编译的时候，指定一个宏</td></tr><tr><td>-w</td><td>不生成任何警告信息</td></tr><tr><td>-wall</td><td>生成所有警告信息</td></tr><tr><td>-On</td><td>n取值0-3，编译器的优化选项的4个级别，-o0表示没有优化，-o1为缺省值，-o3优化级别最高</td></tr><tr><td>-l</td><td>在程序编译的时候，指定使用的库</td></tr><tr><td>-L</td><td>指定编译的时候，搜索的库的路径</td></tr><tr><td>-fPIC&#x2F;fpic</td><td>生成与位置无关的代码</td></tr><tr><td>-shared</td><td>生成共享目标文件，通常用在建立共享库</td></tr><tr><td>-std</td><td>指定c方言，如-std&#x3D;c99</td></tr></tbody></table></li></ul><h3 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h3><p>静态库在程序的链接阶段被复制到程序中；动态库在程序运行时由系统动态加载到内存中供程序调用</p><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><ul><li><p><strong>静态库的制作</strong>：</p><ol><li>生成.o文件：<code>gcc -c xxx.c</code></li><li>将.o文件打包：<code>ar rcs libxxx.a xx1.o xx2.o</code></li></ol></li><li><p><strong>静态库的使用</strong>：需要提供静态库文件和相应的头文件。编译运行时指定头文件路径、静态库名称、静态库路径。<code>gcc main.c -o main -I 头文件路径 -l 静态库名称 -L 静态库路径</code></p></li><li><p><strong>优缺点</strong>：</p><ul><li>加载速度快，发布程序无需提供静态库，移植方便</li><li>消耗资源浪费内存，更新部署发布麻烦</li></ul></li></ul><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><ul><li><p><strong>动态库制作</strong>：</p><ol><li>生成.o文件：<code>gcc -c -fpic xxx.c</code></li><li>将.o文件打包：<code>gcc -shared xx1.o xx2.o -o libxxx.so</code></li></ol></li><li><p><strong>动态库的使用</strong>：</p><ul><li><p>需要提供动态库文件和相应的头文件</p></li><li><p>定位动态库</p><ul><li><p>方法一：修改环境变量，当前终端生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/...</span><br></pre></td></tr></table></figure></li><li><p>方法二：修改环境变量，用户级别永久配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改~/.bashrc</span><br><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"># 在~/.bashrc中添加下行，保存退出</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/...</span><br><span class="line"></span><br><span class="line"># 使修改生效</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>方法三：修改环境变量，系统级别永久配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改/etc/profile</span><br><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line"># 在~/.bashrc中添加下行，保存退出</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/u/Desktop/Linux/calc/lib</span><br><span class="line"></span><br><span class="line"># 使修改生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>方法四：修改<code>/etc/ld.so.cache文件列表</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改/etc/ld.so.conf</span><br><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line"># 在/etc/ld.so.conf中添加下行，保存退出</span><br><span class="line">/home/u/Desktop/Linux/calc/lib</span><br><span class="line"></span><br><span class="line"># 更新配置</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编译运行</p></li><li><p>程序启动之后，动态库会被动态加载到内存中，通过 <code>ldd 可执行文件（list dynamic dependencies）</code>命令检查动态库依赖关系</p></li></ul></li><li><p><strong>优缺点</strong>：</p><ul><li>可以实现进程间资源共享，更新部署发布简单，可以控制何时加载动态库</li><li>加载速度慢，发布时需要提供动态库</li></ul></li></ul><h3 id="makefile-x2F-Makefile"><a href="#makefile-x2F-Makefile" class="headerlink" title="makefile&#x2F;Makefile"></a>makefile&#x2F;Makefile</h3><ul><li><p>规则: 可以有一个或者多个规则，其它规则一般都是为第一条规则服务的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标...: 依赖 ...</span><br><span class="line">命令 (shell命令)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>变量</p><ul><li><p>自定义变量：<code>变量名=变量值</code>，如<code>var=hello</code>，获取变量值：<code>$(var)</code></p></li><li><p>预定义变量</p><table><thead><tr><th>变量</th><th>意义</th></tr></thead><tbody><tr><td>AR</td><td>归档维护程序的名称，默认值ar</td></tr><tr><td>CC</td><td>C编译器名称，默认值cc</td></tr><tr><td>CXX</td><td>C++编译器名称，默认值g++</td></tr><tr><td>$@</td><td>目标的完整名称</td></tr><tr><td>$&lt;</td><td>第一个依赖文件的名称</td></tr><tr><td>$^</td><td>所有依赖文件</td></tr></tbody></table></li></ul></li><li><p>函数</p><ul><li><p><code>$(wildcard ...)</code>: 获取指定目录下指定类型文件列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(wildcard *.c ./src/*.c)</span><br></pre></td></tr></table></figure></li><li><p><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code>: 替换文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回x.o bar.o</span><br><span class="line">$(patsubst %.c, %.o, x.c bar.c)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>清除中间文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm *.o</span><br></pre></td></tr></table></figure></li></ul><h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><ul><li><p>使用以下命令编译：<code>gcc -g -Wall program.c -o program</code></p><ul><li>通常，在为调试而编译时，我们会<strong>关掉编译器的优化选项</strong>（<code>-O</code>）， 并打开<strong>调试选项</strong>（<code>-g</code>）。另外，<code>-Wall</code>在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的 BUG</li><li><code>-g</code> 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 <code>gdb</code> 能找到源文件</li></ul></li><li><p>注：当在 <code>gdb</code> 中直接使用<code>回车</code>时，会默认执行上一条命令</p></li></ul><ul><li><p>常用命令</p><table><thead><tr><th>意义</th><th>命令</th></tr></thead><tbody><tr><td>启动<br>退出</td><td>gdb 可执行文件<br>quit</td></tr><tr><td>设置参数<br>获取设置参数</td><td>set args 10 20<br>show args</td></tr><tr><td>使用帮助</td><td>help</td></tr><tr><td>从默认位置显示<br>从指定行显示<br>从指定函数显示<br>从指定文件指定行显示<br>从指定文件指定函数显示</td><td>list&#x2F;l<br>list&#x2F;l 行号<br>list&#x2F;l 函数名<br>list&#x2F;l 文件名:行号 <br>list&#x2F;l 文件名:函数名</td></tr><tr><td>查看显示的行数<br>设置显示的行数</td><td>show list&#x2F;listsize <br>set list&#x2F;listsize</td></tr><tr><td>查看断点<br>设置断点<br>设置条件断点(一般用在循环)<br>删除断点<br>设置断点无效<br>设置断点生效</td><td>i&#x2F;info b&#x2F;break <br>b&#x2F;break 行号&#x2F;函数名&#x2F;文件名:行号&#x2F;文件名:函数 <br>b&#x2F;break 10 if i&#x3D;&#x3D;5<br>d&#x2F;del&#x2F;delete 断点编号<br>dis&#x2F;disable 断点编号<br>ena&#x2F;enable 断点编号</td></tr><tr><td>运行程序时停在第一行<br>运行程序遇到断点才停</td><td>start<br>run</td></tr><tr><td>继续运行，到下一个断点停</td><td>c&#x2F;continue</td></tr><tr><td>向下执行一行代码(不会进入函数)</td><td>n&#x2F;next</td></tr><tr><td>打印变量值<br>打印变量类型</td><td>p&#x2F;print 变量名<br>ptype 变量名</td></tr><tr><td>向下单步调试（进入函数）<br>跳出函数体</td><td>s&#x2F;step<br>finish</td></tr><tr><td>自动打印指定变量的值<br>查看自动变量<br>取消自动变量</td><td>display 变量名<br>i&#x2F;info display<br>undisplay 编号</td></tr><tr><td>设置变量值</td><td>set var 变量名&#x3D;变量值</td></tr><tr><td>跳出循环</td><td>until</td></tr></tbody></table></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/2023/08/04/sql/"/>
      <url>/2023/08/04/sql/</url>
      
        <content type="html"><![CDATA[<h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><ul><li><p><strong>截断和偏移</strong>：使用<code>LIMIT</code>关键字实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 后只跟一个整数，表示要截断的数据条数（一次获取几条）</span><br><span class="line">LIMIT 后跟2个整数，依次表示从第几条数据开始、依次获取几条</span><br></pre></td></tr></table></figure></li><li><p><strong>条件分支</strong>：使用<code>case when</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case when 指定多个分支</span><br><span class="line">CASE WHEN (条件1) THEN 结果1</span><br><span class="line"> WHEN (条件2) THEN 结果2</span><br><span class="line"> ...</span><br><span class="line"> ELSE 其他结果 END</span><br></pre></td></tr></table></figure></li></ul><h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><ul><li><p><strong>having子句</strong>：用于在分组聚合后对分组进行过滤。它允许我们对分组后的结果进行条件筛选，只保留满足特定条件的分组。</p><p>HAVING 子句与条件查询 WHERE 子句的区别在于，WHERE 子句用于在 <strong>分组之前</strong> 进行过滤，而 HAVING 子句用于在 <strong>分组之后</strong> 进行过滤。</p></li></ul><h4 id="查询进阶"><a href="#查询进阶" class="headerlink" title="查询进阶"></a>查询进阶</h4><ul><li><p>关联查询：</p><ul><li><p><code>cross join</code>, 返回两个表的笛卡尔积</p></li><li><p><code>inner join/join</code>, 返回两个表中满足关联条件的交集部分</p></li><li><p><code>outer join</code>, 将两个表中满足条件的行组合在一起，并 <strong>包含没有匹配的行</strong> 。</p><p>包括 LEFT OUTER JOIN 和 RIGHT OUTER JOIN 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。</p></li></ul></li><li><p>组合查询：</p><ol><li>UNION 操作：它用于将两个或多个查询的结果集合并， <strong>并去除重复的行</strong> 。即如果两个查询的结果有相同的行，则只保留一行。</li><li>UNION ALL 操作：它也用于将两个或多个查询的结果集合并， <strong>但不去除重复的行</strong> 。即如果两个查询的结果有相同的行，则全部保留。</li></ol></li><li><p>开窗函数：允许我们在查询中进行对分组数据进行计算、 <strong>同时保留原始行的详细信息</strong> 。</p><ul><li><p><code>sum over</code>: 分组统计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(计算字段名) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 分组字段名)</span><br></pre></td></tr></table></figure></li><li><p><code>sum over order by</code>: 同组内数据的累加求和</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(计算字段名) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 分组字段名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段 排序规则)</span><br></pre></td></tr></table></figure></li><li><p><code>rank</code>: 对查询结果集中的行进行 <strong>排名</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RANK() OVER (</span><br><span class="line">  PARTITION BY 列名1, 列名2, ... -- 可选，用于指定分组列</span><br><span class="line">  ORDER BY 列名3 [ASC|DESC], 列名4 [ASC|DESC], ... -- 用于指定排序列及排序方式</span><br><span class="line">) AS rank_column</span><br></pre></td></tr></table></figure></li><li><p><code>row_number</code>: 为查询结果集中的每一行 <strong>分配唯一连续排名</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROW_NUMBER() OVER (</span><br><span class="line">  PARTITION BY column1, column2, ... -- 可选，用于指定分组列</span><br><span class="line">  ORDER BY column3 [ASC|DESC], column4 [ASC|DESC], ... -- 用于指定排序列及排序方式</span><br><span class="line">) AS row_number_column</span><br></pre></td></tr></table></figure></li><li><p><code>lag</code>: 获取 <strong>当前行之前</strong> 的某一列的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LAG</span>(column_name, <span class="keyword">offset</span>, default_value) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_column <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_column)</span><br><span class="line">column_name：要获取值的列名。</span><br><span class="line"><span class="keyword">offset</span>：表示要向上偏移的行数。例如，<span class="keyword">offset</span>为<span class="number">1</span>表示获取上一行的值，<span class="keyword">offset</span>为<span class="number">2</span>表示获取上两行的值，以此类推。</span><br><span class="line">default_value：可选参数，用于指定当没有前一行时的默认值。</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span>和<span class="keyword">ORDER</span> <span class="keyword">BY</span>子句可选，用于分组和排序数据。</span><br></pre></td></tr></table></figure></li><li><p><code>lead</code>: 获取 <strong>当前行之后</strong> 的某一列的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LEAD</span>(column_name, <span class="keyword">offset</span>, default_value) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_column <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_column)</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务与并发</title>
      <link href="/2023/07/22/shi-wu-yu-bing-fa/"/>
      <url>/2023/07/22/shi-wu-yu-bing-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是访问并可能更新各种数据项的一个程序执行单元，事务是不可分割的，要么执行全部内容要么不执行。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>原子性：事务的所有操作要么全部正确的反映出来，要么完全不反映</li><li>一致性：数据库从一个一致的数据库状态开始，结束于另一个一致的状态。例如转账金额总和不变。</li><li>隔离性：尽管多个事务可能并发执行，但系统保证每个事务感觉不到其他事务在执行</li><li>持久性：一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障</li></ul><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul><li>活动的：初始状态，事务执行时处于该状态</li><li>部分提交的：最后一条语句执行后。事务已经完成执行，但可能仍驻留在主存中</li><li>失败的：发现正常的执行不能继续后</li><li>中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后。事务进入中止状态系统有两种选择：重启（中止由硬件错误而不是内部逻辑导致）和杀死</li><li>提交的：成功完成后</li></ul><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>如果I和J是有不同的事务在相同数据项上执行的操作，并且其中有一个指令是write操作，那么I和J是冲突的。</p><ul><li>冲突等价：一系列非冲突指令的交换得到的调度是等价的</li><li>冲突可串行化-优先图：优先图无环则是冲突可串行化（充分非必要条件）</li></ul><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><ul><li>丢失更新（对数据的修改丢失了）</li><li>读脏数据（读取的数据不存在）</li><li>不可重复读（两次读到的数据不一样）</li></ul><h4 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h4><ul><li><p>一级封锁协议：事务在修改数据之前必须加排他锁，直到事务结束才释放</p><ul><li>解决丢失更新</li><li>会出现脏读、不可重复读</li></ul></li><li><p>二级封锁协议：一级封锁协议+事务在读取数据之前加共享锁，读完立即释放</p><ul><li>解决脏读</li><li>会出现不可重复读</li></ul></li><li><p>三级封锁协议：一级封锁协议+事务在读取数据之前加共享锁，<strong>事务结束</strong>才释放</p><ul><li>解决不可重复读</li></ul></li><li><p>两阶段封锁协议：三级封锁协议，需要在事务结束时才能释放锁，代价太大。 放宽事务释放锁的时机。分两个阶段提出加锁和解锁申请</p><ol><li>增长阶段：可以获得锁，但不能释放锁</li><li>缩减阶段：可以释放锁，但不能获得锁</li></ol></li><li><p>共享锁和排他锁：共享锁对数据可读不可写，排他锁可读可写</p></li><li><p>锁的升级：事务T要读写X的新值，X首先持有一个共享锁，待到T准备好写入新值时，将锁升级为排他锁</p></li><li><p>更新锁：如果Ti 想要读A且知道之后可能会写A，那么它就请求一个更新锁（非共享锁）</p><ul><li>更新锁随后可以升级为写锁，读锁不可以升级</li><li>X上已经持有一个共享锁时可以被授予更新锁，可是一旦X上持有一个更新锁，我们就应当防止X上被添加其他锁</li></ul></li><li><p>增量锁：</p><ul><li>一个一致性事务仅仅只有在拥有X上的增量锁时才能执行增量动作。增量锁不同时允许读动作或写动作。</li><li>在一个合法调度中，任何数量的事务能够在任何时间持有在X上的增量锁</li><li>动作inci(X) 与 rj(X) 和 wj(X)冲突, 但是并不与incj(X) 冲突</li></ul></li></ul><h4 id="隔离性级别"><a href="#隔离性级别" class="headerlink" title="隔离性级别"></a>隔离性级别</h4><ul><li><p>读未提交：允许读未提交数据</p><ul><li>解决丢失更新</li><li>存在不可重复读、脏读、幻象</li></ul></li><li><p>读已提交：只允许读已提交数据</p><ul><li>解决丢失更新、脏读</li><li>存在不可重复读、幻象</li></ul></li><li><p>可重复读：只允许读已提交数据，一个事务两次读取一个数据项期间其他事务不得更新该数据</p><ul><li>解决丢失更新、脏读、不可重复读</li><li>存在幻象</li></ul></li><li><p>可串行化读</p></li><li><p>隔离性级别的实现</p><ul><li>锁：共享锁用于事务读的数据项，排他锁用于事务写的数据项</li><li>时间戳：事务按照时间戳顺序访问数据项</li><li>多版本和快照隔离：维护多个版本数据项。快照隔离中想象每个事务有自己的数据库版本或快照，从私有的版本中读取数据，与其他事务隔离</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库存储和查询</title>
      <link href="/2023/07/11/shu-ju-ku-cun-chu-he-cha-xun/"/>
      <url>/2023/07/11/shu-ju-ku-cun-chu-he-cha-xun/</url>
      
        <content type="html"><![CDATA[<h3 id="存储和文件结构"><a href="#存储和文件结构" class="headerlink" title="存储和文件结构"></a>存储和文件结构</h3><h4 id="文件中记录的组织"><a href="#文件中记录的组织" class="headerlink" title="文件中记录的组织"></a>文件中记录的组织</h4><ul><li><p>堆文件组织：任意存储</p></li><li><p>顺序文件组织：根据搜索码的值顺序存储</p><p>插入删除时维护记录的物理顺序困难，可以使用指针链表来管理，插入位置不为空时将新纪录插入溢出块中，顺序处理效率降低。文件重组来恢复顺序</p></li><li><p>散列文件组织：根据散列函数的结果决定存储位置</p></li><li><p>多表聚簇文件组织：通常每个关系的记录用到单独的文件存储。多表聚簇文件组织是一种在每一块中存储两个或多个关系的相关记录的文件组织结构，可以高效的执行特定查询。</p></li></ul><h3 id="索引与散列"><a href="#索引与散列" class="headerlink" title="索引与散列"></a>索引与散列</h3><h4 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h4><p>基于值的顺序排序</p><ul><li>聚集索引（主索引）：搜索码指定的顺序与文件中记录的物理顺序相同</li><li>非聚集索引（辅助索引）：搜索码指定的顺序与文件中记录的物理顺序不同</li><li>稠密索引：文件中的每个搜索码值都有一个索引项，索引项包括索引值和指向第一条数据的指针。查找快</li><li>稀疏索引：只为搜索码的某些值建立索引项。只有当关系按照搜索码顺序存储时（聚集索引）才能使用稀疏索引。所占空间小，插入和删除所需维护开销小</li><li>多级索引：原始的内层索引上构造一个稀疏的外层索引</li><li>辅助索引：不是主索引的索引。必须是稠密索引，对每个搜索码值都有一个索引项，而且对文件的每一条记录都有一个指针。</li><li>多码上的索引：复合搜索码</li></ul><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ul><li>插入：叶结点中仍有空间；叶结点溢出；非叶结点溢出；分裂、新根结点</li><li>删除：叶结点内直接删除；页结点与兄弟结点合并；从兄弟结点借键；合并根结点</li><li>结点分裂、合并会影响到辅助索引更新指针，为此：在辅助索引中，不存储指向被索引的记录的指针，而是存储主索引搜索码属性的值。现在辅助索引定位记录需两步：首先用辅助索引找到主索引搜索码的值，然后用主索引找对应记录。</li></ul><h4 id="B-树扩展"><a href="#B-树扩展" class="headerlink" title="B+树扩展"></a>B+树扩展</h4><ul><li><p>B+树文件组织：叶结点存储记录而不是指向记录的指针</p></li><li><p>辅助索引和记录重定向：一些文件组织可能改变记录的位置，即使记录并没有更新。这可能影响到辅助索引，解决方法是：在辅助索引中不存储指向被索引记录的指针，而是存储主索引搜索码的值。</p></li><li><p>字符串上的索引：字符串上使用B+树有两个问题：字符串是变长的；字符串很长导致结点扇出降低以及相应的增加树的高度。使用<strong>前缀压缩</strong>技术可以增加结点的扇出，不用存储整个搜索码值，只存储一个足以区分开的前缀</p></li><li><p>B+树索引的批量加载：大量项一次插入到索引中。方法：首先创建一个含有关系索引项的临时文件，然后根据创建好的索引的搜索码来排序文件，最后插入到索引中。</p></li><li><p><strong>静态散列（散列索引）</strong>：</p><ul><li>散列函数：分布均匀、随机</li><li>桶（存储一条或多条记录的存储单位）溢出：<ul><li>原因：桶不足；偏斜（某些桶分配记录多，其他桶仍有空间）</li><li>溢出桶解决桶溢出问题：若桶已满则插入到溢出桶中，形成溢出链。这种散列结构称为闭地址。</li><li>开地址：桶固定，没有溢出链，桶满后将其插入其他桶。在数据库重要性不大</li></ul></li></ul></li><li><p><strong>动态散列</strong>：散列函数动态改变适应数据库增大或缩小</p><ul><li><p>数据结构：通过桶的分裂或合并适应数据库大小变化。选择的散列函数的值范围较大，是b位二进制整数，一个典型的b值是32，使用 高i 位标记桶，i随数据库大小变化而增大或减小。</p></li><li><p>查询和更新</p><ul><li>插入：若桶满，则分裂这个桶并对记录重新分配。分裂桶需要确定是否增加位数，如果只有一个表项指向桶，则多引入一位；如果多个表项指向桶不需要增加位数</li><li>删除：桶空删除。位数也应随之变化</li></ul></li><li><p>线性散列：使用低i位标记桶。与上述可扩充散列不同的是线性散列不使用间接层（桶地址表）</p></li></ul></li><li><p><strong>多维索引结构</strong>：</p><ul><li><p>类散列方法</p><ul><li>网格文件：存储指向记录的指针。根据每维的分量确定所属的桶，桶没有空间可以添加溢出块或通过增加或移动网格重组结构。适用范围查询和最临近查询</li><li>分段散列函数：适用部分匹配查询</li></ul></li><li><p>类树方法</p><ul><li>多键索引</li><li>kd-树：内部结点有一对属性和值将数据点分成两部分，所有维的属性在层间交替出现，叶子层为存储记录的存储块。</li><li>四叉树</li><li>R树（区域树）</li></ul></li><li><p>位图索引：关系有n个记录，字段有m种取值，则位图索引是m个长度为n的位向量集合。位图索引只是找到记录号，但是记录对应的磁盘地址不知道，可以创建一个辅助索引，索引项是记录号和记录地址。</p><ul><li><p>压缩位图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">对位图进行压缩，i个0和后面的一个1是一个段，对段进行编码</span><br><span class="line">0000 0000 0000 01//13个0,log2(13) = 4,所以编码为：</span><br><span class="line">11101101            //1110表示后面4位是有效值,1101表示13个0和一个1</span><br><span class="line">特殊:如果没有0,编码00;如果1个0，编码01</span><br><span class="line">例如:100000001000 -&gt; 00 110111</span><br><span class="line">1-&gt;00</span><br><span class="line">00000001-&gt;110111</span><br><span class="line">000-&gt;忽略</span><br><span class="line">解码:111011011011-&gt;0000 0000 0000 01 1 0001</span><br><span class="line">11101101-&gt;0000 0000 0000 01</span><br><span class="line">00-&gt;1</span><br><span class="line">1011-&gt;0001</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h4><ul><li><p><strong>选择运算</strong></p><p><img src="https://github.com/RonronnerW/RonronnerW.github.io/blob/master/img/db3.jpg"></p></li><li><p><strong>排序</strong>：外部排序归并算法</p></li><li><p><strong>连接运算</strong></p><ul><li><p>嵌套循环连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for each 元组r in R do begin</span><br><span class="line">for each 元组s in S do begin</span><br><span class="line">测试元组对(r,s)是否满足连接条件</span><br><span class="line">如果满足输出r·s</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>块嵌套循环连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for each 块r in R do begin</span><br><span class="line">for each 块s in S do begin</span><br><span class="line">for each 元组t in 块r do begin</span><br><span class="line">for each 元组v in 块s do begin</span><br><span class="line">测试元组对(r,s)是否满足连接条件</span><br><span class="line">如果满足输出r·s</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>索引嵌套循环连接：内层循环连接的属性上有索引，用索引查找替换文件扫描</p></li><li><p>归并连接：归并连接算法（排序-归并-连接算法）可用于自然连接和等值连接</p></li><li><p>散列连接：用于自然连接和等值连接。思想：关系r的一个元组和关系s的一个元组满足连接条件时，他们在连接属性上就会有相同的值。</p></li></ul></li><li><p><strong>其他运算</strong></p><ul><li><p>去除重复：可以用排序方法和散列实现去除重复</p></li><li><p>投影：对单个元组进行投影在去重</p></li><li><p>集合运算：</p><ul><li>对两个关系进行排序，然后对已排序关系扫描一次产生结果</li><li>使用相同的散列函数对两个关系进行划分r_0…r_n和s_0…s_n, 对r_i建立散列索引，再对s_i中元组根据并、交、差不同情况输出到结果中</li></ul></li><li><p>外连接：</p><ul><li>计算相应连接，然后将适当元组加入到连接结果中</li><li>对连接算法加以修改。例如计算左外连接时对嵌套循环算法进行修改，与内层元组都不匹配的外层元组加入结果</li></ul></li><li><p>聚集</p></li></ul></li><li><p><strong>表达式计算</strong>：</p><ul><li>物化：构造临时关系将其写到磁盘上</li><li>流水线：同时计算多个运算<ul><li>需求驱动的流水线：系统不停向位于流水线顶端的操作发出需要元组的请求</li><li>生产者驱动的流水线：各个操作并不等待元组请求，而是积极的产生元组</li></ul></li></ul></li></ul><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><ul><li><p><strong>等价规则</strong></p><ul><li><p>合取选择运算可分解为单个选择运算的序列 <code>在关系E上选择a和b属性，可分解为在E上取a属性的基础上取b属性</code></p></li><li><p>选择运算满足交换律</p></li><li><p>一系列投影运算中只有最后一个运算是必须的，其余可省略</p></li><li><p>选择操作可与笛卡尔积以及θ连接相结合</p><p><img src="https://img8.php1.cn/3cdc5/fd11/bdf/7b0a2aa1f1fa1468.png" alt="选择操作可与笛卡尔积以及θ连接相结合"></p></li><li><p>θ连接运算满足交换律</p><p><img src="https://img8.php1.cn/3cdc5/fd11/bdf/ac88ac68dc7c04af.png"></p></li><li><p>选择运算在下面两个条件下对θ连接运算具有分配律</p><p><img src="https://kgithub.com/RonronnerW/RonronnerW.github.io/blob/master/img/db1.png?raw=true"></p></li><li><p>投影运算在下面条件下对θ连接运算具有分配律</p><p><img src="https://kgithub.com/RonronnerW/RonronnerW.github.io/blob/master/img/db2.png?raw=true"></p></li><li><p>集合的并于交满足交换律和结合律</p></li><li><p>选择运算对并、交、差运算具有分配律</p></li><li><p>投影运算对并运算具有分配律</p></li></ul></li><li><p><strong>物化视图</strong>：内容已计算并存储的视图</p><ul><li>视图维护：触发器、增量的视图维护</li><li>增量的视图维护：只对视图的受影响部分进行修改<ul><li>连接操作：<code>对于视图v = r连接s 对r插入元组i, 更新v仅需要将 元组i连接s 的结果加入到物化视图中</code></li><li>选择和投影操作：<code>投影操作：对投影的每个元组可保留一个计数，记录该元组由几条途径得到</code></li><li>聚集操作：类似投影操作</li></ul></li></ul></li><li><p><strong>查询优化中的高级话题</strong>：</p><ul><li>top-K优化：只取结果中前k个</li><li>连接极小化：连接中去掉一个关系</li><li>更新的优化：万圣节问题（更新操作本身可能影响自己执行的问题）将更新查询批量收集，然后将批量的更新在其影响的索引上执行</li><li>多查询优化和共享式扫描：不同查询中间共同的子表达式，仅执行它们一次并在需要时重用。不是对于需要扫描一个关系的每一个查询都从磁盘重复读，而是读一次然后流水线的传递给每一个查询。</li><li>参数化查询优化</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/2023/07/06/shu-ju-ku-she-ji/"/>
      <url>/2023/07/06/shu-ju-ku-she-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="数据库设计和E-R模型"><a href="#数据库设计和E-R模型" class="headerlink" title="数据库设计和E-R模型"></a>数据库设计和E-R模型</h4><h5 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a><strong>E-R模型</strong></h5><ul><li>实体集：相同类型或性质的实体的集合。</li><li>联系集：联系指多个实体间的关联。联系集是相同类型联系的集合。</li><li>属性：属性可取值的集合叫域<ul><li>简单属性：不能划分更小的部分</li><li>复合属性：可以再划分，如地址</li><li>单值属性：如id</li><li>多值属性：如电话</li><li>派生属性：属性值不存储，需要时计算，如根据出生计算年龄</li></ul></li></ul><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h5><ul><li>映射基数：表示一个实体通过联系集能关联的实体个数。有一对一、一对多、多对一和多对多</li><li>参与约束：全部的或部分的：根据实体是否全部参与联系区分</li><li>码</li></ul><h5 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a><strong>E-R图</strong></h5><ul><li><p>基本结构：</p><ul><li>分成两部分的矩形：实体集，属性加下划线表示主码</li><li>菱形：联系集</li><li>未分割的矩形：联系集的属性</li><li>线段：连接属性集和联系集</li><li>虚线：连接联系集属性和联系集</li><li>双实线：全部参与</li></ul></li><li><p>映射基数：</p><ul><li>一对一：联系集到实体集的箭头</li><li>一对多&#x2F;多对一&#x2F;多对多：一用箭头，多用线段</li><li>线上用<code>l..h</code>标明最小和最大映射基数，最小值为1表示实体集全部参与，最大值为1表示实体参与至多一个联系，*代表没有限制</li></ul></li></ul><h5 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a><strong>弱实体集</strong></h5><ul><li><p>没有足够的属性以形成主码的实体集。有主码的实体集称为强实体集。弱实体集必须与称作标识或属主实体集的实体集关联才有意义。每个弱实体必须和一个标识实体关联。</p><p>区分弱实体集中实体的属性集合叫分辨符&#x2F;部分码</p><p>弱实体集的主码由标识实体集的主码加上分辨符构成</p><p>在E-R图中：</p><ul><li>弱实体集的分辨符以虚下划线标明</li><li>关联弱实体集和标识实体集的联系集以双菱形表示</li></ul></li></ul><h5 id="拓展的E-R特性"><a href="#拓展的E-R特性" class="headerlink" title="拓展的E-R特性"></a><strong>拓展的E-R特性</strong></h5><ul><li><p>特化：</p><ul><li><p>实体集中可能包含一些子集，子集中的实体某些方面区别于实体集中的其他实体。例如，实体集<code>person</code>可分为<code>employee</code>和<code>student</code>, 这两类中每一个都用一个属性集来描述，<code>employee</code>可以进一步用<code>salary</code>来描述，<code>student</code>进一步用<code>cred</code>来描述。</p></li><li><p>在实体集内部进行分组的过程称为<strong>特化</strong></p></li><li><p>E-R图中，特化用从特化实体指向另一方实体的空心箭头来表示。称这种关系为ISA关系，表示“是一个”。</p></li></ul></li><li><p>概化：高层实体集与低层实体集的包含关系。提取公共属性，概化是特化的逆过程</p><ul><li>全部概化&#x2F;特化：每个高层实体必须属于一个低层实体集</li><li>部分概化&#x2F;特化：允许一些高层实体不属于任何低层实体</li></ul></li><li><p>高层和低层实体集</p><ul><li>低层实体集有两种情况<ul><li>不相交：要求一个实体至多属于一个低层实体集</li><li>重叠：允许属于多个低层实体集</li></ul></li></ul></li><li><p>属性继承：高层实体集的属性被低层实体集所继承。</p></li><li><p>聚集：通过抽象将联系视为高层实体</p></li></ul><h4 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h4><h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h5><p>​一个域是原子的，如果该域的元素被认为是不可分的单元。</p><p>​关系的所有属性的域都是原子的（不可分的），则该关系模式属于第一范式。</p><h5 id="使用函数依赖分解"><a href="#使用函数依赖分解" class="headerlink" title="使用函数依赖分解"></a>使用函数依赖分解</h5><ul><li><p><strong>码和函数依赖</strong>：</p><ul><li>超码：可以唯一标识关系中一条元组的一个或多个属性的集合。子集K是超码的条件：关系r的实例中的所有元组对t1和t2总满足，若t1≠t2，则t1[K]≠t2[K]。</li><li>满足函数依赖 a-&gt;b 的条件：对所有元组对t1和t2，若t1[a]&#x3D;t2[a]，则t1[b]&#x3D;t2[b]</li><li>每个合法实例都满足函数依赖，则说该函数依赖在模式上成立</li><li>如果函数依赖K-&gt;R在r(R)上成立，则K是r(R)的一个超码。若t1[K]&#x3D;t2[K]，则t1[R]&#x3D;t2[R]（t1&#x3D;t2)</li><li>有些函数依赖称为平凡的，因为它们在所有关系中都满足。一般地，如果b包含于a，则形如a-&gt;b的函数依赖是平凡的。</li><li>A-&gt;B, B-&gt;C, 则A-&gt;C</li></ul></li><li><p><strong>Boyce-Codd范式（BCNF）</strong>：</p><ul><li><p>对F的闭包（F﹢）中所有形如 a-&gt;b 的函数依赖，下面至少一项成立：</p><ol><li><p>a-&gt;b 是平凡的函数依赖（即b包含于a）</p></li><li><p>a 是关系模式的一个超码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算a﹢，并且验证它是否包含R中的所有属性，即验证它是否是R的超码</span><br></pre></td></tr></table></figure></li></ol></li><li><p>分解不属于BCNF模式的一般规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设R不属于BCNF，则存在至少一个非平凡的函数依赖 a-&gt;b ,其中a不是R的超码。以下面两个模式取代R：</span><br><span class="line">(a∪b)</span><br><span class="line">(R-(b-a))</span><br><span class="line">产生的模式仍有不属于BCNF的，则继续分解，直至最终都是BCNF</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>第三范式</strong>：</p><ul><li><p>对F的闭包中所有形如 a-&gt;b 的函数依赖，下面至少一项成立：</p><ol><li><p>a-&gt;b 是一个平凡的函数依赖（b包含于a）</p></li><li><p>a 是 R 的一个超码</p></li><li><p>b-a 中的每个属性A都包含于R的一个候选码中（可能包含于不同的候选码中）</p></li></ol></li></ul></li></ul><h5 id="函数依赖理论"><a href="#函数依赖理论" class="headerlink" title="函数依赖理论"></a>函数依赖理论</h5><ul><li><p>Armstrong公理：</p><ul><li>自反律：若a为一属性集且b包含于a，则a-&gt;b成立</li><li>增补律：若a-&gt;b成立且r，则r∪a-&gt;r∪b</li><li>传递律：a-&gt;b和b-&gt;r，则a-&gt;r</li><li>合并律：a-&gt;b和a-&gt;r，则a-&gt;b∪r</li><li>分解律：a-&gt;b∪r，则a-&gt;b和a-&gt;r</li><li>伪传递律：a-&gt;b和c∪b-&gt;r，则a∪c-&gt;r</li></ul></li><li><p>计算闭包（F﹢）的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F﹢=F</span><br><span class="line">repeat</span><br><span class="line">for each F﹢中的函数依赖f</span><br><span class="line">在f上应用自反律和增补律</span><br><span class="line">将结果加入到F﹢中</span><br><span class="line">for each F﹢中的一对函数依赖f1和f2</span><br><span class="line">if f1和f2可以使用传递律结合起来</span><br><span class="line">将结果加入到F﹢中</span><br><span class="line">until F﹢不再发生变化</span><br></pre></td></tr></table></figure></li><li><p>属性集的闭包：a为一个属性集，函数依赖集下被a所确定的所有属性的集合称为a的<strong>闭包</strong>(a﹢)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ret:=a;</span><br><span class="line">repeat</span><br><span class="line">for each 函数依赖 b-&gt;c in F do</span><br><span class="line">begin</span><br><span class="line">if b包含于ret then ret:=ret∪c;</span><br><span class="line">            end</span><br><span class="line">     until (ret不变)</span><br></pre></td></tr></table></figure><ul><li>闭包的用途：<ul><li>判断a是否为超码，计算a﹢，检查a﹢是否包含所有属性</li><li>通过检查是否b包含于a﹢，我们可以检查函数依赖a-&gt;b是否成立</li></ul></li></ul></li><li><p>正则覆盖：是一个依赖集，其中任何函数依赖都不含无关属性（除去一个属性不影响闭包，则该属性是无关属性），函数依赖左半部都是唯一的。</p><ul><li><p>函数依赖集F及F中的函数依赖a-&gt;b</p><ul><li>如果A∈a并且F逻辑蕴含 (F-{a-&gt;b})∪(a-A)-&gt;b，则属性A在a中是无关的。</li><li>如果A∈b并且函数依赖集 (F-{a-&gt;b})∪a-&gt;(b-A)逻辑蕴含F，则属性A在b中是无关的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如，假设F包含AB-&gt;CD, A-&gt;E, E-&gt;C. 检验C在AB-&gt;CD中是否是无关的</span><br><span class="line">计算F&#x27;=&#123;A-&gt;E, E-&gt;C, AB-&gt;D&#125;下AB的闭包为ABCDE包含CD，所以是无关的</span><br></pre></td></tr></table></figure></li></ul></li><li><p>无损分解：把关系R投影到R1和R2上然后计算投影结果的自然连接，仍然能得到R。如果R1∩R2是R1或R2的超码，R上的分解就是无损分解。</p></li><li><p>保持依赖</p></li></ul><h5 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h5><ul><li><p>BCNF分解</p></li><li><p>3NF分解</p></li></ul><h5 id="使用多值依赖的分解"><a href="#使用多值依赖的分解" class="headerlink" title="使用多值依赖的分解"></a>使用多值依赖的分解</h5><ul><li><p>多值依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;-&gt;b</span><br><span class="line">关系r中任意一对满足t1[a]=t2[a]的元组对t1和t2,r中都存在元组t3和t4,使得</span><br><span class="line">t1[a]=t2[a]=t3[a]=t4[a]</span><br><span class="line">t3[b]=t1[b]</span><br><span class="line">t3[R-b]=t2[R-b]</span><br><span class="line">t4[b]=t2[b]</span><br><span class="line">t4[R-b]=t1[R-b]</span><br></pre></td></tr></table></figure></li><li><p>第四范式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数依赖和多值依赖集为D的关系模式r(R)属于第四范式的条件是，对D﹢中所有形如a-&gt;-&gt;b的多值依赖，至少有一下之一成立：</span><br><span class="line">a-&gt;-&gt;b是一个平凡的多值依赖</span><br><span class="line">a是R的一个超码</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计 E-R模型 关系数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系数据库</title>
      <link href="/2023/07/02/guan-xi-shu-ju-ku/"/>
      <url>/2023/07/02/guan-xi-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h4 id="码"><a href="#码" class="headerlink" title="码"></a>码</h4><ul><li><strong>超码</strong>：一个或多个属性的集合，这些属性的组合可以使我们在一个关系中<strong>唯一标识一个元组</strong>。</li><li><strong>候选码</strong>：最小超码称为候选码。</li><li><strong>主码</strong>：选中用来区分不同元组的候选码。</li><li><strong>外码</strong>：一个关系模式<code>r1</code>可能在它的属性中包括另一个关系模式<code>r2</code>的主码，这个属性在<code>r1</code>上称作参照<code>r2</code>的外码。</li></ul><h4 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h4><ul><li>选择（σ）：返回满足谓词的行</li><li>投影（π）：对输入关系的所有行输出指定属性。从输出中去除重复元组</li><li>自然连接（⋈）：两个关系相同名称的属性自动进行记录匹配，结果去除重复属性列</li><li>笛卡尔积（×）：两个关系中输出所有元组对（无论他们共同属性上的取值是否相同）</li><li>并（∪）：输出两个关系的元组的并</li></ul><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><h5 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h5><ul><li>数据定义语言：定义、删除、修改关系</li><li>数据操纵语言：插入、删除、修改元组</li><li>完整性</li><li>视图定义</li><li>事务控制：定义事务的开始和结束命令</li><li>嵌入式SQL和动态SQL</li><li>授权</li></ul><h5 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h5><ul><li><p><strong>基本类型</strong>：</p><table><thead><tr><th>类型</th><th>定义</th></tr></thead><tbody><tr><td>char(n)</td><td>固定长度字符串。会追加空格使其达到串长度。</td></tr><tr><td>varchar(n)</td><td>可变长度字符串。不会追加空格</td></tr><tr><td>int</td><td>整形</td></tr><tr><td>smallint</td><td>小整数类型</td></tr><tr><td>numeric(p,d)</td><td>定点数。p位数字，其中d位在小数点右边</td></tr><tr><td>real, double precision</td><td>浮点数和双精度浮点数</td></tr><tr><td>float(n)</td><td>精度至少为n的浮点数</td></tr></tbody></table></li><li><p><strong>基本模式定义</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table r</span><br><span class="line">(A1 D1,</span><br><span class="line">A2 D2,</span><br><span class="line">...</span><br><span class="line">An Dn,</span><br><span class="line">&lt;完整性约束k&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>完整性约束：<ul><li><code>primary key(a)</code>：主码</li><li><code>foreign key(a) references B</code>：外码</li><li><code>not null</code>：不允许空值</li></ul></li></ul><p>插入元组：<code>insert into r values(&#39;wang&#39;,&#39;a&#39;);</code></p><p>删除所有元组：<code>delete from r</code></p><p>删除关系：<code>drop table r</code></p><p>为关系添加属性：<code>alter table r add A D</code>,A为属性，D为属性的域</p><p>去掉属性：<code>alter table r drop A</code></p></li></ul><h5 id="查询的基本结构"><a href="#查询的基本结构" class="headerlink" title="查询的基本结构"></a>查询的基本结构</h5><ul><li>单关系查询：<code>select dept_name from department;</code><ul><li>强行删除重复：**<code>distinct</code>**</li><li>where 满足特定谓词：<code>select dept_name from department where ... ;</code></li></ul></li><li>多关系查询：把访问的关系都列在from中，where指定匹配条件</li><li>自然连接：**<code>natural join </code>**</li><li>指定列名连接：**<code>r1 join r2 using(A1, A2)</code>**</li></ul><h5 id="附加的基本运算"><a href="#附加的基本运算" class="headerlink" title="附加的基本运算"></a>附加的基本运算</h5><ul><li><p>更名运算：<code>old-name as new-name</code>，可以出现在<code>select</code>和<code>from</code>中。方便使用；适用于比较同一关系中元组的情况，便于区分。</p></li><li><p>字符串运算：使用<code>Like</code>操作实现模式匹配，模式是大小写敏感的</p><ul><li><code>%</code>：匹配任意子串</li><li><code>_</code>：匹配任意一个字符</li><li>使用<code>escape</code>定义转义字符。<code>like &#39;ab\%cd%&#39; escape &#39;\&#39;  匹配ab%cd开头字符串   </code></li></ul></li><li><p>正则表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mysql使用REGEXP</span><br><span class="line"></span><br><span class="line">^:匹配开始位置</span><br><span class="line">[A-Za-z]:匹配大小写字母</span><br><span class="line">[A-Za-z0-9_.-]:匹配字母(大写或小写)、数字、下划线 _、句点.和/或横杠-的字符串</span><br><span class="line">*:匹配前面的子表达式零次或多次</span><br><span class="line">@leetcode[.]com:匹配@leetcode.com</span><br><span class="line">$:匹配结尾</span><br><span class="line"></span><br><span class="line">where mail REGEXP &#x27;^[A-Za-z][A-Za-z0-9_.-]*@leetcode[.]com$&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>排序：**<code>order by </code>** 默认升序，可以用<code>desc</code>表示降序，<code>asc</code>表示升序</p></li><li><p>where子句谓词：</p><ul><li><code>between A and B  表示一个值属于[A,B]</code></li><li><code>and   增加一个条件</code></li><li>元组比较运算：<code>(a1,a2) &lt;= (b1,b2) 表示a1&lt;=b1且a2&lt;=b2时为真</code></li></ul></li></ul><h5 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h5><ul><li><code>union</code>：并。自动去重复，保留重复必须用<code>union all</code></li><li><code>intersect</code>：交。</li><li><code>except</code>：差。</li></ul><h5 id="空值"><a href="#空值" class="headerlink" title="空值"></a><strong>空值</strong></h5><ul><li>算数运算：任一输入为空，结果为空</li><li>比较运算：涉及空值的比较运算结果为<code>unknown</code>，where子句谓词对一个元组计算出false或unknown都不能加入到结果集中。在谓词中<code>null = null</code>会返回unknown，而不是true。</li><li>集合运算</li></ul><h5 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a><strong>聚集函数</strong></h5><p>以值的一个集合为 输入，返回单个值的函数。例如：<code>avg,min,max,sum,count</code></p><ul><li><p>基本聚集：计算元组个数使用<code>count(*)</code>，使用<code>count(*)</code>时不允许使用<code>distinct</code></p></li><li><p>分组聚集：<code>group by</code>给出一个或多个属性来构造分组。注意：出现在<code>select</code>中但是没有被聚集的属性只能是出现在<code>group by</code>子句中的那些属性。换句话说，任何没有出现在group by 中的属性如果出现在select 中的话，只能出现在聚集函数内部。</p></li><li><p>having 子句：对分组限定条件，跟在<code>group by</code>后面。<strong>having中的谓词在形成分组后才起作用，所以可以使用聚集函数</strong>。出现在<code>having</code>中但是没有被聚集的属性只能是出现在<code>group by</code>子句中的那些属性</p></li><li><p>操作序列</p><ul><li>满足where谓词的元组通过group by子句形成分组</li><li>如果出现了having子句，它将应用到每个分组上</li></ul></li><li><p>对空值和布尔值的聚集：除了<code>count(*)</code>外所有聚集函数都<strong>忽略空值</strong>。空集的count运算值为0，其他聚集函数输入为空集情况下返回一个空值。</p></li></ul><h5 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a><strong>嵌套子查询</strong></h5><ul><li><p>集合成员资格：<code>in</code>测试元组是否是集合中的成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct ID)</span><br><span class="line">from takes</span><br><span class="line">where (course_id,sec_id) in (select course_id,sec_id</span><br><span class="line">from teaches</span><br><span class="line">where tesches.ID = 10101);</span><br></pre></td></tr></table></figure></li><li><p>集合的比较：</p><ul><li><p>至少比某一个大: <code>&gt; some</code>, 也允许<code>&lt; some, &lt;= some, &gt;=some, =some等价于in, &lt;&gt; some并不等价于not in</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; some(select salary</span><br><span class="line">from instructor</span><br><span class="line">where dept_name = &#x27;Biology&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>比所有的都大：<code>&gt; all</code>, <code>&lt;&gt; all等价于not in, =all不等价于in</code></p></li></ul></li><li><p>空关系测试：子查询结果集中是否存在元组：<code>exists</code>，非空返回true；可将关系A包含关系B写成<code>not exists(B except A)</code></p></li><li><p>重复元组存在性测试：<code>unique</code>，没有重复返回true；</p></li><li><p>from子句中的子查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, avg_salary</span><br><span class="line">from (select dept_name,avg(salary)</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name</span><br><span class="line">as dept_avg(dept_name,avg_salary)) --as给子查询的结果关系起名字并对属性重命名</span><br><span class="line">where avg_salary &gt; 4200;</span><br></pre></td></tr></table></figure><p>from子句嵌套的子查询中不能使用来自from子句其他关系的相关变量，想要实现此操作需要以**<code>lateral</code>**作为前缀，只有少数数据库支持。</p></li><li><p>with子句：定义临时关系，只对包含with子句的查询有效。例如找出最大预算值的系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with max_budget(value) as</span><br><span class="line">(select max(budget)</span><br><span class="line">from department)</span><br><span class="line">select budget</span><br><span class="line">from department,max_budget</span><br><span class="line">where department.budget = max_budget.value;</span><br></pre></td></tr></table></figure></li><li><p>标量子查询：返回包含单个属性的单个元组，可以出现在任何地方</p></li></ul><h5 id="数据库的修改"><a href="#数据库的修改" class="headerlink" title="数据库的修改"></a>数据库的修改</h5><ul><li><p>删除：<code>delete</code>删除元组, 只能作用于一个关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from r</span><br><span class="line">where P；</span><br></pre></td></tr></table></figure></li><li><p>插入：<code>insert</code>, 单个元组插入请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into r</span><br><span class="line">values(&#x27;101&#x27;,&#x27;DS&#x27;,4);</span><br><span class="line"></span><br><span class="line">insert into r</span><br><span class="line">select *</span><br><span class="line">from s</span><br><span class="line">where P;</span><br></pre></td></tr></table></figure></li><li><p>更新：<code>update</code>, 改变元组部分属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update r</span><br><span class="line">set course_id = &#x27;102&#x27;</span><br><span class="line">where P;</span><br></pre></td></tr></table></figure></li><li><p>case语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">when pred1 then ret1</span><br><span class="line">when pres2 then ret2</span><br><span class="line">else retn</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><h4 id="中级SQL"><a href="#中级SQL" class="headerlink" title="中级SQL"></a>中级SQL</h4><h5 id="连接表达式"><a href="#连接表达式" class="headerlink" title="连接表达式"></a><strong>连接表达式</strong></h5><ul><li><p>连接条件：<code>on</code>可以指定任意的连接条件, 出现在连接表达式的末尾</p><p><code>on</code>和<code>where</code>在外连接中的表现不同：on条件是外连接声明的一部分，where子句却不是。具体表现就是使用<code>on</code>会补上空值的元组，<code>where</code>会排除条件为假的元组。</p></li><li><p>外连接：通过在结果中创建空值元组的方式，保留连接中丢失的元组</p><ul><li><p>左外连接：只保留出现在左外连接运算之前左边关系的元组,其余属性为空值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from student left outer join takes;</span><br></pre></td></tr></table></figure></li><li><p>右外连接：保留右边  <code>right outer join</code></p></li><li><p>全外连接：两边都保留 <code>full outer join</code></p></li></ul></li></ul><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a><strong>视图</strong></h5><ul><li><p>从基本表中导出的虚拟的表，数据库存储视图定义本身，而不存储执行结果。</p><ul><li><p>视图定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create view view_name as</span><br><span class="line">&lt;query ecpression&gt;;</span><br></pre></td></tr></table></figure></li><li><p>物化视图：允许存储视图关系，但是必须保证：定义视图的实际关系变化时，视图也随之修改。物化视图查询很快，避免了读取大量底层关系。</p></li><li><p>视图更新：一般不允许对视图关系进行修改</p><ul><li><p>视图可更新的条件</p><ul><li><p>from子句中只有一个关系</p></li><li><p>select子句中只包含关系的属性名，不包含任何表达式、聚集或distinct声明</p></li><li><p>任何没有出现在select子句中的属性可以取空值</p></li><li><p>查询中不包含group by或having子句</p></li></ul></li></ul></li></ul></li></ul><h5 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a><strong>完整性约束</strong></h5><p>防止对数据的意外破坏。作用于创建关系命令的一部分被声明，也可以通过<code>alter table table_name add ...</code>命令施加到关系上</p><ul><li><code>not null</code>：禁止主码出现空值，因此主码不必再显式声明为not null</li><li><code>unique( A1,A2,...)</code>：声明属性形成一个<strong>候选码</strong>，没有两个元组能在所列出的属性上取值相同. 候选码属性可以为null，因为空值不等于其他任何值</li><li><code>check( &lt;谓词&gt; )</code>：保证属性值满足指定的条件。例如：<code>check(budget&gt;0)</code></li><li>参照完整性：外码<code>foreign key(dept_name) references department</code><ul><li>违反参照完整性时，通常是拒绝执行，但<code>foreign key</code>可以指明进一步修改参照关系的元组来恢复参照完整性，例如<ul><li>级联<code>on delete/update cascade</code></li><li>其他，可将参照域设为null <code>set null代替cascade</code>，或者设置为域的默认值<code>set default</code></li></ul></li></ul></li></ul><h5 id="SQL数据类型与模式："><a href="#SQL数据类型与模式：" class="headerlink" title="SQL数据类型与模式："></a><strong>SQL数据类型与模式</strong>：</h5><ul><li><p>日期和时间：<code>data:日期; time:时间; timestamp:data于time的组合</code></p></li><li><p>默认值：<code>default 0:默认值为0</code></p></li><li><p>创建索引：高效的查找而不用扫描关系中的所有元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index student_index on student(ID);</span><br></pre></td></tr></table></figure></li><li><p>大对象类型：例如图片等。字符数据的大对象数据类型（clob）、二进制数据的大对象数据类型（blob）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book_review clob (10KB)</span><br><span class="line">image blob (10MB)</span><br></pre></td></tr></table></figure></li><li><p>用户定义类型</p><ul><li><p>独特类型：</p><ul><li><p>定义新类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create type Dollars as numeric(12,2) final; --Dollars定义为numeric(12,2)</span><br></pre></td></tr></table></figure></li><li><p>类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast(budget to numeric(12,2))</span><br></pre></td></tr></table></figure></li><li><p>删除和修改创建过的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop/alter type</span><br></pre></td></tr></table></figure></li><li><p>定义域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create domain DDolars as numeric(12,2) not null;</span><br></pre></td></tr></table></figure><p>域和类型区别：</p><ol><li>域上可以声明约束和默认值</li><li>域并不是强制类型的，一个域类型的值可以被赋给另一个域类型，只要它们基本类型相容</li></ol></li><li><p>创建模式相同的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table temp_r like r; --创建temp_r具有与r相同的模式</span><br><span class="line">create table t as</span><br><span class="line">(select *</span><br><span class="line">from r</span><br><span class="line">where ...</span><br><span class="line">)</span><br><span class="line">with data; --表t被创建，同时载入数据</span><br></pre></td></tr></table></figure></li></ul></li><li><p>结构化数据类型</p></li></ul></li></ul><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a><strong>授权</strong></h5><ul><li><p>权限的授予与收回：默认情况下，被授予权限的用户&#x2F;角色无权将权限再授予其他用户&#x2F;角色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &lt;权限列表&gt;--select/insert/update/delete</span><br><span class="line">on &lt;关系/视图&gt;</span><br><span class="line">to &lt;用户/角色列表&gt;;   --public指系统的所有当前用户和将来的用户</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revoke &lt;权限列表&gt;</span><br><span class="line">on &lt;关系/视图&gt;</span><br><span class="line">from &lt;用户/角色列表&gt;;</span><br></pre></td></tr></table></figure></li><li><p>角色：</p><ul><li>创建角色：<code>create role instrutor;</code></li><li>授予权限：同上</li><li>角色可以授予用户&#x2F;角色：<code>grant A to B;</code></li></ul></li><li><p>权限的转移：允许将得到的权限传递给其他用户，需要附加<code>with grant option</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on department to Amit with grant option;</span><br></pre></td></tr></table></figure></li><li><p>权限的收回：大多数数据库系统中，权限收回默认是级联的。可以申明<code>restrict</code>防止级联收回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke select on departmnet from Amit restrict;--防止级联收回</span><br></pre></td></tr></table></figure></li></ul><h4 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h4><h5 id="函数和过程"><a href="#函数和过程" class="headerlink" title="函数和过程"></a><strong>函数和过程</strong></h5><ul><li><p>声明和调用函数和过程</p><p>输入自己的函数和过程通常用<code>create or replace</code>对旧代码替换。SQL支持函数重载</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//函数：给定系名返回教师数目</span><br><span class="line">create function dept_count(dept_name varchar(20))</span><br><span class="line">returns integer</span><br><span class="line">begin</span><br><span class="line">declare d_count integer;</span><br><span class="line">select count(*) into d_count</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dpt_name = dept_name</span><br><span class="line">return d_count;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//过程：in和out 分别表示参数和返回值</span><br><span class="line">create procedure dept_count(in dept_name varchar(20),out d_count integer)</span><br><span class="line">begin</span><br><span class="line">select count(*) into d_count</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dept_name = dept_name</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>​表函数：返回关系作为结果的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create function instrutor_of(dept_name varchar(20))</span><br><span class="line">return table(</span><br><span class="line">ID varchar(5),</span><br><span class="line">name varchar(20))</span><br><span class="line">return table</span><br><span class="line">(select ID,name</span><br><span class="line">from instrutor</span><br><span class="line">where instrutor.dept_name = dept_name);</span><br></pre></td></tr></table></figure><p>​使用<code>call</code>调用</p><ul><li><p>支持过程和函数的语言构造</p><ul><li><p>变量声明<code>declare d_cnt integer</code></p></li><li><p>变量赋值<code>set d_cnt = 10</code></p></li><li><p><code>while</code>和<code>repeat</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while 布尔表达式 do</span><br><span class="line">语句序列;</span><br><span class="line">end while</span><br><span class="line">repeat</span><br><span class="line">语句序列;</span><br><span class="line">until 布尔表达式</span><br><span class="line">end repeat</span><br></pre></td></tr></table></figure></li><li><p><code>if-then-else</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式</span><br><span class="line">than 语句</span><br><span class="line">elseif 布尔表达式</span><br><span class="line">than 语句</span><br><span class="line">else 语句</span><br><span class="line">end if</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h5><p>触发器是一条语句，当对数据库进行修改时，系统自动执行。</p><p>设置触发器必须满足两个条件：1、指明什么条件下执行触发器。2、指明触发器执行时的动作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create trigger check after insert on section--插入元组后启动触发器</span><br><span class="line">referencing new row as nrow--建立一个过渡变量用来在插入完成后存储所插入值</span><br><span class="line">for each row--插入多个元组时，可以显式迭代每一个元组</span><br><span class="line">when (nrow.id not in(--when指定一个条件</span><br><span class="line">select slot_id</span><br><span class="line">from slot))</span><br><span class="line">begin--触发器执行</span><br><span class="line">rollback--回滚</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 指定哪个属性更新执行触发器</span><br><span class="line">after updata of takes on grade</span><br></pre></td></tr></table></figure><h4 id="形式化关系查询语言"><a href="#形式化关系查询语言" class="headerlink" title="形式化关系查询语言"></a>形式化关系查询语言</h4><h5 id="关系代数-1"><a href="#关系代数-1" class="headerlink" title="关系代数"></a>关系代数</h5><ul><li>基本运算：选择（σ）、投影（Π）、并、集合差、笛卡儿积、更名运算（ρ）</li><li>附加的关系代数运算：集合交运算、自然连接、theta连接、赋值运算、外连接</li><li>拓展的关系代数运算：广义投影（允许投影列表中使用算数运算和字符串函数）、聚集</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/06/23/c/"/>
      <url>/2023/06/23/c/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>预处理器</strong>：</p><p><code>#define</code> 指令把一个名字设定为预处理变量</p><p><code>#ifdef</code> 当且仅当变量已定义时为真，<code>#ifndef</code> 当且仅当变量未定义时为真。一旦结果为真则执行后续操作直到遇到<code>#endif</code>指令为止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">std::string bookNo;</span><br><span class="line">unsigned units_sold  = 0;</span><br><span class="line">double revenue = 0.0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>第一次包含<code>Sales_data.h</code>时，<code>#ifndef</code>检查结果为真，预处理器执行后面操作直到遇到<code>#endif</code>。此时SALES_DATA_H值变为已定义，<code>Sales_data.h</code>也会被拷贝到程序中。后面再次包含<code>Sales_data.h</code>时检查结果为假，编译器忽略。</p></li><li><p><strong>声明和定义</strong>： </p><ul><li><p>声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含那个名字的声明。定义负责创建与名字关联的实体。声明规定了变量的类型和名字，定义还申请存储空间，也可能赋一个初值。</p></li><li><p>想声明而非定义变量，就在变量名前添加关键字<code>extern</code>, 而且不要显式地初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明</span><br><span class="line">int j; //定义</span><br><span class="line">extern int i = 1; //定义 任何包含显式初始化的声明成为定义</span><br></pre></td></tr></table></figure></li><li><p>多个文件中使用同一个变量，就必须声明和定义分离。此时，定义必须出现且只能出现在一个文件中，其他文件中对其声明。</p></li></ul></li><li><p><strong>复杂的数组声明</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *ptrs[10];//从右往左理解，表示含有十个整型指针的数组</span><br><span class="line">int (*parray)[10] = &amp;arr;//从内往外理解，parray指向一个含有10个整数的数组</span><br><span class="line">int (&amp;arrref)[10] = arr;//从内往外理解，arrref引用一个含有10个整数的数组</span><br><span class="line">int *(&amp;array)[10] = ptrs;//array是数组的引用，该数组含有10个指针</span><br></pre></td></tr></table></figure></li><li><p><strong>指针与引用</strong>：</p><ul><li><p>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针生命周期内它可以先后指向不同的对象。</p></li><li><p>指针无需再定义时赋初值。</p></li><li><p>引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p></li><li><p>一旦定义引用就无法再绑定到另外的对象，之后每次使用这个引用都是访问最初绑定的对象。</p></li><li><p>指向指针的引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int *p;//p是指针</span><br><span class="line">int *&amp;r = p;//r是一个对指针p的引用. 从右往左，首先r是一个引用，然后引用的是一个int指针</span><br><span class="line">r = &amp;i;//r引用了一个指针，和r赋值&amp;i就是另p指向i</span><br><span class="line">*r = 0;//解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>深拷贝和浅拷贝</strong>：</p><ul><li><p>浅拷贝：简单的赋值拷贝操作</p></li><li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">//浅拷贝</span><br><span class="line">Person(int age ,int height) &#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = height;</span><br><span class="line">&#125;</span><br><span class="line">//深拷贝</span><br><span class="line">Person(int age ,int height) &#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = new int(height);</span><br><span class="line">&#125;</span><br><span class="line">//析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">if (m_height != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">int* m_height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数指针</strong>：指向函数的指针。函数的类型由返回类型和形参类型共同决定，与函数名无关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool (*pf)(const int&amp; a, const int&amp; b);//函数指针，pf指向一个函数，返回值是bool类型</span><br><span class="line">bool *pf(const int&amp; a, const int&amp; b);//指针函数，名为pf的函数，返回bool*</span><br><span class="line"></span><br><span class="line">bool compare(const int&amp; a, const int&amp; b);</span><br><span class="line">//把函数名作为一个值使用时，该函数自动转换成指针</span><br><span class="line">pf = compare;//pf指向名为compare的函数</span><br><span class="line">pf = &amp;compare;//等价，取地址符是可选的</span><br></pre></td></tr></table></figure></li><li><p><strong><code>const</code>作用</strong>：</p><ol><li><p>定义常量</p></li><li><p>类型检查。const与#define定义常量的区别：const常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，只是简单的字符替换，不能进行安全检查。</p></li><li><p>修饰指针，分为指向常量的指针和指针常量</p></li><li><p>常量引用，经常用于形参，既避免了拷贝，又避免了函数对值的修改</p></li><li><p>修饰成员函数，说明成员函数内不能修改成员变量</p></li></ol></li><li><p><strong><code>const</code>的引用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line">const int &amp;r1 = ci;// 正确，引用及其对象都是常量</span><br><span class="line">int &amp;r2 = ci;// 错误，试图让一个非常量引用指向一个常量对象</span><br><span class="line"></span><br><span class="line">int i = 42;</span><br><span class="line">const int &amp;r3 = i;// 正确，允许将const int&amp;绑定到一个普通int对象上</span><br></pre></td></tr></table></figure></li><li><p>**指针和<code>const</code>**：</p><ul><li><p><strong>指向常量的指针（<code>pointer to const</code>）</strong>: 不能用于改变其所指对象的值。要想存放常量对象地址，只能使用指向常量的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int *a;//指向常量的指针</span><br><span class="line">int const *a;//同上。cosnt位于*的左侧，则const用来修饰指针指向的变量</span><br><span class="line">*a = 10;//错误</span><br><span class="line"></span><br><span class="line">//允许把非const对象地址赋给指向const对象的指针</span><br><span class="line">const int *ptr;</span><br><span class="line">int val = 3;</span><br><span class="line">ptr = &amp;val;//正确，但是不能通过ptr指针修改val</span><br></pre></td></tr></table></figure></li><li><p><strong><code>const</code>指针（<code>const pointer</code>）</strong>：常量指针，必须初始化且初始化后值不能再改变。把*放在<code>const</code>之前说明指针是一个常量，意味着不变的是指针本身的值而非指向的那个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;</span><br><span class="line">int *const cur = &amp;num;//cur 将一直指向num</span><br><span class="line">//从右往左阅读，离cur最近的是const，意味着cur本身是一个常量对象，对象的类型为int*，</span><br><span class="line">//即cur是一个常量指针，该常量指针指向一个int对象</span><br><span class="line"></span><br><span class="line">const double pi = 3.14;</span><br><span class="line">const double *const pip = &amp;pi;//pip是一个指向常量对象的常量指针</span><br><span class="line">//pip本身是一个常量对象，对象类型是const double*，表示pip是一个指向常量的常量指针</span><br></pre></td></tr></table></figure></li></ul></li><li><p>**顶层<code>const</code>**：顶层<code>const</code>表示指针本身是常量，底层<code>const</code>表示指针所指对象是一个常量。更一般的，顶层<code>const</code>可以表示任意的对象是常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *const p1 = &amp;i;//不能改变p1的值，顶层const</span><br><span class="line">const int ci = 42;//不能改变ci的值，顶层const</span><br><span class="line">const int *p2 = &amp;ci;//允许改变p2的值，底层const</span><br><span class="line">const int *const p3 = p2;//靠右的const的顶层，靠左的是底层</span><br><span class="line">const int &amp;r = ci;//声明引用的const都是底层</span><br></pre></td></tr></table></figure><p>拷贝操作时，顶层<code>const</code>不受影响，底层<code>const</code>必须具有相同的底层<code>const</code>资格，一般来说非常量可以转换成常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = ci;//正确</span><br><span class="line">p2 = p3;//正确，p2和p3指向对象类型相同，p3顶层const部分不影响</span><br><span class="line"></span><br><span class="line">int *p = p3;//错误，p3包含底层const定义而p没有</span><br><span class="line">p2 = &amp;i;//正确，int*能转换成const int*</span><br><span class="line">int &amp;r = ci;//错误，普通的int不能绑定到int常量上</span><br><span class="line">const int &amp;r2 = i;//正确，const int&amp;可以绑定到普通的int上</span><br></pre></td></tr></table></figure></li><li><p><strong>static</strong>：</p><ul><li><p>静态变量：变量声明为static时，空间将在程序的生命周期内分配，只分配一次。类中的静态变量由对象共享，不能使用构造函数初始化，应使用类外的类名和范围解析运算符显式初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Apple&#123;</span><br><span class="line">public:</span><br><span class="line">static int i;</span><br><span class="line">&#125;</span><br><span class="line">int Apple::i = 0;</span><br></pre></td></tr></table></figure></li><li><p>静态成员：</p><ul><li>类对象为静态：对象的生命周期直到程序结束。</li><li>类中的静态函数：允许静态成员函数仅访问静态数据成员和其他静态成员函数，无法访问非静态成员和函数。</li></ul></li></ul></li><li><p><strong>重载和<code>const</code>形参</strong>：</p><ul><li><p>顶层<code>const</code>不影响传入函数的对象。一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(Phone);</span><br><span class="line">Record lookup(cosnt Phone);//重复声明</span><br><span class="line"></span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(Phone* const);//重复声明</span><br></pre></td></tr></table></figure></li><li><p>如果形参是指针或引用，则区分其指向常量对象还是非常量对象可以实现函数重载，此时<code>const</code>是底层的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(Phone&amp;);</span><br><span class="line">Record lookup(cosnt Phone&amp;);//新函数，作用于常量引用</span><br><span class="line"></span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(const Phone*);//新函数，作用于指向常量的指针</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>this</code>指针</strong>：作用在类内部，当类的非静态成员函数中访问类的非静态成员的时候，编译器自动将对象本身地址作为一个隐含参数传递给函数。</p><ul><li><p>在类的非静态成员函数中返回类对象本身的时候，直接使用<code>return *this</code>.</p></li><li><p>参数与变量名相同时，必须<code>this-&gt;n = n</code>。</p></li><li><p><code>this</code>指针会被编译器解析为<code>A *const</code>。</p></li><li><p><code>this</code>是右值</p></li></ul></li><li><p>**<code>inline</code>**：内联能提高函数效率，但是内联是以代码膨胀为代价的，仅仅省区函数调用的开销从而提高执行效率。不适合使用内联：函数体内代码比较长；函数体内出现循环。</p><ul><li><p>虚函数（virtual）和内联（inline）：</p><ul><li><p>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联。内联是编译期间，虚函数多态在运行期间，编译器无法知道运行期间用哪个代码，因此虚函数表现多态时不可以内联。</p></li><li><p><code>inline virtual</code>唯一可以内联时候：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p></li></ul></li></ul></li></ul><p>​      </p><ul><li><p>**<code>class</code>和<code>struct</code>**：唯一区别是默认访问权限不一样，<code>struct</code>默认<code>public</code>，<code>class</code>默认<code>private</code>。</p></li><li><p>**<code>union</code>**：一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。</p></li><li><p><strong><code>sizeof</code>类大小计算</strong>：</p><ul><li>空类大小为1字节</li><li>一个类中，成员函数、静态数据成员不占存储空间</li><li>不管多少个虚函数只有一个虚指针的大小</li><li>派生类继承了所有基类的函数和成员，按照字节对齐计算大小。虚函数都是继承基类的虚指针。</li></ul></li><li><p>**<code>extern &quot;C&quot;</code>**：告诉编译器按照C的方式编译。</p><ul><li><p>C++调用C函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern int add(...)</span><br><span class="line"></span><br><span class="line">//xx.c</span><br><span class="line">int add()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//xx.cpp</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    #include &quot;xx.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C调用C++函数：<code>extern &quot;C&quot;</code>在C中是语法错误，需要放在C++头文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">    int add();</span><br><span class="line">&#125;</span><br><span class="line">//xx.cpp</span><br><span class="line">int add()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//xx.c</span><br><span class="line">extern int add();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>lambda表达式</strong>：</p><p><strong>[ capture list ]   ( parameter list )  -&gt;  return type   { function body }</strong></p><p>capture list:捕获列表；parameter list：参数列表；return type：返回类型；function body：函数体</p><p>我们可以忽略参数列表和返回类型，但必须包含捕获列表和函数体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto f = [] &#123;return 42;&#125;//忽略括号和参数列表等价于指定一个空参数列表</span><br><span class="line">cout&lt;&lt;f()&lt;&lt;endl;//输出42</span><br><span class="line">[] (const string&amp; a,const string&amp; b) &#123;return a.size()&lt;b.size();&#125;</span><br></pre></td></tr></table></figure><p>lambda捕获列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]空捕获列表。lambda不能使用所在函数中的变量</span><br><span class="line">[names]names是一个逗号分隔的名字列表，都是所在函数的局部变量，默认情况下捕获列表中的变量都被拷贝。名字前加&amp;，则采用引用捕获方式。</span><br><span class="line">[&amp;]隐式捕获列表，采用引用捕获方式，使用所在函数的实体的引用</span><br><span class="line">[=]隐式，采用值捕获方式，拷贝所在函数的实体的值</span><br><span class="line">[&amp;,names]names采用值捕获方式，不能加&amp;</span><br><span class="line">[=,names]names采用引用方式捕获，必须加&amp;</span><br></pre></td></tr></table></figure></li><li><p><strong>智能指针</strong>：</p><ul><li><p><code>shared_ptr</code>：允许多个指针指向同一个对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; sp;//空指针，可以指向类型为T的对象</span><br><span class="line">p.get();//返回p中保存的指针</span><br><span class="line">make_shared&lt;T&gt; (args);//返回一个shared_ptr，指向一个动态分配类型为T的对象。使用args初始化对象。最安全的分配</span><br><span class="line">shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(42);</span><br><span class="line">shared_ptr&lt;T&gt; p(q);//p是shared_ptr的拷贝</span><br><span class="line">p = q;//此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0则将其管理的原内存释放</span><br><span class="line">p.use_count();//若p.use_count()为1，返回true</span><br><span class="line">p.unique();//返回p共享对象的智能指针数量</span><br></pre></td></tr></table></figure></li><li><p><code>unique_ptr</code>：独占所指向对象。不支持普通的拷贝或赋值操作，但是可以通过release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr。不能拷贝的规则有一个例外：可以拷贝或赋值一个将要被销毁的unique_ptr，如返回局部对象的拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; p(new int(42));</span><br><span class="line">unique_ptr&lt;int&gt; p1(p2);//错误，不支持拷贝</span><br><span class="line">p1 = p2;//错误，不支持赋值</span><br><span class="line">unique_ptr&lt;int&gt; p2(p1.release());//将所有权从p1转移给p2。release将p1置空</span><br><span class="line">p2.reset(p3.release());//将所有权从p3转移给p2。reset释放了p2原来指向内存</span><br></pre></td></tr></table></figure></li><li><p><code>weak_ptr</code>：弱引用，指向<code>shared_ptr</code>所管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto p = make_shared&lt;int&gt;(42);</span><br><span class="line">weak_ptr&lt;int&gt; wp(p);//wp弱共享p，p引用计数不变</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多态性</strong>：</p><ul><li>静态绑定：编译时把调用函数名与具体函数绑定到一起。通过函数重载和运算符重载实现。</li><li>动态绑定：运行时绑定。通过继承和虚函数实现。</li></ul></li><li><p><strong>运算符重载</strong>：</p><ul><li><p>类运算符重载形式（二元）</p><ul><li><p>非静态成员运算符重载：参数比实际参数少一个，第一个参数以this指针隐式传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex operator+(Complex b)&#123;……&#125;</span><br></pre></td></tr></table></figure></li><li><p>友元运算符重载：参数个数与实际运算的参数个数相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">friend Complex operator+(Complex a,Complex b);//声明</span><br><span class="line">Complex  operator+(Complex a,Complex b)&#123;……&#125;//定义</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一元运算符：作为类成员函数重载时不需要参数，通过this指针隐式传递</p><ul><li><p>前自增&#x2F;减 与 后自增&#x2F;减：通过在运算符函数参数表中是否插入关键字int 来区分这两种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//前缀</span><br><span class="line">operator -- ();</span><br><span class="line">operator -- (X &amp; x);</span><br><span class="line">//后缀</span><br><span class="line">operator -- (int);</span><br><span class="line">operator -- (X &amp; x, int);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重载赋值运算符”&#x3D;”：只能用成员函数重载</p></li><li><p>重载”[]”：</p><ul><li>是一个二元运算符，<code>X&amp; operator[](int n);</code></li><li>[]既可以出现在赋值符“&#x3D;”的左边，也可以出现在赋值符“&#x3D;”的右边，所以重载运算符[]时常返回引用。</li><li>[]只能被重载为类的非静态成员函数，不能被重载为友元和普通函数。</li></ul></li><li><p>重载”()”：只能被重载为类的成员函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X&amp; operator( )(参数表);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>模板</strong>：</p><ul><li><p>函数模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T1, class T2,…&gt;</span><br><span class="line">返回类型 函数名(参数表)&#123;</span><br><span class="line">   …… //函数模板定义体</span><br><span class="line">&#125;</span><br><span class="line">//T1,T1...是模板参数, class/typename表示其后参数可以是任意类型</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T min(T a, T b)&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>类模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1,class T2,…&gt;</span><br><span class="line">class 类名&#123;</span><br><span class="line">    ……// 类成员的声明与定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2023/06/21/markdown/"/>
      <url>/2023/06/21/markdown/</url>
      
        <content type="html"><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><ul><li>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</li></ul><hr><h4 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h4><ul><li><p><strong>换行</strong>：段落换行使用两个以上空格加上回车</p></li><li><p><strong>字体</strong>：</p></li></ul><p>​*斜体*</p><p>​_斜体_</p><p>​**粗体**</p><p>​**粗体**</p><p>​***粗斜体***</p><p>​___粗斜体___</p><ul><li><strong>分割线</strong>：</li></ul><p>​你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西</p><ul><li><strong>删除线</strong>：</li></ul><p>​如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可。</p><ul><li><strong>下划线</strong>：</li></ul><p>​下划线可以通过 HTML 的 <strong><u></strong> 标签来实现。例如：&lt;u&gt;文本&lt;&#x2F;u&gt;</p><hr><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li><strong>无序表</strong>：无序列表使用星号(<em>****)、加号(<strong>+</strong>)或是减号(</em>*-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</li><li><strong>有序表</strong>：使用数字并加上 <strong>.</strong> 号来表示</li><li><strong>列表嵌套</strong>：子列表中的选项前面添加两个或四个空格即可</li></ul><hr><h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><ul><li>区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号。另外区块是可以嵌套的，一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推。</li></ul><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><p>用 <strong>&#96;&#96;&#96;</strong> 包裹一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><ul><li>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><ul><li><strong>我们可以设置表格的对齐方式：</strong><ul><li><p><strong>-:</strong> 设置内容和标题栏居右对齐。</p></li><li><p><strong>:-</strong> 设置内容和标题栏居左对齐。</p></li><li><p><strong>:-:</strong> 设置内容和标题栏居中对齐。</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><hr><h4 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h4><ul><li><p><strong>转义</strong>：使用反斜杠转义特殊字符</p></li><li><p><strong>公式</strong>：使用 <a href="https://github.com/Khan/KaTeX">KaTeX</a> 或者 <a href="https://github.com/mathjax/MathJax">MathJax</a> 来渲染数学表达式。</p><ul><li><code>$...$</code> 或者 <code>\(...\)</code> 中的数学表达式将会在行内显示。</li><li><code>$$...$$</code> 或者 <code>\[...\]</code> 或者 &#96;&#96;&#96;&#96;math&#96; 中的数学表达式将会在块内显示。</li></ul></li><li><p><strong><a href="https://www.runoob.com/markdown/md-advance.html">流程图、时序图、甘特图</a></strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
