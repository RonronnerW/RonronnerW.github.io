<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>进程和线程 | RonronnerW</title><meta name="author" content="RonronnerW"><meta name="copyright" content="RonronnerW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程并行和并发 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行  进程控制块(PCB)Linux 内核的进程控制块是 task_struct 结构体:   进程i">
<meta property="og:type" content="article">
<meta property="og:title" content="进程和线程">
<meta property="og:url" content="http://example.com/2023/08/09/jin-cheng-he-xian-cheng/index.html">
<meta property="og:site_name" content="RonronnerW">
<meta property="og:description" content="进程并行和并发 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行  进程控制块(PCB)Linux 内核的进程控制块是 task_struct 结构体:   进程i">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-08-09T02:16:12.000Z">
<meta property="article:modified_time" content="2023-08-13T10:07:59.231Z">
<meta property="article:author" content="RonronnerW">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/09/jin-cheng-he-xian-cheng/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: RonronnerW","link":"链接: ","source":"来源: RonronnerW","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程和线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-08-13 18:07:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-poo"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="RonronnerW"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">RonronnerW</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-poo"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程和线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-09T02:16:12.000Z" title="发表于 2023-08-09 10:16:12">2023-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-13T10:07:59.231Z" title="更新于 2023-08-13 18:07:59">2023-08-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进程和线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul>
<li><code>并行(parallel)</code>：指在同一时刻，有多条指令在多个处理器上同时执行</li>
<li><code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</li>
</ul>
<h4 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h4><p>Linux 内核的进程控制块是 <code>task_struct</code> 结构体: </p>
<ul>
<li><p><strong>进程id</strong>：系统中每个进程有唯一的 id，用 <code>pid_t</code> 类型表示，其实就是一个非负整数</p>
</li>
<li><p><strong>进程的状态</strong>：有<code>就绪</code>、<code>运行</code>、<code>挂起</code>、<code>停止</code>等状态</p>
</li>
<li><p>进程切换时需要<strong>保存和恢复的一些CPU寄存器</strong></p>
</li>
<li><p>描述<strong>虚拟地址空间</strong>的信息</p>
</li>
<li><p>描述<strong>控制终端</strong>的信息</p>
</li>
</ul>
<h4 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h4><h5 id="查看进程-静态"><a href="#查看进程-静态" class="headerlink" title="查看进程-静态"></a>查看进程-静态</h5><ul>
<li><p><code>ps</code>命令用来查看进程（静态），可以使用<code>man ps</code>查看使用说明</p>
<ul>
<li><p>常用参数含义</p>
<ul>
<li>a：显示终端上的所有进程，包括其他用户的进程</li>
<li>u：显示进程的详细信息</li>
<li>x：显示没有控制终端的进程</li>
<li>j：列出与作业控制相关的信息</li>
</ul>
</li>
<li><p><code>ps -aux</code>或<code>ps aux</code></p>
<ul>
<li><p><code>TTY</code>：进程所属终端，在终端直接执行<code>tty</code>可查看当前<code>Terminal</code>所属终端</p>
</li>
<li><p><code>STAT</code>：进程状态</p>
<ul>
<li>D ：不可中断 Uninterruptible（usually IO）</li>
<li>R：正在运行，或在队列中的进程</li>
<li>S(大写) ：处于休眠状态</li>
<li>T：停止或被追踪</li>
<li>Z：僵尸进程</li>
<li>W：进入内存交换（从内核2.6开始无效）</li>
<li>X：死掉的进程</li>
<li>&lt;：高优先级</li>
<li>N：低优先级</li>
<li>s：包含子进程</li>
<li>+：位于前台的进程组</li>
</ul>
</li>
<li><p><code>COMMAND</code>：进程执行命令</p>
</li>
</ul>
</li>
<li><p><code>ps -ajx</code>或<code>ps ajx</code></p>
<ul>
<li><code>PPID</code>：该进程的父进程ID</li>
<li><code>PGID</code>：该进程所属组ID</li>
<li><code>SID</code>：该进程所属会话(session)ID，多个组构成会话</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="查看进程-动态"><a href="#查看进程-动态" class="headerlink" title="查看进程-动态"></a>查看进程-动态</h5><ul>
<li><p><code>top</code></p>
</li>
<li><p>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔</p>
</li>
<li><p>在 top 命令执行后，可以按以下按键对显示的结果进行排序</p>
<ul>
<li>M：根据内存使用量排序</li>
<li>P：根据 CPU 占有率排序</li>
<li>T：根据进程运行时间长短排序</li>
<li>U：根据用户名来筛选进程</li>
<li>K：输入指定的 PID 杀死进程</li>
</ul>
</li>
</ul>
<h5 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h5><ul>
<li><p><code>kill [-signal] pid</code></p>
</li>
<li><p><code>kill -l</code>：列出所有信号</p>
</li>
<li><p><code>kill -9 进程ID</code> 等价于<code>kill –SIGKILL 进程ID</code></p>
</li>
<li><p><code>killall name</code>：根据进程名杀死进程</p>
</li>
</ul>
<h4 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a>进程号和相关函数</h4><ul>
<li>每个进程都由进程号来标识，其类型为 <code>pid_t（整型）</code>，进程号的范围：<code>0～32767</code>。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用</li>
<li><strong>任何进程（除 init 进程）都是由另一个进程创建</strong>，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）</li>
<li><strong>进程组是一个或多个进程的集合</strong>。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号</li>
<li>进程号和进程组相关函数<ul>
<li><code>pid_t getpid(void);</code>：获取进程ID</li>
<li><code>pid_t getppid(void);</code>：获取进程的父进程ID</li>
<li><code>pid_t getpgid(pid_t pid);</code>：获取进程的组ID</li>
</ul>
</li>
</ul>
<h4 id="进程创建：fork"><a href="#进程创建：fork" class="headerlink" title="进程创建：fork"></a>进程创建：fork</h4><ul>
<li><p>可通过<code>man 2 fork</code>查看帮助</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">    pid_t fork(void);</span><br><span class="line">        函数的作用：用于创建子进程。</span><br><span class="line">        返回值：</span><br><span class="line">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span><br><span class="line">            在父进程中返回创建的子进程的ID,</span><br><span class="line">            在子进程中返回0</span><br><span class="line">            如何区分父进程和子进程：通过fork的返回值。</span><br><span class="line">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux 的 <code>fork()</code> 使用是通过<strong>写时拷贝 (copy- on-write) 实现</strong>。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让<strong>父子进程共享同一个地址空间</strong>，只有在<strong>需要写入的时候</strong>才会复制地址空间，从而使各个进程拥有各自的地址空间。即<strong>资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享</strong></p>
</li>
<li><p><strong>fork之后父子进程共享文件</strong>。fork产生的子进程与父进程<strong>有相同的文件描述符，指向相同的文件表</strong>，引用计数增加，共享文件偏移指针</p>
</li>
</ul>
<h4 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h4><ol>
<li><p>打断点及查看 <code>b 行号</code>，<code>i b</code></p>
</li>
<li><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，<strong>默认跟踪父进程</strong></p>
</li>
<li><p>查看当前跟踪的进程：<code>show follow-fork-mode</code></p>
</li>
<li><p>设置调试父进程或者子进程：<code>set follow-fork-mode [parent（默认）| child]</code></p>
</li>
<li><p>查看调试模式：<code>show detach-on-fork</code></p>
</li>
<li><p>设置调试模式：<code>set detach-on-fork [on | off]</code></p>
<ul>
<li>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起</li>
</ul>
</li>
<li><p>查看调试的进程：<code>info inferiors</code></p>
</li>
<li><p>切换当前调试的进程：<code>inferior Num</code></p>
</li>
<li><p>使进程脱离 GDB 调试：<code>detach inferiors Num</code></p>
</li>
</ol>
<h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><ul>
<li><p>可通过<code>man 3 exec</code>查看帮助，作用：<strong>在调用进程内部执行一个可执行文件</strong></p>
</li>
<li><p>基本组件为<code>exec</code>，后面跟不同参数，代表不同含义</p>
<ul>
<li><p><code>l(list) </code>：参数地址列表，以<strong>空指针结尾</strong></p>
</li>
<li><p><code>v(vector) </code>：存有各参数地址的指针数组的地址</p>
</li>
<li><p><code>p(path) </code>：按 PATH 环境变量指定的目录搜索可执行文件，可用<code>env</code>查看现有的环境变量</p>
</li>
<li><p><code>e(environment)</code>：存有环境变量字符串地址的指针数组的地址，增加新的环境变量</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">	path：需要指定的执行的文件的路径或者名称</span><br><span class="line">	arg：是执行可执行文件所需要的参数列表。第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称，从第二个参数开始往后，就是程序执行所需要的的参数列表，参数最后需要以NULL结束（哨兵）</span><br><span class="line">	</span><br><span class="line">int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line">	//会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功</span><br><span class="line">	file：只需要提供名称（不需要提供路径）</span><br><span class="line">	</span><br><span class="line">int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);</span><br><span class="line">	envp：添加路径至环境变量，注意以`NULL`结尾，否则报`execle: Bad address`</span><br><span class="line">		char* envp[] = &#123;&quot;/home/u/Desktop/Linux/&quot;, NULL&#125;;</span><br><span class="line">    	execle(&quot;/home/u/Desktop/Linux/hello&quot;, &quot;hello&quot;, NULL, envp);</span><br><span class="line"></span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">	argv：将运行参数都写在数组中</span><br><span class="line">	</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line"></span><br><span class="line">int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line"></span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure>



<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><ul>
<li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为<code>孤儿进程（Orphan Process）</code></li>
<li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。</li>
<li>孤儿进程并不会有什么危害</li>
</ul>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><ul>
<li><p>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放</p>
</li>
<li><p>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成<code>僵尸（Zombie）进程</code></p>
</li>
<li><p><strong>僵尸进程不能被 <code>kill -9</code> 杀死</strong>，这样就会导致一个问题，如果父进程不调用 <code>wait()</code> 或 <code>waitpid()</code> 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免</p>
</li>
</ul>
<h4 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h4><ul>
<li><p><code>wait()</code> 和 <code>waitpid()</code> 函数的功能一样，区别在于，<code>wait()</code> 函数会阻塞；<code>waitpid()</code> 可以设置是否阻塞，<code>waitpid()</code> 还可以指定等待哪个子进程结束</p>
</li>
<li><p>一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应使用循环</p>
</li>
<li><pre><code>pid_t wait(int *wstatus);//等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源
pid_t waitpid(pid_t pid, int *wstatus, int options);//回收指定进程号的子进程，可以设置是否阻塞
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 进程通信</span><br><span class="line"></span><br><span class="line">##### 管道</span><br><span class="line"></span><br><span class="line">- 管道其实是一个在**内核内存中维护的缓冲器**，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同</span><br><span class="line">- 管道拥有文件的特质：读操作、写操作</span><br><span class="line">  - **匿名管道**没有文件实体</span><br><span class="line">  - **有名管道**有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作</span><br><span class="line">- **一个管道是一个字节流**，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少</span><br><span class="line">- 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的</span><br><span class="line">- 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是**半双工**的</span><br><span class="line">- 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，**在管道中无法使用 lseek() 来随机的访问数据**</span><br><span class="line">- `匿名管道`只能在**具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用**</span><br><span class="line"></span><br><span class="line">###### 匿名管道</span><br><span class="line"></span><br><span class="line">`管道`也叫`无名（匿名）管道`，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制</span><br><span class="line"></span><br><span class="line">* 创建匿名管道</span><br><span class="line">  * `int pipe(int pipefd[2])`</span><br><span class="line">    - 功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">    - 参数：`int pipefd[2]` 这个数组是一个传出参数。</span><br><span class="line">      - `pipefd[0]` 对应的是管道的读端</span><br><span class="line">      - `pipefd[1]` 对应的是管道的写端</span><br><span class="line">    - 返回值：成功 0，失败 -1</span><br><span class="line">  * 注意</span><br><span class="line"></span><br><span class="line">    - 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line">    - 匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line"></span><br><span class="line">* 读管道</span><br><span class="line">  - 管道中有数据，read返回实际读到的字节数</span><br><span class="line">  - 管道中无数据</span><br><span class="line">    - 写端被全部关闭，read返回0（相当于读到文件的末尾）</span><br><span class="line">    - 写端没有完全关闭，read阻塞等待</span><br><span class="line"></span><br><span class="line">* 写管道</span><br><span class="line">  - 管道读端全部被关闭，进程异常终止（进程收到`SIGPIPE`信号）</span><br><span class="line">  - 管道读端没有全部关闭：</span><br><span class="line">    - 管道已满，write阻塞</span><br><span class="line">    - 管道没有满，write将数据写入，并返回实际写入的字节数</span><br><span class="line"></span><br><span class="line">###### 有名管道</span><br><span class="line"></span><br><span class="line">- 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了`有名管道（FIFO）`，也叫`命名管道`、`FIFO文件`</span><br><span class="line">- `有名管道（FIFO）`不同于匿名管道之处在于它**提供了一个路径名与之关联**，以 **FIFO 的文件形式存在于文件系统中**，并且其打开方式与打开一个普通文件是一样的，这样即使与 `FIFO` 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 `FIFO` 相互通信，因此，通过 `FIFO` 不相关的进程也能交换数据</span><br><span class="line">- 一旦打开了 `FIFO`，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如`read()`、`write()`和`close()`）。与管道一样，`FIFO` 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出</span><br><span class="line">- `有名管道（FIFO)`和`匿名管道（pipe）`有一些特点是相同的，不一样的地方在于</span><br><span class="line">  - `FIFO` 在文件系统中作为一个特殊文件存在，但 `FIFO` 中的**内容却存放在内存中**</span><br><span class="line">  - 当使用 `FIFO` 的进程退出后，`FIFO` 文件将继续保存在文件系统中以便以后使用</span><br><span class="line">  - `FIFO` 有名字，不相关的进程可以通过打开有名管道进行通信</span><br><span class="line"></span><br><span class="line">- 可使用`man fifo`查看帮助</span><br><span class="line"></span><br><span class="line">* 创建有名管道</span><br><span class="line">  * shell命令创建：`mkfifo 文件名`，可通过`man 1 mkfifo`查看帮助</span><br><span class="line">  * 函数创建：`int mkfifo(const char *pathname, mode_t mode);`，可通过`man 3 mkfifo`查看帮助</span><br><span class="line"></span><br><span class="line">##### 共享内存</span><br><span class="line"></span><br><span class="line">**共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）**。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 `IPC` 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用</span><br><span class="line"></span><br><span class="line">* 共享内存使用步骤</span><br><span class="line"></span><br><span class="line">  1. 调用 `shmget()` 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符</span><br><span class="line">  2. 使用 `shmat()`来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分</span><br><span class="line">  3. 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 `shmat()` 调用返回的 `addr` 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针</span><br><span class="line">  4. 调用 `shmdt()` 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步</span><br><span class="line">  5. 调用 `shmctl()` 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步</span><br><span class="line"></span><br><span class="line">* 共享内存操作函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
int shmget(key_t key, size_t size, int shmflg);
void *shmat(int shmid, const void *shmaddr, int shmflg);
int shmdt(const void *shmaddr);
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
key_t ftok(const char *pathname, int proj_id);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 共享内存操作命令</span><br><span class="line"></span><br><span class="line">  * ### ipcs </span><br><span class="line"></span><br><span class="line">    - `ipcs -a`：打印当前系统中**所有的**进程间通信方式的信息</span><br><span class="line">    - `ipcs -m`：打印出**使用共享内存**进行进程间通信的信息</span><br><span class="line">    - `ipcs -q`：打印出**使用消息队列**进行进程间通信的信息</span><br><span class="line">    - `ipcs -s`：打印出**使用信号**进行进程间通信的信息</span><br><span class="line"></span><br><span class="line">  * ### ipcrm</span><br><span class="line"></span><br><span class="line">    - `ipcrm -M shmkey`：移除用`shmkey`创建的**共享内存段**</span><br><span class="line">    - `ipcrm -m shmid`：移除用`shmid`标识的**共享内存段**</span><br><span class="line">    - `ipcrm -Q msgkey`：移除用`msqkey`创建的**消息队列**</span><br><span class="line">    - `ipcrm -q msqid`：移除用`msqid`标识的**消息队列**</span><br><span class="line">    - `ipcrm -S semkey`：移除用`semkey`创建的**信号**</span><br><span class="line">    - `ipcrm -s semid`：移除用`semid`标识的**信号**</span><br><span class="line"></span><br><span class="line">##### 信号</span><br><span class="line"></span><br><span class="line">- 可通过`man 7 signal`查看帮助</span><br><span class="line"></span><br><span class="line">- 信号的 5 中默认处理动作</span><br><span class="line"></span><br><span class="line">  - `Term`：终止进程</span><br><span class="line">  - `Ign`：当前进程忽略掉这个信号</span><br><span class="line">  - `Core`：终止进程，并生成一个Core文件</span><br><span class="line">  - `Stop`：暂停当前进程</span><br><span class="line">  - `Cont`：继续执行当前被暂停的进程</span><br><span class="line"></span><br><span class="line">- 信号的几种状态：`产生`、`未决`、`递达`</span><br><span class="line"></span><br><span class="line">- `SIGKILL` 和 `SIGSTOP` 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</span><br><span class="line"></span><br><span class="line">- 常用信号</span><br><span class="line"></span><br><span class="line">  | 编号 | 信号名称 | 对应事件                                       | 默认动作               |</span><br><span class="line">  | ---- | -------- | ---------------------------------------------- | ---------------------- |</span><br><span class="line">  | 2    | SIGINT   | 按下&lt;Ctrl +c&gt;组合键时用户终端向程序发出此信号  | 终止进程               |</span><br><span class="line">  | 3    | SIGQUIT  | 按下&lt;Ctrl +\\&gt;组合键时用户终端向程序发出此信号 | 终止进程               |</span><br><span class="line">  | 9    | SIGKILL  | 无条件终止进程。该信号不能被忽略、处理和阻塞   | 终止进程               |</span><br><span class="line">  | 11   | SIGSEGV  | 指示进程进行了无效内存访问（段错误）           | 终止进程并产生core文件 |</span><br><span class="line">  | 13   | SIGPIPE  | Broke pipe向一个没有读端的管道写数据           | 终止进程               |</span><br><span class="line">  | 17   | SIGCHLD  | 子进程结束时，父进程会收到这个信号             | 忽略这个信号           |</span><br><span class="line">  | 18   | SIGCONT  | 如果进程已停止，则使其继续运行                 | 继续/忽略              |</span><br><span class="line">  | 19   | SIGSTOP  | 停止进程的执行。不能被忽略、处理和阻塞         | 终止进程               |</span><br><span class="line"></span><br><span class="line">* 当进程异常终止时，会生成`core`文件（需要进行相应设置），可以通过`gdb`调试查看错误</span><br><span class="line"></span><br><span class="line">  * 生成调试`core`文件需要做以下几步</span><br><span class="line">    1. 使用`ulimit -a`查看资源上限</span><br><span class="line">    2. 修改`core size`：`ulimit -c core-size`</span><br><span class="line">    3. 在编译运行程序时加上`-g`选项使得能够被`gdb`调试，运行后生成`core`文件</span><br><span class="line">    4. 调试`core`程序：`gdb 可执行文件`进入`gdb`终端，使用`core-file core`可以查看`core`定位错误</span><br><span class="line"></span><br><span class="line">* 信号相关函数</span><br><span class="line"></span><br><span class="line">  * `int kill(pid_t pid, int sig);` 给**任何的进程或者进程组**`pid`，发送**任何的信号** `sig`</span><br><span class="line"></span><br><span class="line">  * `int raise(int sig);` 给**当前进程**发送信号</span><br><span class="line"></span><br><span class="line">  * `void abort(void);` 发送`SIGABRT`信号给当前的进程，**杀死当前进程**</span><br><span class="line"></span><br><span class="line">  * `unsigned int alarm(unsigned int seconds);` 设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：`SIGALARM`：默认终止**当前的进程**，每一个进程都有且只有唯一的一个定时器</span><br><span class="line"></span><br><span class="line">  * `int setitimer(int which, const struct itimerval *new_val, struct itimerval *old_value);`  设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line"></span><br><span class="line">  * `sighandler_t signal(int signum, sighandler_t handler);` 设置某个信号的捕捉行为</span><br><span class="line"></span><br><span class="line">  * `int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);` 检查或者改变信号的处理，即信号捕捉</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">* 信号集</span><br><span class="line"></span><br><span class="line">  * 使用`man 3 sigset`查看帮助</span><br><span class="line">  * 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 `sigset_t`</span><br><span class="line">  * 在 PCB 中有两个非常重要的信号集。一个称之为 `阻塞信号集` ，另一个称之为`未决信号集`。这两个信号集都是**内核使用位图机制来实现**的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改</span><br><span class="line">  * 信号的 `未决` 是一种状态，指的是**从信号的产生到信号被处理前的这一段时间**</span><br><span class="line">  * 信号的 `阻塞` 是一个开关动作，指的是**阻止信号被处理，但不是阻止信号产生**。信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作</span><br><span class="line">  * 操作自定义信号集函数</span><br><span class="line">    * 使用`man 3 sigemptyset`查看帮助</span><br><span class="line">    * `int sigemptyset(sigset_t *set);`功能：清空信号集中的数据，将信号集中的所有的标志位置为0</span><br><span class="line">    * `int sigfillset(sigset_t *set);`将信号集中的所有的标志位置为1</span><br><span class="line">    * `int sigaddset(sigset_t *set, int signum);`设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="line">    * `int sigdelset(sigset_t *set, int signum);`设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="line">    * `int sigismember(const sigset_t *set, int signum);`判断某个信号是否阻塞</span><br><span class="line"></span><br><span class="line">  * 操作内核信号集函数</span><br><span class="line">    * `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">    * `int sigpending(sigset_t *set);`获取内核中的未决信号集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 线程</span><br><span class="line"></span><br><span class="line">- 与`进程（process）`类似，`线程（thread）`是允许应用程序**并发执行多个任务**的一种机制</span><br><span class="line">- 一个进程可以包含多个线程</span><br><span class="line"></span><br><span class="line">* **进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位**</span><br><span class="line"></span><br><span class="line">#### 进程和线程区别</span><br><span class="line"></span><br><span class="line">- **进程间的信息难以共享**。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换</span><br><span class="line">- 调用 `fork()` 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 `fork()` 调用在时间上的开销依然不菲</span><br><span class="line">- 线程之间能够方便、快速地共享信息。只需**将数据复制到共享（全局或堆）变量**中即可</span><br><span class="line">- 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</span><br><span class="line"></span><br><span class="line">#### 线程之间共享和非共享资源</span><br><span class="line"></span><br><span class="line">##### 共享资源</span><br><span class="line"></span><br><span class="line">- 进程 ID 和父进程 ID</span><br><span class="line">- 进程组 ID 和会话 ID</span><br><span class="line">- 用户 ID 和 用户组 ID</span><br><span class="line">- 文件描述符表</span><br><span class="line">- 信号处置</span><br><span class="line">- 文件系统的相关信息：文件权限掩码（`umask`）、当前工作目录</span><br><span class="line">- 虚拟地址空间（**除栈、.text**）</span><br><span class="line"></span><br><span class="line">##### 非共享资源</span><br><span class="line"></span><br><span class="line">- 线程 ID</span><br><span class="line">- 信号掩码</span><br><span class="line">- 线程特有数据</span><br><span class="line">- error 变量</span><br><span class="line">- 实时调度策略和优先级</span><br><span class="line">- 栈，本地变量和函数的调用链接信息</span><br><span class="line"></span><br><span class="line">#### 线程操作函数</span><br><span class="line"></span><br><span class="line">由于`pthread`属于第三方库，所以在编译时需要加上参数`-pthread`或`-lpthread`即指定包路径，如果不加报以下错误</span><br><span class="line"></span><br><span class="line">- 获取当前的线程的线程ID：`pthread_t pthread_self(void);`</span><br><span class="line"></span><br><span class="line">- 比较两个线程ID是否相等：`int pthread_equal(pthread_t t1, pthread_t t2);`</span><br><span class="line"></span><br><span class="line">  &gt; 不同的操作系统，`pthread_t`类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的</span><br><span class="line"></span><br><span class="line">- 线程创建：``int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);``</span><br><span class="line"></span><br></pre></td></tr></table></figure>
- `thread`：传出参数，线程创建成功后，子线程的线程ID被写到该变量中
- `attr` : 设置线程的属性，一般使用默认值，NULL
- `start_routine` : 函数指针，这个函数是子线程需要处理的逻辑代码
- `arg` : 给第三个参数(`start_routine`)使用，传参
</code></pre>
</li>
</ul>
<ul>
<li><p>线程终止：<code>void pthread_exit(void *retval);</code></p>
</li>
<li><p>线程连接：<code>int pthread_join(pthread_t thread, void **retval);</code>，和一个已经终止的线程进行连接。回收子线程的资源，这个函数是阻塞函数，调用一次只能回收一个子线程，一般在主线程中使用</p>
</li>
<li><p>线程分离：<code>int pthread_detach(pthread_t thread);</code>，分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统</p>
</li>
<li><p>线程取消：<code>int pthread_cancel(pthread_t thread);</code></p>
</li>
</ul>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul>
<li><code>临界区</code>是指访问某一共享资源的代码片段，并且这段代码的执行应为<code>原子操作</code>，也就是同时访问同一共享资源的其他线程不应终端该片段的执行</li>
<li><code>线程同步</code>：即<strong>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态</strong></li>
</ul>
<h5 id="互斥量-互斥锁"><a href="#互斥量-互斥锁" class="headerlink" title="互斥量(互斥锁)"></a>互斥量(互斥锁)</h5><p><strong>互斥量能保证对任意共享资源的原子访问</strong>。任何时候，<strong>至多只有一个线程可以锁定该互斥量</strong>。</p>
<h6 id="相关操作函数"><a href="#相关操作函数" class="headerlink" title="相关操作函数"></a>相关操作函数</h6><ul>
<li><p>互斥量的类型：<code>pthread_mutex_t</code></p>
</li>
<li><p>初始化互斥量：<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></p>
<ul>
<li>参数<ul>
<li><code>mutex</code> ： 需要初始化的互斥量变量</li>
<li><code>attr</code> ： 互斥量相关的属性，设置为NULL，由内核指定</li>
</ul>
</li>
<li><code>restrict</code> : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作</li>
</ul>
</li>
<li><p>释放互斥量的资源：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
</li>
<li><p>加锁：<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p>
</li>
<li><p>尝试加锁：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p>
</li>
<li><p>解锁：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p>
</li>
</ul>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><ul>
<li>产生死锁的几种场景：<ul>
<li>忘记释放锁</li>
<li>重复加锁</li>
<li>多线程多锁，抢占锁资源</li>
</ul>
</li>
</ul>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul>
<li><p>读写锁的特点</p>
<ul>
<li><p>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</p>
</li>
<li><p>如果有其它线程写数据，则其它线程都不允许读、写操作</p>
</li>
<li><p>写是独占的，写的优先级高</p>
</li>
</ul>
</li>
<li><p>相关操作函数</p>
<ul>
<li><p>读写锁的类型：<code>pthread_rwlock_t</code></p>
</li>
<li><p>初始化读写锁：<code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></p>
</li>
<li><p>释放互斥量的资源：<code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>读操作加锁：<code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>读操作尝试加锁：<code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>写操作加锁：<code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>写操作尝试加锁：<code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>解锁：<code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><ul>
<li>相关操作函数<ul>
<li>条件变量的类型：<code>pthread_cond_t</code></li>
<li>初始化：<code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></li>
<li>回收：<code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li>
<li>等待，调用了该函数，线程会阻塞：<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></li>
<li>等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束：<code>int pthread_cond_timedwait(pthread_cond_t *restrict cond,  pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></li>
<li>唤醒一个或者多个等待的线程：<code>int pthread_cond_signal(pthread_cond_t *cond);</code></li>
<li>唤醒所有的等待的线程：<code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li>
</ul>
</li>
</ul>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><ul>
<li>相关操作函数<ul>
<li>信号量的类型：<code>sem_t</code></li>
<li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code><ul>
<li>功能：初始化信号量</li>
<li>参数<ul>
<li><code>sem</code>：信号量变量的地址</li>
<li><code>pshared</code>：0 用在线程间 ，非0 用在进程间</li>
<li><code>value </code>：信号量中的值，代表容器大小</li>
</ul>
</li>
</ul>
</li>
<li><code>int sem_destroy(sem_t *sem);</code><ul>
<li>功能：释放资源</li>
</ul>
</li>
<li><code>int sem_wait(sem_t *sem);</code><ul>
<li>功能：对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</li>
</ul>
</li>
<li><code>int sem_trywait(sem_t *sem);</code></li>
<li><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></li>
<li><code>int sem_post(sem_t *sem);</code><ul>
<li>功能：对信号量解锁，调用一次对信号量的值+1</li>
</ul>
</li>
<li><code>int sem_getvalue(sem_t *sem, int *sval);</code></li>
</ul>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/22/shi-wu-yu-bing-fa/" title="事务与并发"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">事务与并发</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/20/fen-bu-shi-xi-tong-yu-shi-xu-shu-ju-ku/" title="分布式系统与时序数据库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式系统与时序数据库</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RonronnerW</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RonronnerW"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RonronnerW" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/wlbin_1019@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/2568998391" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">1.0.1.</span> <span class="toc-text">并行和并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-PCB"><span class="toc-number">1.0.2.</span> <span class="toc-text">进程控制块(PCB)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.0.3.</span> <span class="toc-text">进程相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-%E9%9D%99%E6%80%81"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">查看进程-静态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">查看进程-动态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">杀死进程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.4.</span> <span class="toc-text">进程号和相关函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%EF%BC%9Afork"><span class="toc-number">1.0.5.</span> <span class="toc-text">进程创建：fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GDB%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="toc-number">1.0.6.</span> <span class="toc-text">GDB多进程调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">1.0.7.</span> <span class="toc-text">exec函数族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.8.</span> <span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.9.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-number">1.0.10.</span> <span class="toc-text">进程回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.0.11.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.0.11.1.</span> <span class="toc-text">互斥量(互斥锁)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.1.1.</span> <span class="toc-text">相关操作函数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.0.11.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.0.11.3.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.11.4.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.0.11.5.</span> <span class="toc-text">信号量</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/26/spring-cloud-alibaba/" title="无题">无题</a><time datetime="2023-10-26T12:05:40.516Z" title="发表于 2023-10-26 20:05:40">2023-10-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/26/springboot3/" title="无题">无题</a><time datetime="2023-10-26T00:37:20.536Z" title="发表于 2023-10-26 08:37:20">2023-10-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/25/mybatis/" title="无题">无题</a><time datetime="2023-10-25T02:04:57.741Z" title="发表于 2023-10-25 10:04:57">2023-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/24/springmvc/" title="无题">无题</a><time datetime="2023-10-24T06:25:50.196Z" title="发表于 2023-10-24 14:25:50">2023-10-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By RonronnerW</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2023/08/09/jin-cheng-he-xian-cheng/'
    this.page.identifier = '/2023/08/09/jin-cheng-he-xian-cheng/'
    this.page.title = '进程和线程'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>