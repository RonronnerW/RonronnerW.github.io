<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java | RonronnerW</title><meta name="author" content="RonronnerW"><meta name="copyright" content="RonronnerW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IDEA常用快捷键 删除行(delete line)：ctrl+d  复制行(duplicate)：ctrl+alt+向下箭头  补全：alt+&#x2F;  注释：ctrl+&#x2F;  导入该行需要的类：先配置Auto import, alt+enter  快速格式化代码：ctrl+alt+L  快速运行代码(run)：ctrl+R  生成代码：alt+insert  查看类的层级关系：ctrl+H  定位方法">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://example.com/2023/09/14/java/index.html">
<meta property="og:site_name" content="RonronnerW">
<meta property="og:description" content="IDEA常用快捷键 删除行(delete line)：ctrl+d  复制行(duplicate)：ctrl+alt+向下箭头  补全：alt+&#x2F;  注释：ctrl+&#x2F;  导入该行需要的类：先配置Auto import, alt+enter  快速格式化代码：ctrl+alt+L  快速运行代码(run)：ctrl+R  生成代码：alt+insert  查看类的层级关系：ctrl+H  定位方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-09-14T11:43:07.000Z">
<meta property="article:modified_time" content="2023-10-27T11:59:46.843Z">
<meta property="article:author" content="RonronnerW">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/09/14/java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: RonronnerW","link":"链接: ","source":"来源: RonronnerW","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-10-27 19:59:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-poo"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="RonronnerW"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">RonronnerW</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-poo"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-14T11:43:07.000Z" title="发表于 2023-09-14 19:43:07">2023-09-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-27T11:59:46.843Z" title="更新于 2023-10-27 19:59:46">2023-10-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><ul>
<li><p>删除行(delete line)：<code>ctrl</code>+<code>d</code></p>
</li>
<li><p>复制行(duplicate)：<code>ctrl</code>+<code>alt</code>+向下箭头</p>
</li>
<li><p>补全：<code>alt</code>+<code>/</code></p>
</li>
<li><p>注释：<code>ctrl</code>+<code>/</code></p>
</li>
<li><p>导入该行需要的类：先配置<code>Auto import</code>, <code>alt</code>+<code>enter</code></p>
</li>
<li><p>快速格式化代码：<code>ctrl</code>+<code>alt</code>+<code>L</code></p>
</li>
<li><p>快速运行代码(run)：<code>ctrl</code>+<code>R</code></p>
</li>
<li><p>生成代码：<code>alt</code>+<code>insert</code></p>
</li>
<li><p>查看类的层级关系：<code>ctrl</code>+<code>H</code></p>
</li>
<li><p>定位方法：<code>ctrl</code>+<code>B</code></p>
</li>
<li><p>自动创建变量名：通过在后面加<code>.var</code></p>
</li>
<li><p>模板：file-&gt;settings-&gt;editor-&gt;Live templates-&gt;查看模板快捷键和增加自己的模板</p>
</li>
</ul>
<h3 id="JAVA开发注意事项和细节"><a href="#JAVA开发注意事项和细节" class="headerlink" title="JAVA开发注意事项和细节"></a>JAVA开发注意事项和细节</h3><ul>
<li><p>执行入口是<code>main()</code>方法</p>
<p><code>public static void main(String[] args)&#123;...&#125;</code></p>
</li>
<li><p>一个源文件中最多只能有一个public类，其他类个数不限。也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。</p>
</li>
<li><p>如果源文件包含一个public类，则文件名必须按该类命名</p>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><p>单行注释：&#x2F;&#x2F;</p>
</li>
<li><p>多行注释：&#x2F;*    *&#x2F;，不允许多行注释嵌套</p>
</li>
<li><p>文档注释：<code>javadoc -d 文件夹名 -xx -yy file.java</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @author xx</span><br><span class="line">  * @version yy</span><br><span class="line">  */</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>标签</strong></th>
<th align="center"><strong>描述</strong></th>
<th align="center"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">@author</td>
<td align="center">标识一个类的作者</td>
<td align="center">@author description</td>
</tr>
<tr>
<td align="left">@deprecated</td>
<td align="center">指名一个过期的类或成员</td>
<td align="center">@deprecated description</td>
</tr>
<tr>
<td align="left">{@docRoot}</td>
<td align="center">指明当前文档根目录的路径</td>
<td align="center">Directory Path</td>
</tr>
<tr>
<td align="left">@exception</td>
<td align="center">标志一个类抛出的异常</td>
<td align="center">@exception exception-name explanation</td>
</tr>
<tr>
<td align="left">{@inheritDoc}</td>
<td align="center">从直接父类继承的注释</td>
<td align="center">Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td align="left">{@link}</td>
<td align="center">插入一个到另一个主题的链接</td>
<td align="center">{@link name text}</td>
</tr>
<tr>
<td align="left">{@linkplain}</td>
<td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td align="center">Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td align="left">@param</td>
<td align="center">说明一个方法的参数</td>
<td align="center">@param parameter-name explanation</td>
</tr>
<tr>
<td align="left">@return</td>
<td align="center">说明返回值类型</td>
<td align="center">@return explanation</td>
</tr>
<tr>
<td align="left">@see</td>
<td align="center">指定一个到另一个主题的链接</td>
<td align="center">@see anchor</td>
</tr>
<tr>
<td align="left">@serial</td>
<td align="center">说明一个序列化属性</td>
<td align="center">@serial description</td>
</tr>
<tr>
<td align="left">@serialData</td>
<td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td align="center">@serialData description</td>
</tr>
<tr>
<td align="left">@serialField</td>
<td align="center">说明一个ObjectStreamField组件</td>
<td align="center">@serialField name type description</td>
</tr>
<tr>
<td align="left">@since</td>
<td align="center">标记当引入一个特定的变化时</td>
<td align="center">@since release</td>
</tr>
<tr>
<td align="left">@throws</td>
<td align="center">和 @exception标签一样.</td>
<td align="center">The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td align="left">{@value}</td>
<td align="center">显示常量的值，该常量必须是static属性。</td>
<td align="center">Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td align="left">@version</td>
<td align="center">指定类的版本</td>
<td align="center">@version info</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul>
<li><p>整数类型：byte[1], short[2], int[4], long[8]。long类型后面要声明<code>l</code>或<code>L</code> </p>
</li>
<li><p>浮点类型：float[4], double[8]。默认double，float要加声明<code>l</code>或<code>L</code></p>
</li>
<li><p>字符类型：char[2]</p>
</li>
<li><p>布尔类型：boolean[1]</p>
</li>
</ul>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul>
<li><p>类(class)</p>
</li>
<li><p>接口(interface)</p>
</li>
<li><p>数组([])</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义：数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[大小]</span><br><span class="line">	 数据类型 数组名[] = <span class="keyword">new</span> 数据类型[大小]</span><br><span class="line">	 数据类型[][] 数组名 = <span class="keyword">new</span> 数据类型[大小][大小]</span><br><span class="line">	 </span><br><span class="line">数组默认情况下是引用传递，赋的值是地址</span><br><span class="line">数组拷贝：先开辟新空间，然后逐一拷贝元素</span><br><span class="line">数组扩容：定义一个更大的数组，然后使用引用传递（数组直接赋值）</span><br><span class="line"></span><br><span class="line">二维数组:多个一维数组组成，一维数组大小不要求相同</span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li><p>自动类型转换</p>
<ul>
<li><p>精度小的类型自动转换为精度大的类型</p>
</li>
<li><p>byte、short不能与char相互自动转换</p>
</li>
<li><p>byte, short, char三者之间可以计算，在计算时首先转换为int类型</p>
</li>
<li><p>boolean类型不参与自动转换</p>
</li>
</ul>
</li>
<li><p>强制类型转换: 使用强制转换符<code>()</code></p>
<ul>
<li>强制符号只针对最近的操作数有效，可以使用小括号提升优先级</li>
</ul>
</li>
<li><p>基本数据类型和字符串之间转换</p>
<ul>
<li><p>基本数据类型-&gt;字符串：基本数据类型 + “”</p>
</li>
<li><p>字符串-&gt;基本数据类型：通过基本数据类型的包装类调用parseXXX方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = Integer.parseInt(s);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>取模：本质：a%b &#x3D; a - a &#x2F; b * b</p>
<p>a为小数，则：a%b &#x3D; a - (int)a &#x2F; b * b</p>
</li>
<li><p>短路与(&amp;&amp;)和逻辑与(&amp;)：短路与第一个为false，第二个不判断；逻辑与不管第一个如何都要判断第二个条件</p>
</li>
<li><p>短路或(||)和逻辑或(|)：短路或第一个为true，第二个不判断；逻辑或不管第一个如何都要判断第二个条件</p>
</li>
<li><p>符合赋值运算会进行类型转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 2;</span><br><span class="line">b+=2; //等价于b = (byte)(b + 2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="键盘键入"><a href="#键盘键入" class="headerlink" title="键盘键入"></a>键盘键入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Scanner类所在的包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScaner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//使用相关方法接收输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> myScanner.next();</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> myScanner.nextInt();</span><br></pre></td></tr></table></figure>



<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><ul>
<li>二进制：以<code>0b</code>或<code>0B</code>开头</li>
<li>八进制：以<code>0</code>开头</li>
<li>十六进制：以<code>0x</code>或<code>0X</code>开头</li>
</ul>
<h3 id="JAVA内存结构分析"><a href="#JAVA内存结构分析" class="headerlink" title="JAVA内存结构分析"></a>JAVA内存结构分析</h3><p>创建对象过程：</p>
<ol>
<li>加载类信息（属性和方法，只会加载一次）</li>
<li>堆中分配空间，进行默认初始化，返回地址</li>
<li>指定初始化</li>
</ol>
<ul>
<li>栈：一般存放基本数据类型（局部变量）</li>
<li>堆：存放对象（对象、数组等）</li>
<li>方法区：常量池（常量，比如字符串）、类加载信息</li>
</ul>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li><p>java中允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。通过可变参数实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回类型 方法名（数据类型... 形参名）&#123;&#125;</span><br><span class="line">public int sum(int... nums)&#123;&#125;//nums当作数组使用</span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数实参可以是数组，可变参数的本质就是数组</p>
</li>
<li><p>可变参数可以和普通类型的参数一起放在形参列表，但必须保证<strong>可变参数在最后</strong></p>
</li>
<li><p>一个形参列表<strong>只能出现一个</strong>可变参数</p>
</li>
</ul>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 方法名（形参列表）&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器没有返回值</li>
<li>方法名和类名一样</li>
<li>构造器的调用系统自动完成</li>
<li>没有定义构造器，系统自动给类生成一个默认无参构造器；一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显示的定义一下。</li>
</ul>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ul>
<li>调用本类构造器：<code>this(参数列表)</code>，只能在构造器中使用且必须放在第一条语句</li>
<li>在类定义的方法中用来访问类属性</li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul>
<li><p>作用：区分相同名字的类；管理类；控制访问范围</p>
</li>
<li><p>基本语法：<code>package 包名;</code></p>
</li>
<li><p>命名规范：一般小写。一般<code>com.公司名.项目名.业务模块</code></p>
</li>
</ul>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><table>
<thead>
<tr>
<th>访问级别</th>
<th>修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>不同包</th>
</tr>
</thead>
<tbody><tr>
<td>公开</td>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>默认</td>
<td></td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ul>
<li>修饰符可以用来修饰属性，成员方法和类</li>
<li>只有默认和<code>public</code>才能修饰类</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>隐藏细节，对数据进行验证以保证合理合法性</p>
<p>封装实现步骤：1.属性私有化；2.提供一个公共的set方法对属性进行判断和赋值；3.提供一个公共的get方法获取属性</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子类继承了所有属性和方法，但是私有属性和方法不能在子类直接访问，要通过父类公共的方法</p>
</li>
<li><p>子类必须调用父类的构造器完成父类的初始化</p>
</li>
<li><p>当创建子类的对象时，默认总会区调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super(参数列表);</code>去指定使用父类的哪个构造器完成父类的初始化工作，否则编译不会通过。</p>
</li>
<li><p><code>super()</code>使用时必须放在构造器第一行</p>
</li>
<li><p><code>super()</code>和<code>this()</code>都只能放在构造器第一行，因此不能共存在一个构造器</p>
</li>
<li><p>所有类都是<code>Object</code>类的子类</p>
</li>
<li><p>子类只能继承一个父类，即单继承机制</p>
</li>
</ul>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super代表父类的引用，用于访问父类的属性、方法、构造器。</p>
<p>就近原则，如果父类没有则往上查找。</p>
<ul>
<li>访问父类的属性，但不能访问父类的私有属性 </li>
<li>访问父类的方法，但不能访问父类的私有方法</li>
<li>访问父类的构造器，只能放在构造器第一句 <code>super(参数列表)</code></li>
</ul>
<table>
<thead>
<tr>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>访问属性</td>
<td>访问本类中属性，如果没有从父类中继续查找</td>
<td>从父类开始查找属性</td>
</tr>
<tr>
<td>调用方法</td>
<td>访问本类中方法，如果没有从父类中继续查找</td>
<td>从父类开始查找方法</td>
</tr>
<tr>
<td>调用构造器</td>
<td>调用本类构造器，必须放在首行</td>
<td>调用父类构造器，必须放在首行</td>
</tr>
<tr>
<td>特殊</td>
<td>表示当前对象</td>
<td>子类中访问父类对象</td>
</tr>
</tbody></table>
<h3 id="方法重写-x2F-覆盖"><a href="#方法重写-x2F-覆盖" class="headerlink" title="方法重写&#x2F;覆盖"></a>方法重写&#x2F;覆盖</h3><ul>
<li>子类的方法的参数，方法名称必须和父类一样</li>
<li>子类方法的返回类型和父类一样，或者是父类返回类型的子类，例如<code>public Object getInfo()&#123;&#125;</code>和<code>public String getInfo()&#123;&#125;</code></li>
<li>子类方法不能缩小父类方法的访问权限</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>发生范围</th>
<th>方法名</th>
<th>参数列表</th>
<th>返回类型</th>
<th>修饰符</th>
</tr>
</thead>
<tbody><tr>
<td>重载(overload)</td>
<td>本类</td>
<td>相同</td>
<td>不同</td>
<td>无要求</td>
<td>无要求</td>
</tr>
<tr>
<td>重写(override)</td>
<td>父子类</td>
<td>相同</td>
<td>相同</td>
<td>返回类型和父类一致，或者是其子类</td>
<td>不能缩小父类方法的访问范围</td>
</tr>
</tbody></table>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>重载和重写</li>
<li>对象的多态<ul>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时就确定了，不能改变</li>
<li>运行类型是可以变化的</li>
<li>编译类型看定义时<code>=</code>左边，运行类型看<code>=</code>右边</li>
</ul>
</li>
<li>多态的前提是：两个对象存在继承关系</li>
<li>多态的向上转型<ul>
<li>本质：父类的引用指向子类对象</li>
<li>语法：<code>父类 引用名 = new 子类();</code></li>
<li>可以调用父类的所有成员（需要遵守访问权限）；不能调用子类中的特有成员；最终运行效果看子类的具体实现</li>
</ul>
</li>
<li>向下转型<ul>
<li>语法：<code>子类 引用名 = (子类类型) 父类引用</code></li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类对象的引用必须指向当前目标类型的对象</li>
<li>可以调用子类类型中的所有成员</li>
</ul>
</li>
</ul>
<h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h4><ul>
<li>当调用对象方法时，该方法会和该对象的<strong>内存地址&#x2F;运行类型</strong>绑定</li>
<li>当调用对象属性时，<strong>没有动态绑定机制</strong>，哪里声明哪里使用</li>
</ul>
<h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><ul>
<li><p>数组的定义类型为父类，保存的实际类型是子类</p>
</li>
<li><p>调用子类特有的方法时，先用<code>instanceof</code>判断，再向下转型</p>
</li>
</ul>
<h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><ul>
<li>方法定义的形参为父类类型，实参允许为子类类型</li>
</ul>
<h3 id="x3D-x3D-运算符"><a href="#x3D-x3D-运算符" class="headerlink" title="&#x3D;&#x3D;运算符"></a>&#x3D;&#x3D;运算符</h3><ul>
<li>既可以判断基本类型，又可以判断引用类型</li>
<li>判断基本类型，判断的是值是否相等；判断引用类型，判断的是地址是否相等</li>
<li>只要有基本数据类型，则判断的是值是否相等</li>
</ul>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><ul>
<li>equals是Object类中的方法，只能判断引用类型</li>
</ul>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="类变量-x2F-静态变量"><a href="#类变量-x2F-静态变量" class="headerlink" title="类变量&#x2F;静态变量"></a>类变量&#x2F;静态变量</h4><ul>
<li><p>定义：<code>修饰符 static 数据类型 变量名;</code>或<code>static 修饰符 数据类型 变量名;</code></p>
</li>
<li><p>访问：<code>类名.变量名;</code>或<code>对象名.变量名</code></p>
</li>
<li><p><code>static</code>变量被对象所共享，在<strong>类加载的时候就生成</strong></p>
</li>
<li><p>静态变量保存再class实例的尾部，而class对象<strong>保存在堆中</strong></p>
</li>
<li><p>生命周期为类加载到类消亡</p>
</li>
</ul>
<h4 id="类方法-x2F-静态方法"><a href="#类方法-x2F-静态方法" class="headerlink" title="类方法&#x2F;静态方法"></a>类方法&#x2F;静态方法</h4><p>当方法中不涉及任何对象相关的成员或一些通用的方法，可以设计成静态方法提高开发效率</p>
<ul>
<li><p>定义：<code>修饰符 static 返回类型 方法名()&#123;&#125;</code></p>
</li>
<li><p>访问：<code>类名.方法名;</code></p>
</li>
<li><p>类方法和普通方法都随着类加载而加载，将结构信息存储到方法区</p>
</li>
<li><p>类方法中<strong>不允许使用和对象有关的关键字</strong>，如<code>this</code>和<code>super</code></p>
</li>
<li><p><strong>静态方法只能访问静态变量或静态方法</strong></p>
</li>
</ul>
<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><ul>
<li>main方法是虚拟机调用，访问权限必须是public</li>
<li>执行main方法时不必创建对象，所以必须是static</li>
<li>接收String类型的数组形参，保存运行时传递的参数</li>
<li>main方法中可以直接使用所在类的静态属性和静态方法；访问非静态成员，必须创建对象去调用</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块又叫初始化块，在加载类或创建对象时隐式调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">	代码</span><br><span class="line">&#125;; //;可以省略</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修饰符只能选<code>static</code>，分别称为静态代码块和普通代码块。<strong>静态代码块随类的加载而执行，只执行一次，而普通代码块每创建对象都会执行</strong></p>
</li>
<li><p>静态代码块只能调用静态成员，普通代码块可以调用任意成员</p>
</li>
<li><p>好处：</p>
<ul>
<li>相当于另一种形式的构造器，可以做初始化操作，代码块的<strong>调用优先于构造器</strong></li>
<li>如果多个构造器中都有重复语句，可以抽取到代码块中，提高复用性</li>
</ul>
</li>
</ul>
<p><strong>类什么时候加载？</strong></p>
<ul>
<li>创建对象实例（new)</li>
<li>创建子类对象实例，父类也会被加载</li>
<li>使用类的静态成员时</li>
</ul>
<p><strong>创建一个对象时，在一个类调用顺序</strong></p>
<ol>
<li>调用静态代码块和静态属性初始化（多个则按照定义顺序）</li>
<li>普通代码块和普通属性初始化</li>
<li>调用构造方法。构造器的最前面其实隐藏了<code>super()</code>和调用普通代码块</li>
</ol>
<p><strong>创建一个子类对象时，调用顺序</strong></p>
<ol>
<li>父类的静态代码块和静态属性</li>
<li>子类的静态代码块和静态属性</li>
<li>父类的普通代码块和普通属性初始化</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化</li>
<li>子类的构造方法</li>
</ol>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li><p>使用场景</p>
<ul>
<li>不希望类被继承 <code>final class 类名</code></li>
<li>不希望父类的某个方法被子类覆盖&#x2F;重写时 <code>修饰符 final 返回类型 方法名</code></li>
<li>不希望类的某个属性被修改 <code>修饰符 final 类型 变量名</code> </li>
<li>不希望某个局部变量被修改 <code>final 变量名</code></li>
</ul>
</li>
<li><p>final修饰的属性一般为常量，一般用<code>XX_XX</code>来命名</p>
</li>
<li><p>修饰的属性必须赋初值，以后不能修改，初始化位置：</p>
<ol>
<li>定义时</li>
<li>在构造器中</li>
<li>在代码块中</li>
</ol>
</li>
<li><p>修饰静态属性时，初始化位置：</p>
<ol>
<li>定义时</li>
<li>静态代码块</li>
</ol>
</li>
<li><p>类不是final类，但含有final方法，则该方法不能重写，但是可以被继承</p>
</li>
<li><p>final不能修饰构造器</p>
</li>
<li><p>final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理</p>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>某些方法不确定实现时可以声明为抽象方法让子类来实现，含抽象方法的类称为抽象类</p>
<p>声明为抽象方法：<code>public abstract void eat();</code> <strong>没有方法体</strong>，此时类也必须声明为<code>abstract</code>类</p>
<ul>
<li><p>抽象类不能被实例化</p>
</li>
<li><p>抽象类不一定要包含<code>abstract</code>方法，一旦包含<code>abstract</code>方法就必须声明为抽象类</p>
</li>
<li><p><code>abstract</code>只能用于声明类和方法</p>
</li>
<li><p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类</p>
</li>
<li><p>抽象方法不能用<code>private</code>, <code>final</code>, <code>static</code>来修饰，因为这些关键字于重写相违背。静态方法可以被子类继承，但不能被重写</p>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法实现出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">	//属性</span><br><span class="line">	//方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">	//自己属性</span><br><span class="line">	//自己方法</span><br><span class="line">	//必须实现的接口的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>JDK7.0</code>之前 接口里的所有方法都没有方法体，即都是抽象方法；<code>JDK8.0</code>后接口可以有静态方法（加<code>static</code>），默认方法（加<code>default</code>关键字修饰），也就是说接口中可以有方法的具体实现</li>
<li>接口不能被实例化</li>
<li>接口中所有方法都是public方法，接口中抽象方法可以不用abstract修饰</li>
<li>一个普通类实现接口就必须将该接口的所有方法都实现</li>
<li>抽象类实现接口可以不用实现接口的方法</li>
<li>一个类可以同时实现多个接口</li>
<li>接口中的属性只能是final的，而且是<code>public static final</code>修饰，通过<code>接口名.属性</code>访问</li>
<li>接口不能继承类，但可以继承别的接口</li>
<li>接口的修饰符只能是public和默认，和类一样</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类。内部类最大的特点是可以直接访问私有属性，并且可以直接体现类之间的包含关系。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>定义在外部类局部位置上，比如方法内：<ul>
<li>局部内部类（有类名）</li>
<li>匿名内部类（没有类名）<strong>重点！！！</strong></li>
</ul>
</li>
<li>定义在外部类的成员位置上：<ul>
<li>成员内部类</li>
<li>静态内部类（用static修饰）</li>
</ul>
</li>
</ul>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul>
<li>内部类可以直接访问外部类的所有成员，包括私有的；外部类先创建内部类的对象再进行调用，必须在作用域中</li>
<li><strong>不能添加访问修饰符，因为它的地位是一个局部变量</strong>，局部变量是不能使用修饰符的。但可以使用final修饰</li>
<li>作用域：仅仅在定义它的方法或代码块中</li>
<li>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.this.成员</code>访问</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>一个接口&#x2F;类的方法的某个实现方式在程序中<strong>只会执行一次</strong>，但为了使用它，我们需要创建它的实现类&#x2F;子类去实现重写。此时可以使用匿名内部类的方式，可以<strong>无需创建新的类，减少代码冗余</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new A()&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;.cry();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>匿名内部类既是一个类的定义，同时也是一个对象</p>
</li>
<li><p>可以访问外部类的所有成员，包括私有的</p>
</li>
<li><p><strong>不能添加修饰符，因为它的地位就是一个局部变量</strong></p>
</li>
<li><p>作用域：仅仅是在定义它的方法或代码块中</p>
</li>
<li><p>外部其他类不能访问匿名类</p>
</li>
<li><p>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.this.成员</code>访问</p>
</li>
<li><p>可以当作实参直接传递，简洁高效</p>
</li>
</ul>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul>
<li>定义在外部类的成员位置，并且<strong>没有static修饰</strong></li>
<li>可以直接使用外部类的所有成员，包括私有成员</li>
<li><strong>可以添加任意的访问修饰符，因为它的地位是一个成员</strong></li>
<li>作用域：和外部类的其他成员一样，为整个类体</li>
<li>外部其他类访问内部类<ul>
<li><code>外部类名.内部类名 对象名 = 外部类名.new 内部类名();</code></li>
<li>方法返回</li>
<li><code>new 外部类名().new 内部类();</code></li>
</ul>
</li>
</ul>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul>
<li><p>定义在外部类的成员位置，<strong>有static修饰</strong></p>
</li>
<li><p>可以访问外部类所有静态成员，不能访问非静态成员</p>
</li>
<li><p>可以添加任意修饰符</p>
</li>
<li><p>作用域：整个类体</p>
</li>
<li><p>外部其他类访问内部类</p>
<ul>
<li>通过类名直接访问，但要满足访问权限</li>
<li>方法</li>
</ul>
</li>
<li><p>如果外部类和内部类重名时，默认遵守就近原则，如果想访问外部类的成员，则可以用<code>外部类名.成员</code>访问</p>
</li>
</ul>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul>
<li><p>使用<code>enum</code>代替<code>class</code>声明枚举类，就不能继承其他类了（因为隐式继承<code>Enum</code>类，<code>java</code>是单继承机制），但是可以继承接口</p>
</li>
<li><p>使用<code>enum</code>关键字开发一个枚举类时，默认会继承<code>Enum</code>类, 而且是一个final类</p>
</li>
<li><p>枚举简化为<code>枚举对象(参数列表)</code></p>
</li>
<li><p>使用无参构造器创建枚举对象，则实参和小括号都可以省略</p>
</li>
<li><p>当有多个枚举对象时，使用<code>,</code>分隔，最后一个<code>;</code>结尾</p>
</li>
<li><p>枚举对象必须放在枚举类首行</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color </span><br><span class="line">&#123; </span><br><span class="line">    RED, GREEN, BLUE; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解用来修饰解释包、类、方法、属性、构造器、局部变量等。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</p>
<ul>
<li><p><strong>@Override</strong>：限定某个方法，是重写某个父类方法，该注解只能用于方法</p>
</li>
<li><p><strong>@Deprecated</strong>：用于表示某个程序元素（类、方法等）已过时，即不推荐使用，但是仍然能使用</p>
</li>
<li><p><strong>@SuppressWarnings</strong>：抑制编译器警告</p>
</li>
</ul>
<p><strong>元注解</strong>：注解的注解</p>
<ul>
<li>Retention：指定注解的作用范围，三种SOURCE, CLASS, RUNTIME</li>
<li>Target：指定注解可以在哪些地方使用</li>
<li>Documented：指定注解是否会在javadoc体现</li>
<li>Inherited：子类会继承父类注解</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li><p>执行过程中发生的异常分为两大类</p>
<ol>
<li>Error(错误)：Java虚拟机无法解决的严重问题，如<code>JVM</code>系统内部错误、资源耗尽等。比如<code>StackOverflowError</code>和<code>OOM（out of memory)</code></li>
<li>Exception：其他因编程或偶然的外在因素导致的一般问题，可以使用针对性的代码处理，分为两大类：运行时异常和编译时异常。编译异常程序中必须处理，运行时异常程序中没有处理默认是<code>throws</code></li>
</ol>
</li>
<li><p>异常处理方式: <code>ctrl</code>+<code>alt</code>+<code>t</code>选择 或者 <code>alt</code>+<code>enter</code></p>
<ol>
<li><p><code>try-catch-finally</code>：捕获异常，自行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(EXception e)&#123;</span><br><span class="line">	<span class="comment">//当异常发生时异常后面的代码不执行，直接进入catch，系统将异常封装成Exception对象e传递给catch，得到异常后程序员自己处理</span></span><br><span class="line">	<span class="comment">//异常没有发生，catch不执行</span></span><br><span class="line">	<span class="comment">//在实际开发中，通常将编译异常转换为允许异常抛出，调用者可以捕获或抛出 throw new RuntimeException(e);</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//不管代码是否有异常，finally都要执行</span></span><br><span class="line">	<span class="comment">//通常将释放资源的代码放在finally，保证关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以有多个<code>catch</code>语句，捕获不同的异常，要求父类异常在后，子类异常在前，比如<code>Exception</code>在后，<code>NullPointException</code>在前，如果发生异常，只会匹配一个<code>catch</code></p>
<p>可以进行<code>try-finally</code>配合使用，相当于没有捕获异常，因此程序会直接奔溃。应用场景：执行一段代码不管是否发生异常都必须执行某个业务逻辑</p>
</li>
<li><p><code>throws</code>：将异常抛出，交给调用者处理，最顶级的处理者是<code>JVM</code></p>
<p>编译异常程序中必须处理，运行时异常程序中没有处理默认是<code>throws</code></p>
<p>子类重写父类的方法时，对抛出异常的规定：子类重写的方法抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类型</p>
<p>在<code>throws</code>过程中，如果有<code>try-catch</code>，相当于处理异常，就可以不必<code>throws</code></p>
</li>
</ol>
</li>
<li><p>自定义异常：<code>异常类名 extends Exception/RuntimeException</code>如果继承<code>Exception</code>，属于编译异常；如果继承<code>RuntimeException</code>，属于运行异常，一般继承<code>RuntimeException</code></p>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="包装类（Wrapper类）"><a href="#包装类（Wrapper类）" class="headerlink" title="包装类（Wrapper类）"></a>包装类（Wrapper类）</h3><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<ul>
<li><p>jdk5之后自动装箱和拆箱，自动装箱底层调用的是<code>valueOf()</code>方法，</p>
<p>如果是在基本数据类型对应范围内就直接返回，否则返回 <code>new 包装类(xx)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">		<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">装箱: int -&gt; Integer</span><br><span class="line">	 int m;</span><br><span class="line">	 Interger n = m;</span><br><span class="line">拆箱: Integer -&gt; int</span><br><span class="line">	 Integer n = new Integer(2);</span><br><span class="line">	 int m = n;</span><br></pre></td></tr></table></figure>
</li>
<li><p>包装类和String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">包装类 -&gt; String</span><br><span class="line">Integer i = 100;</span><br><span class="line">String s1 = i + &quot;&quot;;			//方法一</span><br><span class="line">String s2 = i.toString();	//方法二</span><br><span class="line">String s3 = String.valueOf(i);//方法三</span><br><span class="line"></span><br><span class="line">String -&gt; 包装类</span><br><span class="line">String s = &quot;123&quot;;</span><br><span class="line">Integer i1 = Integer.parseInt(s); //方法一，用到自动装箱</span><br><span class="line">Integer i2 = new Integer(s);	//方法二，用到构造器</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li><p>String类是一个<strong>final类</strong>，实现了接口Serializable（可串行化：可以在网络传输）和Comparable（对象可以比较大小）</p>
</li>
<li><p>有属性<code>private final char value[]</code>, value赋值后<strong>不可以修改，指不能指向新的地址，但单个字符内容可以改变</strong></p>
</li>
<li><p>字符串使用Unicode编码，一个字符占两个字节</p>
</li>
<li><p>常见构造器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String();</span><br><span class="line">String s2 = new String(String s);</span><br><span class="line">String s3 = new String(char[] a);</span><br><span class="line">String s4 = new String(char[] a, int startindex, int count);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">String s1 = &quot;str&quot;;</span><br><span class="line">先从常量池查看是否有&quot;str&quot;数据空间，如果有直接指向；如果没有则重新创建然后指向。s1最终指向的是常量池的空间地址</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">String s2 = new String(&quot;str&quot;);</span><br><span class="line">先从堆中创建空间，里面维护了value属性，指向常量池的str空间。如果常量池没有&quot;str&quot;重新创建，如果有直接通过value指向。s2最终指向的是堆中的空间地址</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code>String s1 = &quot;ab&quot; + &quot;cd&quot;;	//常量相加: 编译器会优化，常量池中只有&quot;abcd&quot;, s1指向常量池中的&quot;abcd&quot;

String a = &quot;ab&quot;;
String b = &quot;cd&quot;;
String s2 = a+b;			//变量相加: s2指向堆再通过堆中value指向常量池中的&quot;abcd&quot;, 常量池中有”ab&quot;, &quot;cd&quot;, &quot;abcd&quot;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 常用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
equals			//区分大小写判断内容是否相等
equalsIgnoreCase//忽略大小写判断内容是否相等
length			//字符串长度
indexOf			//获取字符串第一次出现的索引
lastInedxOf		//获取字符串最后一次出现的索引
substring		//截取指定范围子串
trim			//去前后空格
charAt			//获取某索引处的字符，注意不能用Str[idx]方式
toUpperCase		//转换为大写
toLowerCase		//小写
concat			//拼接
replace			//替换, 原串不影响, 返回结果才是替换过的
split			//分割字符串
toCharArray		//转换为字符数组
compareTo		//比较字符串大小
format			//格式转换
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### StringBuffer</span><br><span class="line"></span><br><span class="line">可变的字符序列，可以对字符串内容进行增删。很多方法和String相同，但是StringBuffer是可变长度的。StringBuffer是一个容器。</span><br><span class="line"></span><br><span class="line">* 对比String：</span><br><span class="line">  * String保存的是字符串常量，里面的值不能修改，每次String类更新实际上是修改地址，效率低。`//private final char value[];`</span><br><span class="line">  * StringBuffer保存的是字符串变量，里面的值可以修改，每次更新实际上更新的是内容，不用每次更新地址，效率高。`//char[] value; //放在堆中`</span><br><span class="line"></span><br><span class="line">* 转换</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Stirng -&gt; StringBuffer
// 1. 使用构造器
String str = &quot;hello&quot;;
StringBuffer sb1 = new StringBuffer(str);
// 2. 使用append方法
StringBuffer sb = new StringBuffer();
sb = sb.append(str);

StringBuffer -&gt; String
// 1. 使用StringBuffer提供的toString方法
// 2. 使用构造器
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 常用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
append			//增
delete(st,ed)	//删除[st,ed)字符
replace(st,ed,str)//替换
indexOf			//查找第一次出现的索引
insert(idx,str)	//插入
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### StringBuilder</span><br><span class="line"></span><br><span class="line">一个可变的字符序列，此类提供一个与StringBuffer兼容的API，但并不能保证同步（存在线程安全问题），用作StringBuffer的一个简易替换，**用在字符串缓冲区被单个线程使用的时候**，如果可能建议优先使用，因为**比StringBuffer快**。</span><br><span class="line"></span><br><span class="line">三者比较</span><br><span class="line"></span><br><span class="line">* StringBuffer和StringBuilder非常类似，均代表可变字符序列，而且方法也一样</span><br><span class="line">* String：不可变字符序列，效率低，但复用率高</span><br><span class="line">* StringBuffer：可变字符序列，效率较高（增删），线程安全</span><br><span class="line">* StringBuilder：可变字符序列，效率最高，线程不安全</span><br><span class="line">* 如果需要对String做大量的修改，不要使用String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Arrays</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>toString			&#x2F;&#x2F;返回数组的字符串形式，显示数组<br>sort				&#x2F;&#x2F;自然排序和定制排序<br>传入一个接口Comparator实现定制排序，要求实现匿名内部类Comparator的compare方法<br>Arrays.sort(arr, new Comparator<Integer>() {<br>    @Override<br>    public int compare(Integer o1, Integer o2) {<br>        return 0;&#x2F;&#x2F;自己实现<br>    }<br>});<br>binarySearch		&#x2F;&#x2F;二分查找<br>copyOf				&#x2F;&#x2F;数组元素的复制<br>fill				&#x2F;&#x2F;元素填充<br>equals				&#x2F;&#x2F;数组比较<br>asList				&#x2F;&#x2F;将一组值转换为list集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### BigInteger 和 BigDecimal</span><br><span class="line"></span><br><span class="line">* BigInteger 适合保存比较大的整数；BigDecimal 适合保存精度更高的浮点数</span><br><span class="line">* 对其进行加减乘除运算时需要使用相应的方法，不能直接使用`+ - * /`</span><br><span class="line">* BigDecimal 进行`divide`运算时可能除不尽而抛出异常，指定精度即可，`BigDecimal.ROUND_CEILING`, 结果保留分子精度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 日期类</span><br><span class="line"></span><br><span class="line">#### 第一代日期类Date </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 获取当前时间，在java.util包，默认输出格式是国外格式，可以通过格式转换</span><br><span class="line">// 1. 创建SimpleDateFormat对象可以指定相应格式</span><br><span class="line">// 2. 格式是字母规定好的</span><br><span class="line">Date d = new Date();//获取当前时间</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年mm月dd日 hh:mm:ss E&quot;);</span><br><span class="line">String format = sdf.format(d);</span><br><span class="line">System.out.println(format);//2023年43月21日 07:43:11 周四</span><br><span class="line"></span><br><span class="line">// 把字符串转换为对应时间</span><br><span class="line">String s = &quot;2023年43月21日 07:43:11 周四&quot;;</span><br><span class="line">Date parse = sdf.parse(s);//Sat Jan 21 07:43:11 CST 2023</span><br></pre></td></tr></table></figure>



<h4 id="第二代日期类Calendar"><a href="#第二代日期类Calendar" class="headerlink" title="第二代日期类Calendar"></a>第二代日期类Calendar</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar 是一个抽象类，构造器是私有的，通过getInstance()获取实例，提供大量的方法和字段</span><br><span class="line">月份从0开始</span><br><span class="line">24小时制: Calendar.HOUR -&gt; Calendar.HOUR_OF_DAY</span><br><span class="line"></span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c.get(Calendar.YEAR));//2023</span><br></pre></td></tr></table></figure>



<h4 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h4><p>建议使用第三代日期类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalDate(日期)</span><br><span class="line">LocalTime(时间)</span><br><span class="line">LocalDateTime(时间日期)</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);//2023-09-21T20:39:47.018543</span><br><span class="line"></span><br><span class="line">使用DateTimeFormatter类格式化日期</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter dd = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh小时mm分钟ss秒&quot;);</span><br><span class="line">String s = dd.format(localDateTime);</span><br><span class="line">System.out.println(s);//2023年09月21日 08小时47分钟35秒</span><br></pre></td></tr></table></figure>



<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>允许重复</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li><p>基本等同于Vector，效率高，但是线程不安全</p>
</li>
<li><p>ArrayList 中维护了一个Object类型的数组elementData <code>transient Object[] elementData;//transient表示属性不会被序列化</code></p>
</li>
<li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始的elementData容量为0，第一添加，则扩容为10，如需再次扩容则扩容为1.5倍</p>
</li>
<li><p>如果使用指定大小的构造器，初始容量为指定大小，如果需要扩容则扩容为1.5倍</p>
</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul>
<li><p><code>protected Object[] elementData;</code></p>
</li>
<li><p>线程同步的，即线程安全, 操作方法带 <code>synchronized</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>线程安全 效率</th>
<th>扩容机制</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>不安全，效率高</td>
<td>有参扩容1.5倍 <br>无参默认0，第一次扩容为10，后面扩容1.5倍</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组</td>
<td>安全，效率不高</td>
<td>有参扩容2倍<br>无参默认是10，后面扩容2倍</td>
</tr>
</tbody></table>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>底层实现了双向链表和双端队列的特点</li>
<li>可以添加任意元素</li>
<li>线程不安全</li>
<li>LinkedList底层维护了一个双向链表，属性first和last分别指向首结点和尾结点</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删效率</th>
<th>改查效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>较高</td>
<td>较低</td>
</tr>
</tbody></table>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>不能存放重复元素，取出顺序和添加顺序不一致</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul>
<li><p>HashSet实际上是HashMap , HashMap底层是（数组+链表+红黑树）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第一次添加时，table数组扩容到16，临界值是16*loadFactor(0.75)=12, 如果table数组使用到了临界值，就会扩容2倍，依次类推</span><br><span class="line">1. 添加一个元素时，先得到hash值然后转换为索引值</span><br><span class="line">2. 找到存储数据的table，看索引位置是否有元素</span><br><span class="line">3. 如果没有，直接加入</span><br><span class="line">4. 如果有，调用equals比较，如果相同放弃添加，如果不同添加到最后。equals不能简单的认为是比较内容或是地址，程序员可以进行重写 </span><br><span class="line">5. 在java8中，如果一条链表的元素个数 &gt;= TREEIFY_THRESHOLD(默认8)，并且table大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul>
<li><p>是HashSet的子类</p>
</li>
<li><p>底层是一个LinkedHashMap，底层维护了一个数组+双向链表</p>
</li>
<li><p>根据元素的hashCode值决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的</p>
</li>
<li><p>不允许元素重复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次添加元素时，table数组扩容到16，数组是HashMap$Node[],存放的结点类型是LinkedHashMap$Entry</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul>
<li><p>底层是TreeMap</p>
</li>
<li><p>可以实现排序，构造器可以传入一个比较器（匿名内部类）对TreeSet进行排序</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>存放具有映射关系的数据：key-value, 两者可以是任何引用类型的数据，会封装到HashMap$Node中，key不能重复（相同的key等价于替换）, value可以重复</p>
<ul>
<li><p>接口遍历方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containKey	//键是否存在</span><br><span class="line">keySet		//获取所有键</span><br><span class="line">entrySet	//获取所有关系</span><br><span class="line">values		//获取所有值</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul>
<li>键和值都不能为空</li>
<li>使用方法基本和HashMap一样</li>
<li>Hashtable是线程安全的，HashMap是线程不安全的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">底层数组Hashtable$Entry[] 初始化大小 11</span><br><span class="line">临界值 threshold = 8 (11*0.75)</span><br><span class="line">扩容机制</span><br></pre></td></tr></table></figure>



<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul>
<li><p>继承自Hashtable类并实现了Map接口，也是使用一种键值对的形式来保存数据</p>
</li>
<li><p>还可以用于从XXX.properties文件中加载数据到Properties类对象，并进行读取和修改，通常作为配置文件</p>
</li>
<li><p>常用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">load		//加载配置文件的键值到对象</span><br><span class="line">list		//将数据显示到指定设备</span><br><span class="line">getProperty(key)//根据键获取值</span><br><span class="line">setProperty(key,value)//设置键值对到对象</span><br><span class="line">store		//将键值存储到配置文件，在IDEA中保存信息到配置文件，如果含有中文，会存储为unicode码</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><ul>
<li><p>是一个操作Set, List, Map的工具类</p>
</li>
<li><p>提供了一系列静态的方法对集合元素进行排序、查询、修改等操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)		//反转</span><br><span class="line">shuffle(List)		//随机排序</span><br><span class="line">sort(List)</span><br><span class="line">sort(List, Comparator)</span><br><span class="line">swap(int i, int j)	//交换List集合中位置i和j的元素</span><br><span class="line">max/min(Collection)</span><br><span class="line">max/min(Collection, Comparator)</span><br><span class="line">frequency(Collection, Object)	//返回集合中指定元素出现次数</span><br><span class="line">copy(List desc, List src)	//src -&gt;desc</span><br><span class="line">replaceAll(List list, Object oldVal, Object newVal)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型又称参数化类型，解决数据的安全性问题</p>
<ul>
<li><p>编译时，检查添加元素的类型，提高了安全性</p>
</li>
<li><p>减少了类型转换的次数，提高效率</p>
</li>
<li><p>可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值类型，或是参数类型</p>
</li>
<li><p>泛型指定数据类型时要求是引用类型，不能是基本数据类型</p>
</li>
<li><p>给泛型指定类型后，可以传入该类型或其子类类型</p>
</li>
<li><p>如果不指定泛型，默认是Object</p>
</li>
<li><p>泛型没有继承性 <code>List&lt;Object&gt; list = new ArrayList&lt;String&gt;();//错误</code></p>
</li>
</ul>
<p>自定义泛型类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class 类名&lt;T,R...&gt;&#123;//泛型标识符可以有多个，一般单个大写字母</span><br><span class="line">	成员</span><br><span class="line">&#125;//自定义类后面有泛型, 就称为自定义泛型</span><br><span class="line"></span><br><span class="line">注意细节：</span><br><span class="line">	普通成员可以使用泛型(属性, 方法)</span><br><span class="line">	使用泛型的数组，不能初始化。例如不能：T[] t = new T[8]; //因为数组在new时不能确定T的类型无法在内存开辟空间。</span><br><span class="line">	静态方法和属性中不能使用泛型。因为静态是和类相关的，类加载时对象还没有创建</span><br><span class="line">	泛型类的类型，是在创建对象时确定的</span><br><span class="line">	如果创建对象时没有指定类型，默认Object</span><br></pre></td></tr></table></figure>

<p>自定义泛型接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&lt;T,R...&gt;&#123;&#125;</span><br><span class="line">注意细节：</span><br><span class="line">	接口中静态成员也不能使用泛型</span><br><span class="line">	泛型接口的类型，是在继承接口或实现接口时确定的</span><br><span class="line">	没有指定泛型默认Object</span><br></pre></td></tr></table></figure>

<p>自定义泛型方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,R..&gt; 返回类型 方法名（参数列表）&#123;&#125;</span><br><span class="line">注意细节：</span><br><span class="line">	泛型方法可以定义在普通类中，也可以定义在泛型类中</span><br><span class="line">	当泛型方法被调用时，类型会确定</span><br><span class="line">	public void eat(E e)&#123;&#125;不是泛型方法，而是使用了泛型</span><br></pre></td></tr></table></figure>

<p>通配符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt;: 支持任意泛型类型</span><br><span class="line">&lt;? extends A&gt;: 支持A类和A类的子类，规定了泛型的上限</span><br><span class="line">&lt;? super A&gt;: 支持A类和A类的父类，不限于直接父类，规定了下限</span><br></pre></td></tr></table></figure>



<h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p>java中线程使用的两种方法：</p>
<ol>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口，重写run方法</li>
</ol>
<p>两者本质上并没有什么区别，实现Runnable接口方式更适合多个线程共享一个资源的情况，并且避免了单继承的限制</p>
<ul>
<li><p>线程常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setName</span><br><span class="line">getName</span><br><span class="line">start			//使线程开始执行，java虚拟机调用该线程的start0方法</span><br><span class="line">run 			//调用线程对象run方法</span><br><span class="line">setPriority		//设置优先级</span><br><span class="line">getPriority</span><br><span class="line">sleep			//是静态方法，休眠</span><br><span class="line">interrupt		//中断线程,并没有真正结束线程，一般用于中断正在休眠的线程</span><br><span class="line">yield			//让出CPU让其他线程执行，但礼让的时间不确定，所以不一定成功</span><br><span class="line">join			//线程的插队，肯定先执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户线程：工作线程，当线程的任务执行完或通知方式结束</p>
</li>
<li><p>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。常见的守护线程：垃圾回收机制。通过<code>.setDaemon(true)</code>设置为守护线程</p>
</li>
<li><p>线程同步</p>
<ul>
<li><p>同步代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象)&#123;//得到对象的锁才能操作同步代码</span><br><span class="line">	//需要同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void m(String name)&#123;</span><br><span class="line">	//需要被同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象），默认锁对象为<code>this</code></p>
</li>
<li><p>同步方法（静态的）的锁为当前类本身，默认锁对象为：<code>当前类.class</code></p>
</li>
</ul>
</li>
<li><p>释放锁</p>
<ul>
<li>同步方法、代码执行结束</li>
<li>同步方法、代码遇到break, return </li>
<li>出现未处理的Error或Exception导致异常结束</li>
<li>执行了线程对象的wait()方法，当前线程暂停并释放锁</li>
<li>调用Thread.sleep(), Thread.yield()方法暂停当前线程的执行，不会释放锁</li>
</ul>
</li>
</ul>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>常用的文件操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new File(String path)</span><br><span class="line">new File(File parent, String path)//根据父目录文件+子路径</span><br><span class="line">new File(String parent, String child)//父目录+子路径</span><br><span class="line">createNewFile	//创建文件</span><br><span class="line"></span><br><span class="line">mkdir创建一级目录，mkdirs创建多级目录，delete删除空目录或文件</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png"></p>
<h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><p>节点流可以从一个特定的数据源读取数据，如FileReader，FileWriter。处理流（包装流）是”连接”在已存在的流之上，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader, BufferedWriter。</p>
<p>区别和联系：</p>
<ul>
<li>节点流是底层流&#x2F;低级流，直接和数据源相接</li>
<li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出，例如BufferedReader中有Reader属性，可以封装任意流只要是Reader的子类</li>
<li>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li>
</ul>
<p>处理流的功能体现：</p>
<ul>
<li>性能的提高：主要以增加缓冲的方式提高输入输出的效率</li>
<li>操作的便捷：处理流可能提供一些便捷的方法来一次输入输出大量数据，使用更加灵活</li>
</ul>
<h4 id="序列化和反序列化-ObjectOutputStream-x2F-ObjectInputStream"><a href="#序列化和反序列化-ObjectOutputStream-x2F-ObjectInputStream" class="headerlink" title="序列化和反序列化 ObjectOutputStream&#x2F;ObjectInputStream"></a>序列化和反序列化 ObjectOutputStream&#x2F;ObjectInputStream</h4><p>序列化就是在保存数据时保存值和数据类型，<code>ObjectOutputStream</code>提供序列化；反序列化就是在恢复数据时恢复值和数据类型，<code>ObjectInputStream</code>提供反序列化。</p>
<p>需要让某个类支持序列化机制，则必须让类可序列化，必须实现两个接口之一：</p>
<ol>
<li><p><code>Serializable</code> &#x2F;&#x2F;标记接口，没有方法。推荐使用</p>
</li>
<li><p><code>Externalizable</code></p>
</li>
</ol>
<p>注意事项和细节：</p>
<ol>
<li>读写顺序一致</li>
<li>序列化或反序列化的对象需要实现<code>Serializable</code>接口</li>
<li>序列化的类中建议添加<code>SerialVersionUID</code>，为了提高版本兼容性</li>
<li>序列化对象时默认将里面所有属性都进行序列化，除了<code>static</code>和<code>transient</code>修饰的成员</li>
<li>序列化对象时，要求里面的属性的类型也需要实现序列化接口</li>
<li>序列化具有可继承性，如果某类实现了序列化，则它的所有子类也已经默认实现了序列化</li>
</ol>
<h4 id="转换流-InputStreamReader-x2F-OutputStreamReader"><a href="#转换流-InputStreamReader-x2F-OutputStreamReader" class="headerlink" title="转换流 InputStreamReader&#x2F;OutputStreamReader"></a>转换流 InputStreamReader&#x2F;OutputStreamReader</h4><p>InputStreamReader: Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）</p>
<p>OutputStreamReader: Writer的子类，可以将OutputStream（字节流）包装成Writer（字符流）</p>
<p>当处理纯文本数据时，使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换为字符流</p>
<p>可以在使用时指定编码格式</p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p><code>netstat -an | more</code> ：分页显示主机网络情况</p>
<h4 id="TCP字节流编程"><a href="#TCP字节流编程" class="headerlink" title="TCP字节流编程"></a>TCP字节流编程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="comment">// 1.连接服务端(ip, 端口)</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line"><span class="comment">// 2.连接成功返回Socket对象</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">// 3.通过输出流写数据到数据通道</span></span><br><span class="line">outputStream.write(<span class="string">&quot;hello server&quot;</span>.getBytes());</span><br><span class="line">socket.shutdownOutput();<span class="comment">//设置结束标记。## 也可以改用Write.newLine()标记结束，对应的需要服务端使用readLine()读取数据##</span></span><br><span class="line"><span class="comment">// 4.关闭流</span></span><br><span class="line">outputStream.close();</span><br><span class="line">socket.close();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="comment">// 1.设置监听端口</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"><span class="comment">// 2.没有客户端连接端口时阻塞等待</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"><span class="comment">// 3.通过输入流获取数据</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="comment">// 4.IO读取b</span></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readline</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((readline = inputStream.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readline));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5.关闭流</span></span><br><span class="line">inputStream.close();</span><br><span class="line">socket.close();</span><br><span class="line">serverSocket.close();</span><br></pre></td></tr></table></figure>



<h4 id="TCP字符流编程"><a href="#TCP字符流编程" class="headerlink" title="TCP字符流编程"></a>TCP字符流编程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;hello server....&quot;</span>);</span><br><span class="line">bufferedWriter.flush();<span class="comment">//需要手动刷新，否则数据不会写入通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line"><span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readline</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((readline = bufferedReader.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readline));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>通过外部文件配置，在不修改源码的情况下来控制程序，也符合设计模式的ocp原则(开闭原则: 不修改源码，扩容功能)。</p>
<p>反射机制允许程序在执行期间借助于ReflectionAPI取得任何类的内部信息，并能操作对象的属性及方法。</p>
<p>加载完类之后，在堆中产生一个Class类型的对象（一个类只有一个Class对象），这个对象包含类的完整结构信息。</p>
<p>反射相关的主要类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class 			//代表一个类，Class对象表示某个类加载后在堆中的对象</span><br><span class="line">java.lang.reflect.Method	//代表类方法</span><br><span class="line">java.lang.reflect.Field		//代表类成员变量</span><br><span class="line">java.lang.reflect.Constructor//代表类构造方法</span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong></p>
<p>​	优点：可以动态的创建和使用对象（框架底层核心），使用灵活</p>
<p>​	缺点：使用反射是解释执行，对执行速度有影响</p>
<p><strong>反射调用优化：关闭访问检查</strong></p>
<p>​	Method和Field、Constructor对象都有setAccessible()方法，作用是启动和禁用访问安全检查，参数为true表示反射的对象在使用时取消访问检查，提高反射效率</p>
<p><strong>通过反射获取类结构信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getName:获取全类名</span><br><span class="line">getSimpleName:获取简单类名</span><br><span class="line">getFields:获取所有public属性，包含本类和父类</span><br><span class="line">getDeclaredFields:获取所有属性</span><br><span class="line">getMethods:获取所有public方法</span><br><span class="line">getDeclaredMethods:获取所有方法</span><br><span class="line">getModifiers:以int形式返回修饰符（默认修饰符是0，public是1，private是2，protected是4，static是8，final是16）</span><br><span class="line">getType:以Class形式返回类型</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>通过反射创建对象</strong></p>
<ol>
<li><p>调用类中的public修饰的无参构造器</p>
</li>
<li><p>调用类中的指定构造器</p>
</li>
<li><p>Class类相关方法：</p>
<p>newInstance: 调用类中的无参构造器，获取对应类的对象</p>
<p>getConstructor(Class.class, …): 根据参数列表获取对应构造器对象</p>
<p>getDecalaredConstructor(Class.class, …): 根据参数列表获取对应构造器对象</p>
</li>
<li><p>Constructor类相关方法</p>
<p>setAccessible: 爆破, 使用反射可以访问private构造器&#x2F;属性&#x2F;方法</p>
<p>newInstance(Object.object, …): 调用构造器</p>
</li>
</ol>
<p><strong>通过反射访问类中成员</strong></p>
<ol>
<li><p>根据属性名获取Field对象 &#x2F;&#x2F;getField获取public属性, getDeclaredField获取所有类型属性</p>
<p><code>Field f = clazz对象.getDeclaredField(属性名);//f即为对应属性</code></p>
</li>
<li><p>爆破：<code>f.setAccessible(true)</code></p>
</li>
<li><p>访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.set(object, 值);//object为对象</span><br><span class="line">f.get(object);</span><br><span class="line">//如果是静态属性，set和get中的参数object，可以写成null</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>通过反射访问方法</strong></p>
<ol>
<li><p>根据方法名和参数列表获取Method方法对象</p>
<p><code>Method m = clazz对象.getDeclaredMethod(方法名, XX.class);</code></p>
</li>
<li><p>获取对象 ：<code>Object o = clazz.newInstance();</code></p>
</li>
<li><p>爆破：<code>m.setAccessible(true);</code> &#x2F;&#x2F;私有的需要爆破</p>
</li>
<li><p>访问：<code>Object returnValue = m.invoke(o, 实参列表); //如果是静态方法，o可以写成null</code></p>
</li>
</ol>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>Class类也是类，因此继承Object类</p>
<p>Class类对象不是new出来的，而是系统创建的</p>
<p>对于某个类的Class对象，在内存只有一份，因为类只加载一次</p>
<p>每个类的实例都会记得自己是由哪个Class实例所产生</p>
<p>通过Class对象可以完整的得到一个类的完整结构，通过一系列的API</p>
<p>Class对象存放在堆中</p>
<p>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码、变量名、方法名、访问权限等）</p>
<p><strong>获取Class对象的方法 :</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 已知一个类的全类名，且在该类的路径下，可以通过Class类的静态方法forName()获取。</span></span><br><span class="line"><span class="comment">//	  应用场景：多用于读取配置文件，读取类全路径加载类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Cat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 已知具体类，通过类的class获取，该方式最为安全可靠，性能最高</span></span><br><span class="line"><span class="comment">//	  多用于参数传递，比如通过反射得到对应构造器对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Cat.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 已知某个类的实例，调用该实例的getClass()方法获取Class对象</span></span><br><span class="line"><span class="comment">//	  通过创建好的对象获取Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> 对象.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 通过类加载器得到Class对象</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="comment">// 1) 先得到类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader();</span><br><span class="line"><span class="comment">// 2) 通过类加载器得到Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">aclass</span> <span class="operator">=</span> classLoader.loadClass(classAllPath);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p>
<p>静态加载：编译时加载相关类，如果没有则报错，依赖性太强</p>
<p>动态加载：运行时加载需要的类，如果运行时没有用到该类则不会报错，降低了依赖性</p>
<p><strong>类加载时机：</strong></p>
<ol>
<li>创建对象时 	&#x2F;&#x2F;静态加载</li>
<li>当子类被加载时  &#x2F;&#x2F;静态加载</li>
<li>调用该类的静态成员时 &#x2F;&#x2F;静态加载</li>
<li>通过反射  &#x2F;&#x2F; 动态加载</li>
</ol>
<p><strong>类加载阶段：（加载-&gt;连接（验证，准备，解析）-&gt;初始化）</strong></p>
<ol>
<li><p>加载阶段：将字节码从不同数据源转化为二进制字节流加载到内存中，并生成一个代表该类的Class对象</p>
</li>
<li><p>连接-验证：确保Class文件的字节流中包含的信息符合当前虚拟机要求并且不会危害虚拟机安全。可以考虑使用<code>-Xverify:none</code>参数来关闭大部分类验证措施，缩短类加载时间</p>
<p>连接-准备：JVM对静态变量分配内存并默认初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int n1 = 10;					//不是静态变量，准备阶段不是分配内存</span><br><span class="line">public static int n2 = 20;			//是静态变量分配内存，默认初始化是0，而不是20</span><br><span class="line">public static final int n3 = 30;	//是static final常量，一旦赋值就不变，初始化为30</span><br></pre></td></tr></table></figure>

<p>连接-解析：虚拟机将常量池的符号引用替换为直接引用的过程</p>
</li>
<li><p>初始化：才真正开始执行程序代码，依次收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并</p>
</li>
</ol>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>命令行连接数据库：<code>mysql -h 主机ip -P 端口 -u 用户名 -p[密码]</code></p>
<p>备份数据库(在DOS执行)：<code>mysqldump -u 用户名 -p -B 数据库1 数据库2 &gt; 文件名.sql</code></p>
<p>备份数据库表(在DOS执行)：<code>mysqldump -u 用户名 -p 表1 表2 &gt; 文件名.sql</code></p>
<p>恢复数据库（mysql命令行执行）：<code>Source 文件名.sql</code></p>
<h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><ul>
<li><p>添加列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">ADD			(column datatype...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">MODIFY		(column datatype...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">DROP		(column);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表结构：<code>desc 表名</code></p>
</li>
<li><p>修改表名：<code>rename table 表名 to 新表名</code></p>
</li>
<li><p>修改表字符集：<code>alter table 表名 character set 字符集</code></p>
</li>
<li><p>修改列名：<code>alter table tablename change 原列名 新列名 datatype</code></p>
</li>
</ul>
<h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><ul>
<li><p>insert</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tablename[column...]</span><br><span class="line">VALUES		(value...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>update</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tablename</span><br><span class="line">		SET column=expr,...</span><br><span class="line">		[WHERE ...];</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM tablename</span><br><span class="line">		[WHERE ...];</span><br></pre></td></tr></table></figure>
</li>
<li><p>select</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT [DISTINCT] column as name,...</span><br><span class="line">		FROM tablename;</span><br><span class="line">		GROUP BY column HAVING ...</span><br></pre></td></tr></table></figure>

<p>分页查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ...limit start,rows		//表示从start+1开始取，取出rows行，start从0开始</span><br></pre></td></tr></table></figure>

<p><strong>select语句中顺序：group by, having, order by, limit</strong></p>
</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h5><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CHARSET(str)</td>
<td>返回字串字符集</td>
</tr>
<tr>
<td>CONCAT(string1, […])</td>
<td>连接字符串</td>
</tr>
<tr>
<td>INSTR(string, substring)</td>
<td>返回子串位置，没有返回0</td>
</tr>
<tr>
<td>UCASE(string)</td>
<td>转换大写</td>
</tr>
<tr>
<td>LCASE(string)</td>
<td>转换小写</td>
</tr>
<tr>
<td>LEFT(string，length)</td>
<td>左边起取length个字符</td>
</tr>
<tr>
<td>LENGTH(string)</td>
<td>string长度[按照字节]</td>
</tr>
<tr>
<td>REPLACE(str, search_str, replace_str)</td>
<td>在str中用replace_str替换search_str</td>
</tr>
<tr>
<td>STRCMP(string1, string2)</td>
<td>比较字符串</td>
</tr>
<tr>
<td>SUBSTRING(str, position [, length])</td>
<td>从str的position(从1开始)开始取length个字符</td>
</tr>
<tr>
<td>LTRIM(string), RTRIM(string), TRIM(string)</td>
<td>去前端空格，后端空格，前后端空格</td>
</tr>
</tbody></table>
<h5 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h5><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>abs(num)</td>
<td>绝对值</td>
</tr>
<tr>
<td>bin(num)</td>
<td>十进制转二进制</td>
</tr>
<tr>
<td>CEILING(num)</td>
<td>向上取整</td>
</tr>
<tr>
<td>CONV(num, from_base, to_base)</td>
<td>进制转换</td>
</tr>
<tr>
<td>FLOOR(num)</td>
<td>向下取整</td>
</tr>
<tr>
<td>FORMAT(num，decimal_places)</td>
<td>保留小数位数</td>
</tr>
<tr>
<td>HEX(num)</td>
<td>转十六进制</td>
</tr>
<tr>
<td>LEAST(num1, …)</td>
<td>最小值</td>
</tr>
<tr>
<td>MOD(num, denominator)</td>
<td>取余</td>
</tr>
<tr>
<td>RAND([seed])</td>
<td>随即数 [0-1], seed是随机种子</td>
</tr>
</tbody></table>
<h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CURRENT_DATE()</td>
<td>当前日期</td>
</tr>
<tr>
<td>CURRENT_TIME()</td>
<td></td>
</tr>
<tr>
<td>CURRENT_TIMESTAMP()</td>
<td></td>
</tr>
<tr>
<td>DATE&#x2F;YEAR&#x2F;MONTH&#x2F;DAY(datetime)</td>
<td>返回datetime的日期部分&#x2F;年&#x2F;月&#x2F;日</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL d_value d_type)</td>
<td>date说加上时间或日期，d_type可以是year, day, minute,hour等</td>
</tr>
<tr>
<td>DATE_SUB(date, INTERVAL d_value d_type)</td>
<td>减</td>
</tr>
<tr>
<td>DATEDIFF(date1, date2)</td>
<td>日期差（结果是天）</td>
</tr>
<tr>
<td>TIMEDIFF(date1, date2)</td>
<td>时间差</td>
</tr>
<tr>
<td>NOW()</td>
<td>当前时间</td>
</tr>
</tbody></table>
<h5 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h5><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>USER()</td>
<td>查询用户</td>
</tr>
<tr>
<td>DATABASE()</td>
<td>当前数据库</td>
</tr>
<tr>
<td>MD5(str)</td>
<td>对字符串加密</td>
</tr>
<tr>
<td>PASSWORD(str)</td>
<td>加密函数</td>
</tr>
</tbody></table>
<h5 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h5><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>IF(expr1, expr2, expr3)</td>
<td>expr1为true则返回expr2，否则返回expr3</td>
</tr>
<tr>
<td>IFNULL(expr1, expr2)</td>
<td>expr1不为空返回expr1，否则返回expr2</td>
</tr>
<tr>
<td>SELECT CASE<br>     WHEN expr1 THEN expr2<br>     WHEN expr3 THEN expr4<br>     ELSE expr5<br>END</td>
<td>多重分支</td>
</tr>
</tbody></table>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><h5 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h5><ol>
<li>外键指向的表的字段要求是primary key或者unique</li>
<li>表的类型是innodb才支持外键</li>
<li>外键字段类型和主键字段类型一致</li>
<li>外键字段的值，必须在主键字段中出现过，或者为null [前提是外键字段允许为空]</li>
<li>一旦建立外键关系，数据就不能随意删除了</li>
</ol>
<h5 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字段名 整型 primary key auto_increment</span><br><span class="line">添加自增长的字段方式：</span><br><span class="line">insert into xxx values(null, value...);</span><br><span class="line">insert into xxx (字段1...字段n) values(null, value...);</span><br><span class="line">insert into xxx (字段2...字段n) values(value...);</span><br></pre></td></tr></table></figure>

<ul>
<li>一般和primary key配合使用</li>
<li>也可以单独使用，但要配合一个unique</li>
<li>自增长修饰的字段为整型（可以是小数但是很少使用）</li>
<li>自增长默认从1开始，可以修改<code>alter table 表名 auto_increment = x;</code></li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//添加索引</span><br><span class="line">create [unique] index idx_name on table_name(column);</span><br><span class="line">alter table table_name add index idx_name(column);</span><br><span class="line"></span><br><span class="line">//删除索引</span><br><span class="line">drop index idx_name on table_name;</span><br><span class="line">//删除主键索引</span><br><span class="line">alter table table_name drop primary key;</span><br><span class="line"></span><br><span class="line">//查询索引</span><br><span class="line">show index from table_name</span><br></pre></td></tr></table></figure>

<ul>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li>
<li>更新非常频繁的字段不适合创建索引</li>
<li>不会出现在where语句的字段不该创建索引</li>
</ul>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>事务操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 开启事务</span><br><span class="line">START TRANSACTION</span><br><span class="line">set autocommit=off</span><br><span class="line">// 设置保存点</span><br><span class="line">SAVEPOINT point_name</span><br><span class="line">// 回退</span><br><span class="line">ROLLBACK TO point_name</span><br><span class="line">// 回退全部事务</span><br><span class="line">ROLLBACK</span><br><span class="line">// 提交事务，提交后不能回退	</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

<p><strong>InnoDB 存储引擎支持事务，MyISAM 不支持</strong></p>
<p><strong>隔离级别</strong></p>
<p>脏读：当一个事务读取另一个事务尚未提交的修改时</p>
<p>不可重复读：同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>修改或删除</strong>，每次返回不同结果集</p>
<p>幻读：同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>插入</strong>，每次返回不同结果集</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交(read uncommitted)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>不加锁</td>
</tr>
<tr>
<td>读已提交(read committed)</td>
<td>x</td>
<td>√</td>
<td>√</td>
<td>不加锁</td>
</tr>
<tr>
<td>可重复读(repeatable read)</td>
<td>x</td>
<td>x</td>
<td>√</td>
<td>不加锁</td>
</tr>
<tr>
<td>可串行化(serializable)</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>加锁</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 查看当前会话隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">// 查看系统当前隔离级别</span><br><span class="line">select @@global.tx_isolation;</span><br><span class="line">// 设置当前会话隔离级别</span><br><span class="line">set session transaction isolation level repeatable read ...;</span><br><span class="line">// 设置系统当前隔离级别</span><br><span class="line">set global transaction isolation level repeatable read ...;</span><br><span class="line">mysql默认的事务隔离级别是repeatable read</span><br></pre></td></tr></table></figure>



<h4 id="表类型和存储引擎"><a href="#表类型和存储引擎" class="headerlink" title="表类型和存储引擎"></a>表类型和存储引擎</h4><p>mysql表类型由存储引擎决定，主要包括MyISAM, innoDB, Memory等</p>
<p>mysql数据表主要支持六种类型，分别是CSV, Memory, ARCHIVE, MRG_MYISAM, MYISAM,InnoDB。这六种又分为两类，一类是事务安全型，比如InnoDB；其余属于第二类，为非事务安全型</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
<th>Archive</th>
</tr>
</thead>
<tbody><tr>
<td>批量插入速度</td>
<td>高</td>
<td>低</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>事务安全</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>表锁</td>
<td>行锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>存储限制</td>
<td>没有</td>
<td>64TB</td>
<td>有</td>
<td>没有</td>
</tr>
<tr>
<td>支持外键</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>如果不需要事务，处理的只是基本的CRUD操作，那么MyISAM是不二选择，速度快</li>
<li>需要事务就使用InnoDB</li>
<li>Memory存储引擎就是将数据存储在内存中，由于没有磁盘I&#x2F;O的等待，速度极快。但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失</li>
</ul>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>视图是一个虚拟表，其内容由查询定义，<strong>数据来自对应的真实的表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create view view_name as select语句</span><br><span class="line">alter view view_name as select语句</span><br><span class="line">show create view view_name</span><br><span class="line">drop view view_name</span><br></pre></td></tr></table></figure>



<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建用户 user_name是用户名, localhost表示本地地址, password是password()加密后的密码</span><br><span class="line">// 不指定登录地址，则为%，表示所有IP都有连接权限</span><br><span class="line">create user &#x27;user_name&#x27;@&#x27;localhost&#x27; identified by &#x27;password&#x27;; </span><br><span class="line">// 删除用户</span><br><span class="line">drop user &#x27;user_name&#x27;@&#x27;localhost&#x27;</span><br></pre></td></tr></table></figure>



<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 授权</span><br><span class="line">grant 权限列表 on 库.对象名 to &#x27;user_name&#x27;@&#x27;localhost&#x27; [identified by &#x27;password&#x27;];</span><br><span class="line">grant all on ...	//表示赋予该用户在该对象上的所有权限</span><br><span class="line"></span><br><span class="line">*.*: 表示本系统中的所有数据库的所有对象</span><br><span class="line">库.*: 表示某个数据库中的所有对象</span><br><span class="line">identified by 写上如果用户存在则修改密码，不存在会创建用户</span><br><span class="line"></span><br><span class="line">// 回收权限</span><br><span class="line">revoke 权限列表 on 库.对象名 from &#x27;user_name&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>



<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>Java提供一套用于数据库操作的接口</p>
<p>编写JDBC程序步骤：</p>
<ol>
<li><p>注册驱动</p>
</li>
<li><p>获取连接</p>
</li>
<li><p>执行增删改查</p>
<p>Statement对象，用于执行静态SQL语句并返回生成的结果的对象</p>
<p>在连接建立后，需要对数据进行访问，执行命名或是SQL语句，可以通过：</p>
<ul>
<li>Statement	[存在SQL注入]</li>
<li>PrepareStatement  [预处理]</li>
<li>CallableStatement  [存储过程]</li>
</ul>
<p>使用PrepareStatement替代Statement解决SQL注入问题：</p>
<ol>
<li>PrepareStatement执行的sql语句中的参数用<code>?</code>来表示，调用setXxx()方法来设置这些参数</li>
<li>调用executeQuery(), 返回ResultSet对象</li>
<li>调用executeUpdate(), 执行更新，包括增删改</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 执行sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from admin where user=? and password=?&quot;</span>;</span><br><span class="line"><span class="type">PrepareStatement</span> <span class="variable">preparestatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">preparestatement.setString(<span class="number">1</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">preparestatement.setString(<span class="number">2</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//如果执行的是select语句，使用executeQuery</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultset</span> <span class="operator">=</span> preparestatement.executeQuery(); </span><br><span class="line"><span class="comment">// int rows = statement.executeUpdate();//如果是dml语句用executeUpdate(),返回的是影响行数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放资源</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置工作：将mysql-connector-j-8.1.0.jar文件拷贝到目录下，add to project 加入到项目中</span></span><br><span class="line"><span class="comment">// 1. 注册驱动</span></span><br><span class="line"><span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 得到连接(本质是Socket连接) &#x27;jdbc:mysql://&#x27; 表示协议; &#x27;localhost&#x27; 表示主机，可以是IP地址; &#x27;3306&#x27;表示端口号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306//数据库&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> driver.connect(url,properties);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行sql语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into actor values()&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();<span class="comment">//执行sql语句，返回生成结果的对象</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> statement.executeUpdate(sql);<span class="comment">//如果是dml语句返回的是影响行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 释放资源</span></span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接方式2</span></span><br><span class="line"><span class="comment">//使用反射加载Driver类，动态加载，更加灵活，减少依赖性</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver)aClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306//数据库&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url,properties);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接方式3</span></span><br><span class="line"><span class="comment">//使用DriverManager 替代 Driver 进行统一管理</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver)aClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306//数据库&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">DriverManager.registerDriver(driver);<span class="comment">//注册驱动</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式4, 使用最多, 推荐使用</span></span><br><span class="line"><span class="comment">//使用反射加载了Driver类，自动完成注册驱动，简化代码</span></span><br><span class="line"><span class="comment">//因为静态代码块在类加载时会执行一次</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static &#123;</span></span><br><span class="line"><span class="comment">	try &#123;</span></span><br><span class="line"><span class="comment">		DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	catch(...)&#123;</span></span><br><span class="line"><span class="comment">		...</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306//数据库&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式5</span></span><br><span class="line"><span class="comment">//方式4基础上使用Properties配置文件，让连接更加灵活</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path));</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class.forName(driver);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>



<p><strong>事务</strong></p>
<p>JDBC程序中当一个Connection对象创建时，默认情况下自动提交事务：每次执行一个SQL语句时，如果执行成功就会向数据库自动提交，不能回滚</p>
<p>程序中为了让多个SQL语句作为一个整体执行，需要使用事务</p>
<p>调用Connection的 <code>setAutoCommit(false)</code> 可以取消自动提交事务</p>
<p>所有语句执行成功后调用Connection的 <code>commit()</code> 提交事务</p>
<p>在其中某个操作失败或异常时，调用 <code>rollback()</code> 回滚事务</p>
<p><strong>批处理</strong></p>
<p>JDBC连接MySQL时如果要使用批处理，需要在url中加参数 <code>?rewriteBatchedStatements=true</code></p>
<p>批处理往往和PrepareStatement搭配使用，可以减少编译次数和允许次数，提高效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addBatch():添加需要批量处理的SQL语句或参数</span><br><span class="line">executeBatch():执行批量处理语句</span><br><span class="line">clearBatch():清空批处理语句</span><br></pre></td></tr></table></figure>



<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p><strong>数据库连接池种类</strong></p>
<ol>
<li>JDBC数据库连接池使用javax.sql.DataSource来表示，是一个接口，由第三方实现</li>
<li><strong>C3P0 数据库连接池</strong>，速度相对较慢，稳定性不错</li>
<li>DBCP 数据库连接池，相对C3P0较快，不稳定</li>
<li>Proxool 数据库连接池，有监控连接池状态功能，稳定性较C3P0差一点</li>
<li>BoneCP 数据库连接池，速度快</li>
<li><strong>Druid（德鲁伊）数据库连接池</strong>，集2.3.4优点于一身</li>
</ol>
<p><strong>Druid使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 加入 Druid jar包</span></span><br><span class="line"><span class="comment">// 2. 加入 配置文件 druid.properties ,将该文件拷贝到src目录</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    # druid.properties文件的配置</span></span><br><span class="line"><span class="comment">    driverClassName=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">    url=jdbc:mysql://127.0.0.1:3306/数据库?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="comment">    username=root</span></span><br><span class="line"><span class="comment">    password=123456</span></span><br><span class="line"><span class="comment">    # 初始化连接数量</span></span><br><span class="line"><span class="comment">    initialSize=5</span></span><br><span class="line"><span class="comment">    # 最大连接数</span></span><br><span class="line"><span class="comment">    maxActive=10</span></span><br><span class="line"><span class="comment">    # 最大超时时间</span></span><br><span class="line"><span class="comment">    maxWait=3000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 3. 创建Properties对象，读取配置文件</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建数据库连接池</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭连接。不是真正断开, 而是将使用的连接对象放回连接池</span></span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>



<p>**Apache-DBUtils **</p>
<p>commons-dbutils 是Apache提供的一个开源的JDBC工具类，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量</p>
<p>QueryRunner类：封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理</p>
<p>ResultSetHandler接口：用于处理java.sql.ResultSet, 将数据按要求转换为另一种形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayHandler：把结果集中的第一行数据转成对象数组。</span><br><span class="line">ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</span><br><span class="line">BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</span><br><span class="line">BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</span><br><span class="line">ColumnListHandler：将结果集中某一列的数据存放到List中。</span><br><span class="line">KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</span><br><span class="line">MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</span><br><span class="line">MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List</span><br><span class="line">ScalarHandler：对于查询后只有1个结果</span><br></pre></td></tr></table></figure>

<p>使用步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使用druid得到连接</span><br><span class="line">// 2. 引入DBUtils相关的jar包</span><br><span class="line">// 3. 创建QueryRunner类</span><br><span class="line">	QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">// 4. 调用相关方法，返回ArrayList结果集</span><br><span class="line">	connection: 连接</span><br><span class="line">	sql: sql语句</span><br><span class="line">	1: 给sql语句中的 ? 赋值。是可变形参</span><br><span class="line">	new BeanListHandler&lt;&gt;(Actor.class): 使用反射机制获取Actor属性进行封装 ResultSet -&gt; Actor对象 -&gt; ArrayList</span><br><span class="line">	String sql = &quot;select * from actor while id = ?&quot;;</span><br><span class="line">	List&lt;Actor&gt; list = queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(Actor.class),1);</span><br><span class="line">	// dml</span><br><span class="line">	int rows = queryRunner.update(connection, sql, &quot;smith&quot;, 1);</span><br></pre></td></tr></table></figure>



<p><strong>BasicDao</strong></p>
<p>DAO: data access object 数据访问对象</p>
<p>这样的通用类，称为BasicDao，是专门和数据库交互的，即完成数据库crud操作</p>
<p>在BasicDao基础上，实现一张表对应一个Dao，更好的完成功能</p>
<p><img src="https://img-blog.csdnimg.cn/21c72bcb1b674325864b53b730bfa85e.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在dao包下分别建立domain, dao, utils, test四个子包，它们的功能如下——</span><br><span class="line">	dao_ex.domain : 用于存放相关JavaBean类；</span><br><span class="line">	dao_ex.dao : 用于存放XxxDAO 和 BasicDAO；</span><br><span class="line">	dao_ex.utils : 用于存放相关工具类；</span><br><span class="line">	dao_ex.test : 用于存放DAO的测试类。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开发BasicDAO,是其他DAO的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicDAO</span>&lt;T&gt; &#123;<span class="comment">//泛型指定具体的类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">QueryRunner</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开发通用的DML方法，针对任意的表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> qr.update(connection, sql, parameters);</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常，抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回多个对象(即查询的结果是多行)，针对任意表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql        sql语句可以有?号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz      传入一个类的Class对象 比如Actor.class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters 传入? 的具体的值，可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根据Actor.class 返回对应的ArrayList集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">queryMulti</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常，抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行结果的通用方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">querySingle</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常，抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行单列的方法，即返回单值的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryScalar</span><span class="params">(String sql, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>(), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常，抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Actor对象 和 actor表的记录对应</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Actor</span> &#123;<span class="comment">//JavaBean ,POJO,Domain对象</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Date borndate;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Actor</span><span class="params">()</span> &#123;<span class="comment">//一定要给一个无参构造器[反射需要]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Actor</span><span class="params">(Integer id, String name, String sex, Date borndate, String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.borndate = borndate;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getBorndate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> borndate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBorndate</span><span class="params">(Date borndate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.borndate = borndate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Actor&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, borndate=&quot;</span> + borndate +</span><br><span class="line">                <span class="string">&quot;, phone=&#x27;&quot;</span> + phone + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDAO</span> &#123;</span><br><span class="line">    <span class="comment">//测试ActorDAO 对Actor表的crud操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testActorDAO</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ActorDAO</span> <span class="variable">actorDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActorDAO</span>();</span><br><span class="line">        <span class="comment">//1.查询多行记录</span></span><br><span class="line">        List&lt;Actor&gt; actors = actorDAO.queryMulti(<span class="string">&quot;SELECT * FROM actor WHERE id &gt;= ?&quot;</span>, Actor.class, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===查询结果===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Actor actor : actors) &#123;</span><br><span class="line">            System.out.println(actor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询单行记录</span></span><br><span class="line">        <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> actorDAO.querySingle(<span class="string">&quot;SELECT * FROM actor WHERE id = ?&quot;</span>, Actor.class, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===查询单行结果===&quot;</span>);</span><br><span class="line">        System.out.println(actor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询单行单例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> actorDAO.queryScalar(<span class="string">&quot;SELECT name FROM actor WHERE id = ?&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===查询单行单列===&quot;</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DML操作 (insert,delete,update)</span></span><br><span class="line"><span class="comment">//        int affectedRows = actorDAO.update(&quot;UPDATE actor SET NAME=? WHERE id = ?&quot;, &quot;林青霞&quot;, 2);</span></span><br><span class="line"><span class="comment">//        int affectedRows = actorDAO.update(&quot;INSERT INTO actor VALUES(NULL,?,?,?,?)&quot;, &quot;许三多&quot;, &quot;男&quot;,&quot;1999-01-01&quot;,&quot;123456&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> actorDAO.update(<span class="string">&quot;DELETE FROM actor WHERE id = ?&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(affectedRows &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行没有影响表&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. \\d表示任意一个数字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regexp</span> <span class="operator">=</span> <span class="string">&quot;\\d\\d\\d\\d&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建模式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regexp,Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建匹配器</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 开始匹配</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* matcher.find() 完成的任务</span></span><br><span class="line"><span class="comment">* 1. 根据指定规则，定位满足规则的子字符串</span></span><br><span class="line"><span class="comment">* 2. 找到后将子字符串的开始索引记录到 matcher 对象的属性 int[] groups;</span></span><br><span class="line"><span class="comment">*    groups[0]记录开始索引, 把结束索引+1的值记录到 groups[1]中</span></span><br><span class="line"><span class="comment">* 3. 同时记录 oldLast 的值为：子字符串结束索引+1的值. 下次执行 find() 从此开始匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 考虑分组 正则表达式中含小括号即表示分组: String regexp = &quot;(\\d\\d)(\\d\\d)&quot;;</span></span><br><span class="line"><span class="comment">* groups[0]记录开始索引, 把结束索引+1的值记录到 groups[1]中</span></span><br><span class="line"><span class="comment">* groups[2]记录第一组开始索引, groups[3]记录第一组结束索引+1的值</span></span><br><span class="line"><span class="comment">* 依次类推...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* public String group(int group) &#123;</span></span><br><span class="line"><span class="comment">*    checkMatch();</span></span><br><span class="line"><span class="comment">*    checkGroup(group);</span></span><br><span class="line"><span class="comment">*    if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span></span><br><span class="line"><span class="comment">*        return null;</span></span><br><span class="line"><span class="comment">*    return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">	System.out.println(matcher.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转义：\\	在java的正则表达式中\\代表其他语言中的一个\</span><br><span class="line">		  需要用到转义符号的字符：., *, +, (, ), /, \, ?, [, ], ^, &#123;, &#125;	</span><br></pre></td></tr></table></figure>

<p><strong>匹配符</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>可接收的字符列表</td>
<td>[efgh]</td>
<td>efgh中的任意字符</td>
</tr>
<tr>
<td>[^]</td>
<td>不可接收的字符列表</td>
<td>[^abc]</td>
<td>abc除外的任意字符</td>
</tr>
<tr>
<td>-</td>
<td>连字符</td>
<td>A-Z</td>
<td>任意大写字母</td>
</tr>
<tr>
<td>.</td>
<td>匹配除\n之外的任何字符</td>
<td>a..b</td>
<td>a开头b结尾中间任意两个字符的字符串</td>
</tr>
<tr>
<td>\\d</td>
<td>匹配单个数字字符，相当于[0-9]</td>
<td>\\d{3}(\\d)?</td>
<td>包含3个或4个数字的字符串</td>
</tr>
<tr>
<td>\\D</td>
<td>匹配单个非数字字符</td>
<td>\\D(\\d)*</td>
<td>以单个非数字字符开头，后接任意个数字字符的字符串</td>
</tr>
<tr>
<td>\\w</td>
<td>匹配单个数字、大小写字母字符、下划线<br>相当于[0-9a-zA-Z]</td>
<td>\\d{3}\\w{4}</td>
<td>以3个数字字符开头长度为7的数字字符串</td>
</tr>
<tr>
<td>\\W</td>
<td>匹配单个非数字、大小写字母字符、下划线<br/>相当于[ ^0-9a-zA-Z]</td>
<td>\\W+\\d{2}</td>
<td>以至少1个非数字字母字符开头，2个数字字符结尾的字符串</td>
</tr>
<tr>
<td>\\s</td>
<td>匹配任何空白字符（空格、制表符等）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>\\S</td>
<td>匹配任何非空白字符</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>选择匹配符</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>选择匹配符,匹配之前或之后的</td>
<td>ab|cd</td>
<td>ab或cd</td>
</tr>
<tr>
<td><strong>限定符</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>指定字符重复0次或n次</td>
<td>(abc)*</td>
<td>包含任意个abc的字符串</td>
</tr>
<tr>
<td>+</td>
<td>指定字符重复1次或n次</td>
<td>m+(abc)*</td>
<td>以至少1个m开头，后接任意个abc的字符串</td>
</tr>
<tr>
<td>？</td>
<td>指定字符重复0次或1次</td>
<td>m+abc?</td>
<td>以m开头，后接ab或abc的字符串</td>
</tr>
<tr>
<td>{n}</td>
<td>只能输入n个字符</td>
<td>[abcd]{3}</td>
<td>由abcd中字母组成的任意长度为3的字符串</td>
</tr>
<tr>
<td>{n, }</td>
<td>指定至少n个匹配</td>
<td>[abcd]{3, }</td>
<td>由abcd中字母组成的任意长度至少为3的字符串</td>
</tr>
<tr>
<td>{n, m}</td>
<td>指定至少n个但不多于m个匹配，尽可能匹配多的（贪婪匹配）</td>
<td>[abcd]{3, 5}</td>
<td>由abcd中字母组成的任意长度至少为3但不大于5的字符串</td>
</tr>
<tr>
<td>？</td>
<td>非贪婪匹配，限定符后加 ？</td>
<td>\\d+?</td>
<td>至少一个数字字符的字符串，尽可能匹配少的</td>
</tr>
<tr>
<td><strong>定位符</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>指定起始字符</td>
<td>^[0-9]+[a-z]*</td>
<td>以至少1个数字开头，后接任意个小写字母的字符串</td>
</tr>
<tr>
<td>$</td>
<td>指定结束字符</td>
<td>^[0-9]\\-[a-z]+$</td>
<td>以1个数字开头后接’-‘，并以至少一个小写字母结尾的字符串</td>
</tr>
<tr>
<td>\\b</td>
<td>匹配目标字符串的边界</td>
<td>han\\b</td>
<td>边界指子串间有空格或是目标字符串的结束位置</td>
</tr>
<tr>
<td>\\B</td>
<td>匹配目标字符串的非边界</td>
<td>han\\B</td>
<td></td>
</tr>
</tbody></table>
<p><strong>java正则表达式默认区分大小写，实现不区分大小写：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.</span><br><span class="line">(?i)abc		表示abc都不区分大小写</span><br><span class="line">a(?i)bc		表示bc不区分大小写</span><br><span class="line">a((?i)b)c	表示b不区分大小写</span><br><span class="line"></span><br><span class="line">// 2.</span><br><span class="line">Pattern pattern = Pattern.compile(regexp,Pattern.CASE_INSENSITIVE);</span><br></pre></td></tr></table></figure>



<p><strong>分组</strong></p>
<table>
<thead>
<tr>
<th>常用分组构造形式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(pattern)</td>
<td>非命名捕获。捕获匹配的子字符串，编号为0的第一个捕获是整个正则表达式模式匹配的文本，其他捕获结果根据左括号的顺序从1开始自动编号</td>
</tr>
<tr>
<td>(?&lt;name&gt;pattern)</td>
<td>命名捕获。将匹配子字符串捕获到一个组名称过编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头，可以使用单引号替代尖括号，例如 ?’name’</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配但是不捕获子字符串，是一个非捕获匹配，不存储供以后使用的匹配。这对于用or字符(|)组合模式部件的情况很有用。例如 ‘industr(?:y|ies)’ 是比 ‘industry|industries’ 更经济的表达式</td>
</tr>
<tr>
<td>(?&#x3D;pattern)</td>
<td>非捕获匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配 “Windows 2000” 中的 “Windows”，但是不匹配 “Windows 3.1” 中的 “Windows”</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>非捕获匹配。例如，’Windows (!&#x3D;95|98|NT|2000’ 匹配 “Windows 3.1” 中的”Windows”, 但是不匹配”Windows 2000” 中的”Windows”</td>
</tr>
</tbody></table>
<p><strong>反向引用</strong></p>
<p>圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以是正则表达式内部，也可以是在正则表达式外部，内部反向引用<code>\\分组号</code>，外部反向引用<code>$分组号</code> </p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/20/fen-bu-shi-xi-tong-yu-shi-xu-shu-ju-ku/" title="分布式系统与时序数据库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式系统与时序数据库</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/28/git/" title="Git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RonronnerW</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RonronnerW"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RonronnerW" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/wlbin_1019@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/2568998391" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.</span> <span class="toc-text">IDEA常用快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">2.</span> <span class="toc-text">JAVA开发注意事项和细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">引用数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E9%94%AE%E5%85%A5"><span class="toc-number">6.</span> <span class="toc-text">键盘键入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">JAVA内存结构分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.</span> <span class="toc-text">this关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">12.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">13.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">14.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">15.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">16.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-x2F-%E8%A6%86%E7%9B%96"><span class="toc-number">17.</span> <span class="toc-text">方法重写&#x2F;覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">18.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">18.1.</span> <span class="toc-text">动态绑定机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">18.2.</span> <span class="toc-text">多态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">18.3.</span> <span class="toc-text">多态参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">19.</span> <span class="toc-text">&#x3D;&#x3D;运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-number">20.</span> <span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">21.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F-x2F-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">21.1.</span> <span class="toc-text">类变量&#x2F;静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95-x2F-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">21.2.</span> <span class="toc-text">类方法&#x2F;静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">main方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">23.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">24.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">25.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">27.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">27.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">27.2.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">27.3.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">27.4.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">27.5.</span> <span class="toc-text">静态内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">28.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">29.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">30.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%88Wrapper%E7%B1%BB%EF%BC%89"><span class="toc-number">31.</span> <span class="toc-text">包装类（Wrapper类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">32.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BBCalendar"><span class="toc-number">32.1.</span> <span class="toc-text">第二代日期类Calendar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">32.2.</span> <span class="toc-text">第三代日期类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">33.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">33.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-number">33.2.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList"><span class="toc-number">33.3.</span> <span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">34.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-number">34.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">34.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">34.3.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">35.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">35.1.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashtable"><span class="toc-number">35.2.</span> <span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-number">35.3.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">35.4.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections"><span class="toc-number">36.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">37.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">38.</span> <span class="toc-text">线程基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">39.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">39.1.</span> <span class="toc-text">节点流和处理流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-ObjectOutputStream-x2F-ObjectInputStream"><span class="toc-number">39.2.</span> <span class="toc-text">序列化和反序列化 ObjectOutputStream&#x2F;ObjectInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81-InputStreamReader-x2F-OutputStreamReader"><span class="toc-number">39.3.</span> <span class="toc-text">转换流 InputStreamReader&#x2F;OutputStreamReader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">40.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%AD%97%E8%8A%82%E6%B5%81%E7%BC%96%E7%A8%8B"><span class="toc-number">40.1.</span> <span class="toc-text">TCP字节流编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%AD%97%E7%AC%A6%E6%B5%81%E7%BC%96%E7%A8%8B"><span class="toc-number">40.2.</span> <span class="toc-text">TCP字符流编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">41.</span> <span class="toc-text">反射机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">42.</span> <span class="toc-text">Class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">43.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">44.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="toc-number">44.1.</span> <span class="toc-text">修改表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CRUD"><span class="toc-number">44.2.</span> <span class="toc-text">CRUD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">44.3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">44.3.1.</span> <span class="toc-text">字符串函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">44.3.2.</span> <span class="toc-text">数学函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">44.3.3.</span> <span class="toc-text">日期函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0"><span class="toc-number">44.3.4.</span> <span class="toc-text">加密函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="toc-number">44.3.5.</span> <span class="toc-text">流程控制函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">44.4.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E9%94%AE"><span class="toc-number">44.4.1.</span> <span class="toc-text">外键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%95%BF"><span class="toc-number">44.4.2.</span> <span class="toc-text">自增长</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">44.5.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">44.6.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">44.7.</span> <span class="toc-text">表类型和存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">44.8.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">44.9.</span> <span class="toc-text">用户管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">44.10.</span> <span class="toc-text">权限管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC"><span class="toc-number">45.</span> <span class="toc-text">JDBC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">46.</span> <span class="toc-text">连接池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">47.</span> <span class="toc-text">正则表达式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/06/mybatis-plus/" title="MyBatis-Plus">MyBatis-Plus</a><time datetime="2023-11-06T01:15:34.000Z" title="发表于 2023-11-06 09:15:34">2023-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/04/eureka/" title="无题">无题</a><time datetime="2023-11-04T06:15:30.685Z" title="发表于 2023-11-04 14:15:30">2023-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/02/swagger/" title="swagger">swagger</a><time datetime="2023-11-02T14:38:37.000Z" title="发表于 2023-11-02 22:38:37">2023-11-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/28/rocketmq/" title="RocketMQ">RocketMQ</a><time datetime="2023-10-28T14:32:15.000Z" title="发表于 2023-10-28 22:32:15">2023-10-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By RonronnerW</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2023/09/14/java/'
    this.page.identifier = '/2023/09/14/java/'
    this.page.title = 'Java'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>