<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaWeb | RonronnerW</title><meta name="author" content="RonronnerW"><meta name="copyright" content="RonronnerW"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TomcatTomcat 版本和Servlet版本之间的对应关系    Servlet Version **Tomcat ** Version JDK Version    6.1 11.0.x 17 and later   6.0 10.1.x 11 and later   5.0 10.0.x (superseded) 8 and later   4.0 9.0.x 8 and later">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaWeb">
<meta property="og:url" content="http://example.com/2023/11/21/javaweb/index.html">
<meta property="og:site_name" content="RonronnerW">
<meta property="og:description" content="TomcatTomcat 版本和Servlet版本之间的对应关系    Servlet Version **Tomcat ** Version JDK Version    6.1 11.0.x 17 and later   6.0 10.1.x 11 and later   5.0 10.0.x (superseded) 8 and later   4.0 9.0.x 8 and later">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-11-21T11:09:38.000Z">
<meta property="article:modified_time" content="2023-11-30T09:02:51.268Z">
<meta property="article:author" content="RonronnerW">
<meta property="article:tag" content="JavaWeb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/11/21/javaweb/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: RonronnerW","link":"链接: ","source":"来源: RonronnerW","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaWeb',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-11-30 17:02:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-poo"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="RonronnerW"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">RonronnerW</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-poo"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaWeb</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-21T11:09:38.000Z" title="发表于 2023-11-21 19:09:38">2023-11-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-30T09:02:51.268Z" title="更新于 2023-11-30 17:02:51">2023-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaWeb/">JavaWeb</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaWeb"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p><strong>Tomcat 版本和Servlet版本之间的对应关系</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>Servlet</strong> Version</th>
<th align="left">**Tomcat ** Version</th>
<th align="left"><strong>JDK</strong> Version</th>
</tr>
</thead>
<tbody><tr>
<td align="left">6.1</td>
<td align="left">11.0.x</td>
<td align="left">17 and later</td>
</tr>
<tr>
<td align="left">6.0</td>
<td align="left">10.1.x</td>
<td align="left">11 and later</td>
</tr>
<tr>
<td align="left">5.0</td>
<td align="left">10.0.x (superseded)</td>
<td align="left">8 and later</td>
</tr>
<tr>
<td align="left">4.0</td>
<td align="left">9.0.x</td>
<td align="left">8 and later</td>
</tr>
<tr>
<td align="left">3.1</td>
<td align="left">8.5.x</td>
<td align="left">7 and later</td>
</tr>
<tr>
<td align="left">3.1</td>
<td align="left">8.0.x (superseded)</td>
<td align="left">7 and later</td>
</tr>
<tr>
<td align="left">3.0</td>
<td align="left">7.0.x (archived)</td>
<td align="left">6 and later (7 and later for WebSocket)</td>
</tr>
</tbody></table>
<p>Tomcat官方网站：<a target="_blank" rel="noopener" href="http://tomcat.apache.org/" title="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p>
<ul>
<li>安装版：需要安装，一般不考虑使用。</li>
<li>解压版: 直接解压缩使用，我们使用的版本。</li>
</ul>
<p><strong>目录</strong></p>
<ul>
<li><p>bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat10.exe、tomcat10w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat；</p>
</li>
<li><p>conf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：</p>
<ul>
<li><p><strong>server.xml：配置整个服务器信息。例如修改端口号。默认HTTP请求的端口号是：8080</strong></p>
</li>
<li><p>tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；</p>
</li>
<li><p>web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text&#x2F;html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的！</p>
</li>
<li><p>context.xml：对所有应用的统一配置，通常我们不会去配置它。</p>
</li>
</ul>
</li>
<li><p>lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下；</p>
</li>
<li><p>logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。</p>
</li>
<li><p>temp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！</p>
</li>
<li><p><strong>webapps：存放web项目的目录，其中每个文件夹都是一个项目</strong>；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中访问：<a href="http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目。其中examples"就是项目名，即文件夹的名字。">http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目。其中examples&quot;就是项目名，即文件夹的名字。</a></p>
<ul>
<li>app  本应用根目录<ul>
<li>static 非必要目录,约定俗成的名字,一般在此处放静态资源 ( css  js  img)</li>
<li>WEB-INF  必要目录,必须叫WEB-INF,受保护的资源目录,浏览器通过url不可以直接访问的目录<ul>
<li>classes     必要目录,src下源代码,配置文件,编译后会在该目录下,web项目中如果没有源码,则该目录不会出现</li>
<li>lib             必要目录,项目依赖的jar编译后会出现在该目录下,web项目要是没有依赖任何jar,则该目录不会出现</li>
<li>web.xml   必要文件,web项目的基本配置文件. 较新的版本中可以没有该文件,但是学习过程中还是需要该文件</li>
</ul>
</li>
<li>index.html  非必要文件,index.html&#x2F;index.htm&#x2F;index.jsp为默认的欢迎页</li>
</ul>
</li>
</ul>
</li>
<li><p>work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。</p>
</li>
<li><p>LICENSE：许可证。</p>
</li>
<li><p>NOTICE：说明文件。</p>
</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><blockquote>
<p> HTTP&#x2F;1.0</p>
</blockquote>
<ul>
<li>1996 年，HTTP&#x2F;1.0 发布。该规范是显著扩大，并且支持三种请求方法：GET，Head，和POST。 </li>
<li>HTTP&#x2F;1.0 相对于 HTTP&#x2F;0.9 的改进如下：<ul>
<li>每个请求都附加了 HTTP 版本。</li>
<li>在响应开始时发送状态代码。</li>
<li>请求和响应都包含 HTTP 报文头。</li>
<li>内容类型能够传输 HTML 文件以外的文档。</li>
</ul>
</li>
<li>但是，HTTP&#x2F;1.0 不是官方标准。</li>
</ul>
<blockquote>
<p>HTTP&#x2F;1.1</p>
</blockquote>
<ul>
<li><p>HTTP 的第一个标准化版本 HTTP&#x2F;1.1 ( RFC 2068 ) 于 1997 年初发布，支持七种请求方法：OPTIONS，GET，HEAD，POST，PUT，DELETE，和TRACE </p>
</li>
<li><p>HTTP&#x2F;1.1 是 HTTP 1.0 的增强：</p>
<ul>
<li><p>虚拟主机允许从单个 IP 地址提供多个域。</p>
</li>
<li><p><strong>持久连接</strong>和流水线连接允许 Web 浏览器通过单个持久连接发送多个请求。</p>
</li>
<li><p><strong>缓存</strong>支持节省了带宽并使响应速度更快。</p>
</li>
</ul>
</li>
<li><p>HTTP&#x2F;1.1 在接下来的 15 年左右将非常稳定。 </p>
</li>
<li><p>在此期间，出现了 HTTPS（安全超文本传输协议）。它是使用 SSL&#x2F;TLS 进行安全加密通信的 HTTP 的安全版本。</p>
</li>
</ul>
<p><strong>请求报文格式</strong></p>
<ul>
<li>请求首行（<strong>请求行</strong>）；    GET&#x2F;POST   资源路径?参数   HTTP&#x2F;1.1</li>
<li>请求头信息（<strong>请求头</strong>）；</li>
<li>空行；</li>
<li>请求体；POST请求才有请求体</li>
</ul>
<p><strong>响应报文格式</strong></p>
<ul>
<li>响应首行（<strong>响应行</strong>）； 协议&#x2F;版本  状态码    状态码描述</li>
<li>响应头信息（<strong>响应头</strong>）；</li>
<li>空行；</li>
<li>响应体；</li>
</ul>
<p><strong>常见响应码</strong></p>
<ul>
<li><strong>200：</strong> 请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；</li>
<li><strong>302：</strong> 重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location指定新请求的URL地址；</li>
<li><strong>304：</strong> 使用了本地缓存</li>
<li><strong>404：</strong> 请求的资源没有找到，说明客户端错误的请求了不存在的资源；</li>
<li><strong>405：</strong> 请求的方式不允许</li>
<li><strong>500：</strong> 请求资源找到了，但服务器内部出现了错误；</li>
</ul>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的<strong>控制器</strong></p>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><ol>
<li>客户端发送请求报文</li>
<li>tomcat接收到请求后，会将请求报文的信息转换为一个HttpServiceRequest 对象，该对象包含了请求中的所有信息</li>
<li>tomcat同时创建一个HttpServiceResponse 对象，该对象用于承装要响应给客户端的信息，然后该对象装换为响应报文</li>
<li>tomcat根据请求中的资源路径找到对象的servlet，将servlet实例化，调用service方法，同时将HttpServiceRequest 和HttpServiceResponse 对象传入</li>
<li>服务端返回响应报文</li>
</ol>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ol>
<li><p>创建JavaWeb项目，同时将tomcat添加为当前项目依赖</p>
</li>
<li><p>自定义一个类,要继承HttpServlet类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span>  <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;atguigu&quot;</span>.equals(username))&#123;</span><br><span class="line">            <span class="comment">//通过响应对象响应信息</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重写service方法,该方法主要就是用于处理用户请求的服务方法</p>
</li>
<li><p>HttpServletRequest 代表请求对象,是有请求报文经过tomcat转换而来的,通过该对象可以获取请求中的信息</p>
</li>
<li><p>HttpServletResponse 代表响应对象,该对象会被tomcat转换为响应的报文,通过该对象可以设置响应中的信息</p>
</li>
<li><p>Servlet对象的生命周期(创建,初始化,处理服务,销毁)是由tomcat管理的,无需我们自己new</p>
</li>
<li><p>HttpServletRequest HttpServletResponse 两个对象也是有tomcat负责转换,在调用service方法时传入给我们用的</p>
</li>
</ul>
</li>
<li><p>在web.xml为UseServlet配置请求的映射路径</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给UserServlet起一个别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.UserServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联别名和映射路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以为一个Servlet匹配多个不同的映射路径,但是不同的Servlet不能使用相同的url-pattern--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/userServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;url-pattern&gt;/userServlet2&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            /        表示通配所有资源,不包括jsp文件</span></span><br><span class="line"><span class="comment">            /*       表示通配所有资源,包括jsp文件</span></span><br><span class="line"><span class="comment">            /a/*     匹配所有以a前缀的映射路径</span></span><br><span class="line"><span class="comment">            *.action 匹配所有以action为后缀的映射路径</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Servlet并不是文件系统中实际存在的文件或者目录,所以为了能够请求到该资源,我们需要为其配置映射路径</li>
<li>servlet的请求映射路径配置在web.xml中</li>
<li>servlet-name作为servlet的别名,可以自己随意定义,见名知意就好</li>
<li>url-pattern标签用于定义Servlet的请求映射路径</li>
<li>一个servlet可以对应多个不同的url-pattern</li>
<li>多个servlet不能使用相同的url-pattern</li>
<li>url-pattern中可以使用一些通配写法<ul>
<li>&#x2F;        表示通配所有资源,不包括jsp文件</li>
<li>&#x2F;*      表示通配所有资源,包括jsp文件</li>
<li>&#x2F;a&#x2F;*     匹配所有以a前缀的映射路径</li>
<li>*.action 匹配所有以action为后缀的映射路径</li>
</ul>
</li>
</ul>
<p><strong>推荐使用@WebServlet注解替换Servlet配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">        name = &quot;userServlet&quot;, /*别名*/</span></span><br><span class="line"><span class="meta">        //value = &quot;/user&quot;, /*映射路径*/</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/userServlet1&quot;,&quot;/userServlet2&quot;,&quot;/userServlet&quot;&#125;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name = &quot;encoding&quot;,value = &quot;UTF-8&quot;)&#125;,/*配置初始参数*/</span></span><br><span class="line"><span class="meta">        loadOnStartup = 6</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span>  <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> getServletConfig().getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        System.out.println(encoding);</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;atguigu&quot;</span>.equals(username))&#123;</span><br><span class="line">            <span class="comment">//通过响应对象响应信息</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>测试</p>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><table>
<thead>
<tr>
<th>生命周期</th>
<th>对应方法</th>
<th>执行时机</th>
<th>执行次数</th>
</tr>
</thead>
<tbody><tr>
<td>构造对象</td>
<td>构造器</td>
<td>第一次请求或者容器启动</td>
<td>1</td>
</tr>
<tr>
<td>初始化</td>
<td>init()</td>
<td>构造完毕后</td>
<td>1</td>
</tr>
<tr>
<td>处理服务</td>
<td>service(HttpServletRequest req,HttpServletResponse resp)</td>
<td>每次请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁</td>
<td>destory()</td>
<td>容器关闭</td>
<td>1</td>
</tr>
</tbody></table>
<p>Servlet对象在容器中是单例的</p>
<p>容器是可以处理并发的用户请求的,每个请求在容器中都会开启一个线程</p>
<p>多个线程可能会使用相同的Servlet对象,所以在Servlet中,我们<strong>不要轻易定义一些容易经常发生修改的成员变量</strong>，会引发线程安全问题</p>
<p>load-on-startup中定义的正整数表示启动时实例化顺序,如果数字重复了,容器会自行解决实例化顺序问题,但是应该避免重复。默认值是-1，表示启动时不会实例化</p>
<p>Tomcat容器中,已经定义了一些随系统启动实例化的servlet,我们自定义的servlet的load-on-startup尽量不要占用数字1-5</p>
<h3 id="Servlet继承结构"><a href="#Servlet继承结构" class="headerlink" title="Servlet继承结构"></a>Servlet继承结构</h3><h4 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h4><p>Servlet 规范接口,所有的Servlet必须实现 </p>
<ul>
<li>public void init(ServletConfig config) throws ServletException;   <ul>
<li>初始化方法,容器在构造servlet对象后,自动调用的方法,容器负责实例化一个ServletConfig对象,并在调用该方法时传入</li>
<li>ServletConfig对象可以为Servlet 提供初始化参数</li>
</ul>
</li>
<li>public ServletConfig getServletConfig();<ul>
<li>获取ServletConfig对象的方法,后续可以通过该对象获取Servlet初始化参数</li>
</ul>
</li>
<li>public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;<ul>
<li>处理请求并做出响应的服务方法,每次请求产生时由容器调用</li>
<li>容器创建一个ServletRequest对象和ServletResponse对象,容器在调用service方法时,传入这两个对象</li>
</ul>
</li>
<li>public String getServletInfo();<ul>
<li>获取ServletInfo信息的方法</li>
</ul>
</li>
<li>public void destroy();<ul>
<li>Servlet实例在销毁之前调用的方法</li>
</ul>
</li>
</ul>
<h4 id="GenericServlet-抽象类"><a href="#GenericServlet-抽象类" class="headerlink" title="GenericServlet 抽象类"></a>GenericServlet 抽象类</h4><p>GenericServlet 抽象类是对Servlet接口一些固定功能的粗糙实现,以及对service方法的再次抽象声明,并定义了一些其他相关功能方法</p>
<ul>
<li>private transient ServletConfig config：初始化配置对象作为属性</li>
<li>public GenericServlet() { } ：构造器,为了满足继承而准备</li>
<li>public void destroy() { } ：销毁方法的平庸实现</li>
<li>public String getInitParameter(String name) ：获取初始参数的快捷方法</li>
<li>public Enumeration<String> getInitParameterNames() ：返回所有初始化参数名的方法</li>
<li>public ServletConfig getServletConfig()：获取初始Servlet初始配置对象ServletConfig的方法</li>
<li>public ServletContext getServletContext()：获取上下文对象ServletContext的方法</li>
<li>public String getServletInfo() ：获取Servlet信息的平庸实现</li>
<li>public void init(ServletConfig config) throws ServletException() ：初始化方法的实现,并在此调用了init的重载方法</li>
<li>public void init() throws ServletException ：<strong>重载init方法,为了让我们自己定义初始化功能的方法</strong></li>
<li>public void log(String msg) </li>
<li>public void log(String message, Throwable t)：打印日志的方法及重载</li>
<li>public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException：<strong>服务方法再次声明</strong></li>
<li>public String getServletName() ：获取ServletName的方法</li>
</ul>
<h4 id="HttpServlet-抽象类"><a href="#HttpServlet-抽象类" class="headerlink" title="HttpServlet 抽象类"></a>HttpServlet 抽象类</h4><p>abstract class HttpServlet extends GenericServlet  HttpServlet抽象类,除了基本的实现以外,增加了更多的基础功能</p>
<ul>
<li><p>public HttpServlet() {}</p>
<ul>
<li>构造器,用于处理继承</li>
</ul>
</li>
<li><p>public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException</p>
<ul>
<li>对服务方法的实现</li>
<li>在该方法中,将请求和响应对象转换成对应HTTP协议的HttpServletRequest HttpServletResponse对象</li>
<li>调用重载的service方法</li>
</ul>
</li>
<li><p>public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException</p>
<ul>
<li>重载的service方法,被重写的service方法所调用</li>
<li>在该方法中,通过请求方式判断,调用具体的do***方法完成请求的处理</li>
</ul>
</li>
<li><p>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p>
</li>
<li><p>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p>
</li>
<li><p>protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p>
</li>
<li><p>protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p>
</li>
<li><p>protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p>
</li>
<li><p>protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p>
</li>
<li><p>protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException</p>
<p>对应不同请求方式的处理方法</p>
<p>除了doOptions和doTrace方法,其他的do*** 方法都在故意响应错误信息。如果不重写自己的service方法都会调用这些方法而故意响应405错误信息</p>
<p>自定义Servlet中,必须要对处理请求的方法进行重写，要么重写service方法，要么重写do***方法</p>
</li>
</ul>
<h3 id="ServletConfig和ServletContext"><a href="#ServletConfig和ServletContext" class="headerlink" title="ServletConfig和ServletContext"></a>ServletConfig和ServletContext</h3><h4 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h4><p>为Servlet提供初始配置参数的一种对象,<strong>每个Servlet都有自己独立唯一的ServletConfig对象</strong></p>
<p>容器会为**每个Servlet实例化一个ServletConfig对象,**并通过Servlet生命周期的init方法传入给Servlet作为属性</p>
<p>使用 @WebServlet 注解的initParams配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">        name = &quot;userServlet&quot;, /*别名*/</span></span><br><span class="line"><span class="meta">        //value = &quot;/user&quot;, /*映射路径*/</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/userServlet1&quot;,&quot;/userServlet2&quot;,&quot;/userServlet&quot;&#125;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name = &quot;encoding&quot;,value = &quot;UTF-8&quot;)&#125;,/*配置初始参数*/</span></span><br><span class="line"><span class="meta">        loadOnStartup = 6</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>



<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>容器会为每个app创建一个独立的唯一的ServletContext对象</p>
<p>ServletContext对象<strong>为所有的Servlet所共享</strong></p>
<p>ServletContext可以<strong>为所有的Servlet提供初始配置参数</strong></p>
<p>配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>paramA<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>valueA<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>paramB<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>valueB<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>获取资源的真实路径</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;资源在web目录中的路径&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>例如我们的目标是需要获取项目中某个静态资源的路径，不是工程目录中的路径，而是<strong>部署目录中的路径</strong>；我们如果直接拷贝其在我们电脑中的完整路径的话其实是有问题的，因为如果该项目以后部署到公司服务器上的话，路径肯定是会发生改变的，所以我们需要使用代码动态获取资源的真实路径.  只要使用了servletContext动态获取资源的真实路径，<strong>那么无论项目的部署路径发生什么变化，都会动态获取项目运行时候的实际路径</strong>，所以就不会发生由于写死真实路径而导致项目部署位置改变引发的路径错误问题</li>
</ul>
<p><strong>获取项目的上下文路径</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> servletContext.getContextPath();</span><br></pre></td></tr></table></figure>

<ul>
<li>项目的部署名称,也叫项目的上下文路径,在部署进入tomcat时所使用的路径,该路径是可能发生变化的,通过该API动态获取项目真实的上下文路径,可以<strong>帮助我们解决一些后端页面渲染技术或者请求转发和响应重定向中的路径问题</strong></li>
</ul>
<p><strong>域对象的相关API</strong></p>
<ul>
<li>域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同</li>
<li>ServletContext代表应用,所以ServletContext域也叫作应用域,是webapp中最大的域,可以在本应用内实现数据的共享和传递</li>
<li>webapp中的三大域对象,分别是应用域,会话域,请求域</li>
<li>三大域对象都具有的API如下</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>void setAttribute(String key,Object value);</td>
<td>向域中存储&#x2F;修改数据</td>
</tr>
<tr>
<td>Object getAttribute(String key);</td>
<td>获得域中的数据</td>
</tr>
<tr>
<td>void removeAttribute(String key);</td>
<td>移除域中的数据</td>
</tr>
</tbody></table>
<h2 id="HttpServiceRequest"><a href="#HttpServiceRequest" class="headerlink" title="HttpServiceRequest"></a>HttpServiceRequest</h2><p>获取请求行信息相关(方式,请求的url,协议及版本)</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuffer getRequestURL();</td>
<td>获取客户端请求资源的完整路径，统一资源定位符</td>
</tr>
<tr>
<td>String getRequestURI();</td>
<td>获取客户端请求资源的路径，统一资源标识符</td>
</tr>
<tr>
<td>int getServerPort();</td>
<td>获取客户端发送请求时的端口</td>
</tr>
<tr>
<td>int getLocalPort();</td>
<td>获取本应用在所在容器的端口</td>
</tr>
<tr>
<td>int getRemotePort();</td>
<td>获取客户端程序的端口</td>
</tr>
<tr>
<td>String getScheme();</td>
<td>获取请求协议</td>
</tr>
<tr>
<td>String getProtocol();</td>
<td>获取请求协议及版本号</td>
</tr>
<tr>
<td>String getMethod();</td>
<td>获取请求方式</td>
</tr>
</tbody></table>
<p>获得请求头信息相关</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>String getHeader(String headerName);</td>
<td>根据头名称获取请求头</td>
</tr>
<tr>
<td>Enumeration<String> getHeaderNames();</td>
<td>获取所有的请求头名字</td>
</tr>
<tr>
<td>String getContentType();</td>
<td>获取content-type请求头</td>
</tr>
</tbody></table>
<p>获得请求参数相关</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>String getParameter(String parameterName);</td>
<td>根据请求参数名获取请求单个参数值</td>
</tr>
<tr>
<td>String[] getParameterValues(String parameterName);</td>
<td>根据请求参数名获取请求多个参数值数组</td>
</tr>
<tr>
<td>Enumeration<String> getParameterNames();</td>
<td>获取所有请求参数名</td>
</tr>
<tr>
<td>Map&lt;String, String[]&gt; getParameterMap();</td>
<td>获取所有请求参数的键值对集合</td>
</tr>
<tr>
<td>BufferedReader getReader() throws IOException;</td>
<td>获取读取请求体的字符输入流</td>
</tr>
<tr>
<td>ServletInputStream getInputStream() throws IOException;</td>
<td>获取读取请求体的字节输入流</td>
</tr>
<tr>
<td>int getContentLength();</td>
<td>获得请求体长度的字节数</td>
</tr>
</tbody></table>
<p>其他API</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>String getServletPath();</td>
<td>获取请求的Servlet的映射路径</td>
</tr>
<tr>
<td>ServletContext getServletContext();</td>
<td>获取ServletContext对象</td>
</tr>
<tr>
<td>Cookie[] getCookies();</td>
<td>获取请求中的所有cookie</td>
</tr>
<tr>
<td>HttpSession getSession();</td>
<td>获取Session对象</td>
</tr>
<tr>
<td>void setCharacterEncoding(String encoding) ;</td>
<td>设置请求体字符集</td>
</tr>
</tbody></table>
<h2 id="HttpServiceResponse"><a href="#HttpServiceResponse" class="headerlink" title="HttpServiceResponse"></a>HttpServiceResponse</h2><p>设置响应行相关</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>void setStatus(int  code);</td>
<td>设置响应状态码</td>
</tr>
</tbody></table>
<p>设置响应头相关</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>void setHeader(String headerName, String headerValue);</td>
<td>设置&#x2F;修改响应头键值对</td>
</tr>
<tr>
<td>void setContentType(String contentType);</td>
<td>设置content-type响应头及响应字符集(设置MIME类型)</td>
</tr>
</tbody></table>
<p>设置响应体相关</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>PrintWriter getWriter() throws IOException;</td>
<td>获得向响应体放入信息的字符输出流</td>
</tr>
<tr>
<td>ServletOutputStream getOutputStream() throws IOException;</td>
<td>获得向响应体放入信息的字节输出流</td>
</tr>
<tr>
<td>void setContentLength(int length);</td>
<td>设置响应体的字节长度,其实就是在设置content-length响应头</td>
</tr>
</tbody></table>
<p>其他API</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>void sendError(int code, String message) throws IOException;</td>
<td>向客户端响应错误信息的方法,需要指定响应码和响应信息</td>
</tr>
<tr>
<td>void addCookie(Cookie cookie);</td>
<td>向响应体中增加cookie</td>
</tr>
<tr>
<td>void setCharacterEncoding(String encoding);</td>
<td>设置响应体字符集</td>
</tr>
</tbody></table>
<blockquote>
<p>MIME类型</p>
</blockquote>
<ul>
<li>MIME类型,可以理解为文档类型,用户表示传递的数据是属于什么类型的文档</li>
<li>浏览器可以根据MIME类型决定该用什么样的方式解析接收到的响应体数据</li>
<li>可以这样理解: 前后端交互数据时,告诉对方发给对方的是 html&#x2F;css&#x2F;js&#x2F;图片&#x2F;声音&#x2F;视频&#x2F;… …</li>
<li>tomcat&#x2F;conf&#x2F;web.xml中配置了常见文件的拓展名和MIMIE类型的对应关系</li>
<li>常见的MIME类型举例如下</li>
</ul>
<table>
<thead>
<tr>
<th>文件拓展名</th>
<th>MIME类型</th>
</tr>
</thead>
<tbody><tr>
<td>.html</td>
<td>text&#x2F;html</td>
</tr>
<tr>
<td>.css</td>
<td>text&#x2F;css</td>
</tr>
<tr>
<td>.js</td>
<td>application&#x2F;javascript</td>
</tr>
<tr>
<td>.png &#x2F;.jpeg&#x2F;.jpg&#x2F;… …</td>
<td>image&#x2F;jpeg</td>
</tr>
<tr>
<td>.mp3&#x2F;.mpe&#x2F;.mpeg&#x2F; … …</td>
<td>audio&#x2F;mpeg</td>
</tr>
<tr>
<td>.mp4</td>
<td>video&#x2F;mp4</td>
</tr>
<tr>
<td>.m1v&#x2F;.m1v&#x2F;.m2v&#x2F;.mpe&#x2F;… …</td>
<td>video&#x2F;mpeg</td>
</tr>
</tbody></table>
<h2 id="请求转发和响应重定向"><a href="#请求转发和响应重定向" class="headerlink" title="请求转发和响应重定向"></a>请求转发和响应重定向</h2><p>请求转发和响应重定向是web应用中间接访问项目资源的两种手段,也是Servlet控制页面跳转的两种手段</p>
<p>请求转发通过HttpServletRequest实现,响应重定向通过HttpServletResponse实现</p>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p><strong>请求转发特点：</strong></p>
<ul>
<li>请求转发通过HttpServletRequest对象获取请求转发器实现</li>
<li>请求转发是服务器内部的行为,对客户端是屏蔽的</li>
<li>客户端只发送了一次请求,客户端地址栏不变</li>
<li>服务端只产生了一对请求和响应对象, 这一对请求和响应对象会继续传递给下一个资源</li>
<li>因为全程只有一个HttpServletRequset对象,所以请求参数可以传递,请求域中的数据也可以传递</li>
<li>请求转发可以转发给其他Servlet动态资源,也可以转发给一些静态资源以实现页面跳转</li>
<li>请求转发可以转发给WEB-INF下受保护的资源</li>
<li>请求转发不能转发到本项目以外的外部资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//  获取请求转发器</span></span><br><span class="line">        <span class="comment">//  转发给servlet  ok</span></span><br><span class="line">        <span class="type">RequestDispatcher</span>  <span class="variable">requestDispatcher</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;servletB&quot;</span>);</span><br><span class="line">        <span class="comment">//  转发给一个视图资源 ok</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;welcome.html&quot;);</span></span><br><span class="line">        <span class="comment">//  转发给WEB-INF下的资源  ok</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;);</span></span><br><span class="line">        <span class="comment">//  转发给外部资源   no</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  做出转发动作</span></span><br><span class="line">        requestDispatcher.forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="响应重定向"><a href="#响应重定向" class="headerlink" title="响应重定向"></a>响应重定向</h3><p><strong>响应重定向特点：</strong></p>
<ul>
<li>响应重定向通过HttpServletResponse对象的sendRedirect方法实现</li>
<li>响应重定向是服务端通过302响应码和路径,告诉客户端自己去找其他资源,是在服务端提示下的客户端的行为</li>
<li>客户端至少发送了两次请求,客户端地址栏是要变化的</li>
<li>服务端产生了多对请求和响应对象,且请求和响应对象不会传递给下一个资源</li>
<li>因为全程产生了多个HttpServletRequset对象,所以请求参数不可以传递,请求域中的数据也不可以传递</li>
<li>重定向可以是其他Servlet动态资源,也可以是一些静态资源以实现页面跳转</li>
<li>重定向不可以到给WEB-INF下受保护的资源</li>
<li>重定向可以到本项目以外的外部资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//  响应重定向</span></span><br><span class="line">        <span class="comment">// 重定向到servlet动态资源 OK</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;servletB&quot;</span>);</span><br><span class="line">        <span class="comment">// 重定向到视图静态资源 OK</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;welcome.html&quot;);</span></span><br><span class="line">        <span class="comment">// 重定向到WEB-INF下的资源 NO</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;WEB-INF/views/view1&quot;);</span></span><br><span class="line">        <span class="comment">// 重定向到外部资源 OK</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h2><p><strong>相对路径</strong></p>
<ul>
<li>相对路径的规则是: 以当前资源所在的路径为出发点去寻找目标资源</li>
<li>相对路径不以 &#x2F; 开头</li>
<li>在file协议下,使用的是磁盘路径</li>
<li>在http协议下,使用的是url路径</li>
<li>相对路径中可以使用 .&#x2F;表示当前资源所在路径,可以省略不写</li>
<li>相对路径中可以使用..&#x2F;表示当前资源所在路径的上一层路径,需要时要手动添加</li>
</ul>
<p><strong>绝对路径</strong></p>
<ul>
<li>绝对路径的规则是: 使用以一个固定的路径做出出发点去寻找目标资源,和当前资源所在的路径没有关系</li>
<li>绝对路径要以&#x2F; 开头</li>
<li>绝对路径的写法中,不以当前资源的所在路径为出发点,所以不会出现  .&#x2F; 和..&#x2F;</li>
<li>不同的项目和不同的协议下,绝对路径的基础位置可能不同,要通过测试确定</li>
<li>绝对路径的好处就是:无论当前资源位置在哪,寻找目标资源路径的写法都一致</li>
</ul>
<p><strong>base标签</strong></p>
<blockquote>
<p>base标签定义页面相对路径公共前缀</p>
</blockquote>
<ul>
<li>base 标签定义在head标签中,用于定义相对路径的公共前缀</li>
<li>base 标签定义的公共前缀只在相对路径上有效,绝对路径中无效</li>
<li>如果相对路径开头有 .&#x2F; 或者..&#x2F;修饰,则base标签对该路径同样无效</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义相对路径的公共前缀,将相对路径转化成了绝对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;/web03_war_exploded/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;static/img/logo.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>缺省项目上下文路径</strong></p>
<blockquote>
<p>项目上下文路径变化问题</p>
</blockquote>
<ul>
<li>通过 base标签虽然解决了相对路径转绝对路径问题,但是base中定义的是项目的上下文路径</li>
<li>项目的上下文路径是可以随意变化的</li>
<li>一旦项目的上下文路径发生变化,所有base标签中的路径都需要改</li>
</ul>
<blockquote>
<p>解决方案</p>
</blockquote>
<ul>
<li><strong>将项目的上下文路径进行缺省设置,设置为 &#x2F;,所有的绝对路径中就不必填写项目的上下文了,直接就是&#x2F;开头即可</strong></li>
</ul>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><blockquote>
<p>HTTP是无状态协议</p>
</blockquote>
<p>无状态就是不保存状态,即无状态协议(stateless),HTTP协议自身不对请求和响应之间的通信状态进行保存,也就是说,在HTTP协议这个级别,协议对于发送过的请求或者响应都不做持久化处理</p>
<p><strong>会话管理实现的手段</strong></p>
<blockquote>
<p>Cookie和Session配合解决</p>
</blockquote>
<ul>
<li>cookie是在客户端保留少量数据的技术,主要通过响应头向客户端响应一些客户端要保留的信息</li>
<li>session是在服务端保留更多数据的技术,主要通过HttpSession对象保存一些和客户端相关的信息</li>
<li>cookie和session配合记录请求状态</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>cookie是一种客户端会话技术,cookie由服务端产生,它是服务器存放在浏览器的一小份数据,浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去</p>
<ul>
<li>服务端创建cookie,将cookie放入响应对象中,Tomcat容器将cookie转化为set-cookie响应头,响应给客户端</li>
<li>客户端在收到cookie的响应头时,在下次请求该服务的资源时,会以cookie请求头的形式携带之前收到的Cookie</li>
<li>cookie是一种键值对格式的数据,从tomcat8.5开始可以保存中文,但是不推荐</li>
<li>由于cookie是存储于客户端的数据,比较容易暴露,一般不存储一些敏感或者影响安全的数据</li>
</ul>
<p>servletA向响应中增加Cookie</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>servletB从请求中读取Cookie</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求中的cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">//迭代cookies数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != cookies &amp;&amp; cookies.length!= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                System.out.println(cookie.getName()+<span class="string">&quot;:&quot;</span>+cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Cookie的时效性</strong></p>
<blockquote>
<p>默认情况下Cookie的有效期是一次会话范围内，我们可以通过cookie的setMaxAge()方法让Cookie持久化保存到浏览器上</p>
</blockquote>
<ul>
<li>会话级Cookie<ul>
<li>服务器端并没有明确指定Cookie的存在时间</li>
<li>在浏览器端，Cookie数据存在于内存中</li>
<li>只要浏览器还开着，Cookie数据就一直都在</li>
<li>浏览器关闭，内存中的Cookie数据就会被释放</li>
</ul>
</li>
<li>持久化Cookie<ul>
<li>服务器端明确设置了Cookie的存在时间</li>
<li>在浏览器端，Cookie数据会被保存到硬盘上</li>
<li>Cookie在硬盘上存在的时间根据服务器端限定的时间来管控，不受浏览器关闭的影响</li>
<li>持久化Cookie到达了预设的时间会被释放</li>
</ul>
</li>
</ul>
<blockquote>
<p>cookie.setMaxAge(int expiry)参数单位是秒，表示cookie的持久化时间，如果设置参数为0，表示将浏览器中保存的该cookie删除</p>
</blockquote>
<p>servletA设置一个Cookie为持久化cookie</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        cookie1.setMaxAge(<span class="number">60</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Cookie的提交路径</strong></p>
<blockquote>
<p>访问互联网资源时不能每次都需要把所有Cookie带上。访问不同的资源时,可以携带不同的cookie,我们可以通过cookie的setPath(String path) 对cookie的路径进行设置</p>
</blockquote>
<p>ServletA中设置cookie</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置cookie的提交路径</span></span><br><span class="line">        cookie1.setPath(<span class="string">&quot;/web03_war_exploded/servletB&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>HttpSession是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象. 客户端在发送请求时,都可以使用自己的session. 这样服务端就可以通过session来记录某个客户端的状态了(记录用户的登录状态, 记录用户操作的历史)</p>
<ul>
<li>服务端在为客户端创建session时,会同时将session对象的id,即JSESSIONID以cookie的形式放入响应对象</li>
<li>后端创建完session后,客户端会收到一个特殊的cookie,叫做JSESSIONID</li>
<li>客户端下一次请求时携带JSESSIONID,后端收到后,根据JSESSIONID找到对应的session对象</li>
<li>通过该机制,服务端通过session就可以存储一些专门针对某个客户端的信息了</li>
<li>session也是域对象</li>
</ul>
<p>定义ServletA, 将键值对存入session</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 向session对象中存入数据</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义其他Servlet,从session中读取参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 从session中取出数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HttpSession时效性</strong></p>
<ul>
<li><p>用户量很大之后，Session对象相应的也要创建很多。如果一味创建不释放，那么服务器端的内存迟早要被耗尽。所以可用定义时效性</p>
</li>
<li><p>客户端关闭行为无法被服务端直接侦测,或者客户端较长时间不操作也经常出现,类似这些的情况,就需要对session的时限进行设置了</p>
</li>
<li><p>默认的session最大闲置时间(两次使用同一个session中的间隔时间) 在tomcat&#x2F;conf&#x2F;web.xml配置为30分钟</p>
</li>
<li><p>可以自己在当前项目的web.xml对最大闲置时间进行重新设定 。或者通过HttpSession的API 对最大闲置时间进行设定</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最大闲置时间</span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">60</span>);</span><br><span class="line"><span class="comment">// 直接让session失效</span></span><br><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三大域"><a href="#三大域" class="headerlink" title="三大域"></a>三大域</h2><p>域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同</p>
<ul>
<li>请求域对象是HttpServletRequest ,传递数据的范围是一次请求之内及请求转发</li>
<li>会话域对象是HttpSession,传递数据的范围是一次会话之内,可以跨多个请求</li>
<li>应用域对象是ServletContext,传递数据的范围是本应用之内,可以跨多个会话</li>
</ul>
<blockquote>
<p>域对象的API</p>
</blockquote>
<table>
<thead>
<tr>
<th>API</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void setAttribute(String name,String value)</td>
<td>向域对象中添加&#x2F;修改数据</td>
</tr>
<tr>
<td>Object getAttribute(String name);</td>
<td>从域对象中获取数据</td>
</tr>
<tr>
<td>removeAttribute(String name);</td>
<td>移除域对象中的数据</td>
</tr>
</tbody></table>
<ul>
<li>请求转发时,请求域可以传递数据<code>请求域内一般放本次请求业务有关的数据,如:查询到的所有的部门信息</code></li>
<li>同一个会话内,不用请求转发,会话域可以传递数据<code>会话域内一般放本次会话的客户端有关的数据,如:当前客户端登录的用户</code> </li>
<li>同一个APP内,不同的客户端,应用域可以传递数据<code>应用域内一般放本程序应用有关的数据 如:Spring框架的IOC容器</code></li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul>
<li>Filter接口定义了过滤器的开发规范,所有的过滤器都要实现该接口</li>
<li>Filter的工作位置是项目中所有目标资源之前,容器在创建HttpServletRequest和HttpServletResponse对象后,会先调用Filter的doFilter方法</li>
<li>Filter的doFilter方法可以控制请求是否继续,如果放行,则请求继续,如果拒绝,则请求到此为止,由过滤器本身做出响应</li>
<li>Filter不仅可以对请求做出过滤,也可以在目标资源做出响应前,对响应再次进行处理</li>
<li>Filter是GOF中责任链模式的典型案例</li>
<li>Filter的常用应用包括但不限于: 登录权限检查,解决网站乱码,过滤敏感字符,日志记录,性能分析… …</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>default public void init(FilterConfig filterConfig)</td>
<td>初始化方法,由容器调用并传入初始配置信息filterConfig对象</td>
</tr>
<tr>
<td>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td>
<td>过滤方法,核心方法,过滤请求,决定是否放行,响应之前的其他处理等都在该方法中</td>
</tr>
<tr>
<td>default public void destroy()</td>
<td>销毁方法,容器在回收过滤器对象之前调用的方法</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span>  <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 参数父转子</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span>(HttpServletRequest)  servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span>  <span class="variable">response</span> <span class="operator">=</span>(HttpServletResponse)  servletResponse;</span><br><span class="line">        <span class="comment">// 拼接日志文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">beforeLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;被请求了&quot;</span>;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        System.out.println(beforeLogging);</span><br><span class="line">        <span class="comment">// 获取系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 放行请求</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">        <span class="comment">// 获取系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//  拼接日志文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">afterLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;的请求耗时:&quot;</span>+(t2-t1)+<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        System.out.println(afterLogging);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>doFilter方法中的请求和响应对象是以父接口的形式声明的,实际传入的实参就是HttpServletRequest和HttpServletResponse子接口级别的,可以安全强转</li>
<li>filterChain.doFilter(request,response); 这行代码的功能是放行请求,如果没有这一行代码,则请求到此为止</li>
<li>filterChain.doFilter(request,response);在放行时需要传入request和response,意味着请求和响应对象要继续传递给后续的资源,这里没有产生新的request和response对象</li>
</ul>
<p><strong>配置 web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置filter,并为filter起别名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.LoggingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过映射路径确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletA<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过后缀名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过servlet别名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletBName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>filter-mapping标签中定义了过滤器对那些资源进行过滤</li>
<li>子标签url-pattern通过映射路径确定过滤范围<ul>
<li>&#x2F;servletA  精确匹配,表示对servletA资源的请求进行过滤</li>
<li>*.html 表示对以.action结尾的路径进行过滤</li>
<li>&#x2F;* 表示对所有资源进行过滤</li>
<li>一个filter-mapping下可以配置多个url-pattern</li>
</ul>
</li>
<li>子标签servlet-name通过servlet别名确定对那些servlet进行过滤<ul>
<li>使用该标签确定目标资源的前提是servlet已经起了别名</li>
<li>一个filter-mapping下可以定义多个servlet-name</li>
<li>一个filter-mapping下,servlet-name和url-pattern子标签可以同时存在</li>
</ul>
</li>
</ul>
<h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote>
<p>过滤器作为web项目的组件之一,和Servlet的生命周期类似,略有不同,没有servlet的load-on-startup的配置,默认就是系统启动立刻构造</p>
</blockquote>
<table>
<thead>
<tr>
<th>阶段</th>
<th>对应方法</th>
<th>执行时机</th>
<th>执行次数</th>
</tr>
</thead>
<tbody><tr>
<td>创建对象</td>
<td>构造器</td>
<td>web应用启动时</td>
<td>1</td>
</tr>
<tr>
<td>初始化方法</td>
<td>void init(FilterConfig filterConfig)</td>
<td>构造完毕</td>
<td>1</td>
</tr>
<tr>
<td>过滤请求</td>
<td>void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</td>
<td>每次请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁</td>
<td>default void destroy()</td>
<td>web应用关闭时</td>
<td>1次</td>
</tr>
</tbody></table>
<h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>一个web项目中,可以同时定义多个过滤器,多个过滤器对同一个资源进行过滤时,工作位置有先后,整体形成一个工作链,称之为过滤器链</p>
<ul>
<li>过滤器链中的过滤器的顺序由filter-mapping顺序决定</li>
<li>每个过滤器过滤的范围不同,针对同一个资源来说,过滤器链中的过滤器个数可能是不同的</li>
<li>如果某个Filter是使用ServletName进行匹配规则的配置，那么这个Filter执行的优先级要更低</li>
</ul>
<p><strong>web.xml配置</strong>: 顺序由filter-mapping顺序决定</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter3<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter3<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--filter-mapping的顺序决定了过滤器的工作顺序--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter3<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注解配置</strong>: 顺序由过滤器类名字典序决定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(</span></span><br><span class="line"><span class="meta">        filterName = &quot;loggingFilter&quot;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name=&quot;dateTimePattern&quot;,value=&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;,</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/servletA&quot;,&quot;*.html&quot;&#125;,</span></span><br><span class="line"><span class="meta">        servletNames = &#123;&quot;servletBName&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>



<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><blockquote>
<p>监听器：专门用于对域对象对象身上发生的事件或状态改变进行监听和相应处理的对象</p>
</blockquote>
<ul>
<li><p>监听器是GOF设计模式中,观察者模式的典型案例</p>
</li>
<li><p>观察者模式: 当被观察的对象发生某些改变时, 观察者自动采取对应的行动的一种设计模式</p>
</li>
<li><p>监听器使用的感受类似JS中的事件,被观察的对象发生某些情况时,自动触发代码的执行</p>
</li>
<li><p>监听器并不监听web项目中的所有组件,仅仅是对三大域对象做相关的事件监听</p>
</li>
</ul>
<blockquote>
<p>监听器的分类</p>
</blockquote>
<ul>
<li><p>web中定义八个监听器接口作为监听器的规范,这八个接口按照不同的标准可以形成不同的分类</p>
</li>
<li><p>按监听的对象划分</p>
<ul>
<li>application域监听器 ServletContextListener  ServletContextAttributeListener </li>
<li>session域监听器 HttpSessionListener  HttpSessionAttributeListener  HttpSessionBindingListener  HttpSessionActivationListener  </li>
<li>request域监听器 ServletRequestListener  ServletRequestAttributeListener</li>
</ul>
</li>
<li><p>按监听的事件分</p>
<ul>
<li>域对象的创建和销毁监听器 ServletContextListener   HttpSessionListener   ServletRequestListener  </li>
<li>域对象数据增删改事件监听器 ServletContextAttributeListener  HttpSessionAttributeListener   ServletRequestAttributeListener </li>
<li>其他监听器  HttpSessionBindingListener  HttpSessionActivationListener</li>
</ul>
</li>
</ul>
<h3 id="application域监听器"><a href="#application域监听器" class="headerlink" title="application域监听器"></a>application域监听器</h3><blockquote>
<p>ServletContextListener  监听ServletContext对象的创建与销毁</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>contextInitialized(ServletContextEvent sce)</td>
<td>ServletContext创建时调用</td>
</tr>
<tr>
<td>contextDestroyed(ServletContextEvent sce)</td>
<td>ServletContext销毁时调用</td>
</tr>
</tbody></table>
<ul>
<li>ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。</li>
</ul>
<blockquote>
<p>ServletContextAttributeListener 监听ServletContext中属性的添加、移除和修改</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>attributeAdded(ServletContextAttributeEvent scab)</td>
<td>向ServletContext中添加属性时调用</td>
</tr>
<tr>
<td>attributeRemoved(ServletContextAttributeEvent scab)</td>
<td>从ServletContext中移除属性时调用</td>
</tr>
<tr>
<td>attributeReplaced(ServletContextAttributeEvent scab)</td>
<td>当ServletContext中的属性被修改时调用</td>
</tr>
</tbody></table>
<ul>
<li>ServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下：</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getName()</td>
<td>获取修改或添加的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取被修改或添加的属性值</td>
</tr>
<tr>
<td>getServletContext()</td>
<td>获取ServletContext对象</td>
</tr>
</tbody></table>
<h3 id="session域监听器"><a href="#session域监听器" class="headerlink" title="session域监听器"></a>session域监听器</h3><blockquote>
<p>HttpSessionListener  监听HttpSession对象的创建与销毁</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>sessionCreated(HttpSessionEvent hse)</td>
<td>HttpSession对象创建时调用</td>
</tr>
<tr>
<td>sessionDestroyed(HttpSessionEvent hse)</td>
<td>HttpSession对象销毁时调用</td>
</tr>
</tbody></table>
<ul>
<li>HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。</li>
</ul>
<blockquote>
<p>HttpSessionAttributeListener 监听HttpSession中属性的添加、移除和修改</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>attributeAdded(HttpSessionBindingEvent se)</td>
<td>向HttpSession中添加属性时调用</td>
</tr>
<tr>
<td>attributeRemoved(HttpSessionBindingEvent se)</td>
<td>从HttpSession中移除属性时调用</td>
</tr>
<tr>
<td>attributeReplaced(HttpSessionBindingEvent se)</td>
<td>当HttpSession中的属性被修改时调用</td>
</tr>
</tbody></table>
<ul>
<li>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getName()</td>
<td>获取修改或添加的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取被修改或添加的属性值</td>
</tr>
<tr>
<td>getSession()</td>
<td>获取触发事件的HttpSession对象</td>
</tr>
</tbody></table>
<h3 id="request域监听器"><a href="#request域监听器" class="headerlink" title="request域监听器"></a>request域监听器</h3><blockquote>
<p>ServletRequestListener 监听ServletRequest对象的创建与销毁</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>requestInitialized(ServletRequestEvent sre)</td>
<td>ServletRequest对象创建时调用</td>
</tr>
<tr>
<td>requestDestroyed(ServletRequestEvent sre)</td>
<td>ServletRequest对象销毁时调用</td>
</tr>
</tbody></table>
<ul>
<li>ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。</li>
</ul>
<blockquote>
<p>ServletRequestAttributeListener 监听ServletRequest中属性的添加、移除和修改</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>attributeAdded(ServletRequestAttributeEvent srae)</td>
<td>向ServletRequest中添加属性时调用</td>
</tr>
<tr>
<td>attributeRemoved(ServletRequestAttributeEvent srae)</td>
<td>从ServletRequest中移除属性时调用</td>
</tr>
<tr>
<td>attributeReplaced(ServletRequestAttributeEvent srae)</td>
<td>当ServletRequest中的属性被修改时调用</td>
</tr>
</tbody></table>
<ul>
<li>ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getName()</td>
<td>获取修改或添加的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取被修改或添加的属性值</td>
</tr>
<tr>
<td>getServletRequest ()</td>
<td>获取触发事件的ServletRequest对象</td>
</tr>
</tbody></table>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaWeb/">JavaWeb</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/12/maven/" title="Maven"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Maven</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/25/ssm/" title="SSM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SSM</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RonronnerW</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RonronnerW"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RonronnerW" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/wlbin_1019@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/2568998391" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat"><span class="toc-number">1.</span> <span class="toc-text">Tomcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">2.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet"><span class="toc-number">3.</span> <span class="toc-text">Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">运行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">Servlet继承结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.1.</span> <span class="toc-text">Servlet接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GenericServlet-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.4.2.</span> <span class="toc-text">GenericServlet 抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpServlet-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.4.3.</span> <span class="toc-text">HttpServlet 抽象类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServletConfig%E5%92%8CServletContext"><span class="toc-number">3.5.</span> <span class="toc-text">ServletConfig和ServletContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ServletConfig"><span class="toc-number">3.5.1.</span> <span class="toc-text">ServletConfig</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServletContext"><span class="toc-number">3.5.2.</span> <span class="toc-text">ServletContext</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HttpServiceRequest"><span class="toc-number">4.</span> <span class="toc-text">HttpServiceRequest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HttpServiceResponse"><span class="toc-number">5.</span> <span class="toc-text">HttpServiceResponse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E5%93%8D%E5%BA%94%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.</span> <span class="toc-text">请求转发和响应重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91"><span class="toc-number">6.1.</span> <span class="toc-text">请求转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.2.</span> <span class="toc-text">响应重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">8.</span> <span class="toc-text">会话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">8.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session"><span class="toc-number">8.2.</span> <span class="toc-text">Session</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%9F%9F"><span class="toc-number">9.</span> <span class="toc-text">三大域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1"><span class="toc-number">10.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE"><span class="toc-number">10.2.</span> <span class="toc-text">过滤器链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#application%E5%9F%9F%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">application域监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session%E5%9F%9F%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">11.2.</span> <span class="toc-text">session域监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request%E5%9F%9F%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">11.3.</span> <span class="toc-text">request域监听器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/21/docker/" title="docker">docker</a><time datetime="2023-12-21T06:03:40.000Z" title="发表于 2023-12-21 14:03:40">2023-12-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/10/linux/" title="Linux">Linux</a><time datetime="2023-12-10T01:50:41.000Z" title="发表于 2023-12-10 09:50:41">2023-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/07/yu-cuo-ji-he/" title="遇错集合">遇错集合</a><time datetime="2023-12-07T08:09:00.000Z" title="发表于 2023-12-07 16:09:00">2023-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/06/ling-san-zhi-shi/" title="零散知识">零散知识</a><time datetime="2023-12-06T07:34:12.000Z" title="发表于 2023-12-06 15:34:12">2023-12-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By RonronnerW</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2023/11/21/javaweb/'
    this.page.identifier = '/2023/11/21/javaweb/'
    this.page.title = 'JavaWeb'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>